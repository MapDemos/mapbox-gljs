<html>
<head>
  <meta charset="utf-8" />
  <title>Travel Highlights 2024</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Left menu panel */
    #left-menu {
      width: 300px;
      background: rgba(30, 30, 40, 0.95);
      backdrop-filter: blur(10px);
      display: flex;
      flex-direction: column;
      padding: 20px;
      box-shadow: 2px 0 20px rgba(0,0,0,0.3);
      overflow-y: auto;
      flex-shrink: 0;
    }

    #map {
      flex: 1;
      position: relative;
    }

    #left-menu h2 {
      color: white;
      font-size: 24px;
      font-weight: 700;
      margin: 0 0 20px 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #tour-title-input {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: white;
      font-size: 20px;
      font-weight: 700;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      box-sizing: border-box;
      margin-bottom: 20px;
    }

    #tour-title-input:focus {
      outline: none;
      border-color: #667eea;
      background: rgba(255, 255, 255, 0.15);
    }

    #left-menu .menu-section {
      margin-bottom: 20px;
    }

    #left-menu .menu-section h3 {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      font-weight: 600;
      margin: 0 0 10px 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    /* Destination label */
    #destination-label {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 40px;
      border-radius: 12px;
      font-size: 32px;
      font-weight: 700;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
      text-align: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #destination-label.show {
      opacity: 1;
    }

    #distance-counter {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 30px;
      border-radius: 10px;
      font-size: 28px;
      font-weight: 700;
      z-index: 1000;
      pointer-events: none;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      letter-spacing: 1px;
    }

    #distance-counter span {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      margin-left: 5px;
      font-weight: 400;
    }

    /* Completion Modal */
    #completion-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30, 30, 40, 0.98);
      backdrop-filter: blur(20px);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      z-index: 2000;
      display: none;
      max-width: 550px;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .modal-close-icon {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      font-size: 32px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.2s;
      padding: 0;
    }

    .modal-close-icon:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: rotate(90deg);
    }

    #completion-modal.show {
      display: block;
      animation: modalFadeIn 0.5s ease-out;
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -45%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }

    #completion-modal h2 {
      color: white;
      font-size: 32px;
      font-weight: 700;
      margin: 0 0 10px 0;
      text-align: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #completion-modal .subtitle {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-align: center;
      margin-bottom: 30px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .route-summary {
      background: rgba(255, 255, 255, 0.05);
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .route-summary-name {
      color: white;
      font-size: 14px;
      flex: 1;
    }

    .route-summary-distance {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      font-weight: 600;
      margin-left: 20px;
    }

    .total-summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
      text-align: center;
    }

    .total-summary-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .total-summary-value {
      color: white;
      font-size: 36px;
      font-weight: 700;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #completion-modal .close-btn {
      width: 100%;
      padding: 14px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.2s;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #completion-modal .close-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Confetti */
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #f0f;
      pointer-events: none;
      z-index: 1999;
    }

    @keyframes confettiFall {
      to {
        transform: translateY(100vh) translateX(var(--drift)) rotate(720deg);
        opacity: 0;
      }
    }

    .btn {
      width: 100%;
      padding: 12px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Edit mode info in menu */
    #edit-mode-info {
      background: rgba(102, 126, 234, 0.15);
      padding: 12px;
      border-radius: 6px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.5;
      border-left: 3px solid #667eea;
    }

    /* Control point marker styles */
    .control-point-marker {
      width: 20px;
      height: 20px;
      background: white;
      border: 3px solid #667eea;
      border-radius: 50%;
      cursor: move;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: all 0.2s;
    }

    .control-point-marker:hover {
      width: 24px;
      height: 24px;
      border-width: 4px;
      box-shadow: 0 3px 12px rgba(102, 126, 234, 0.5);
    }

    .control-point-marker.train {
      border-color: #ff0000;
    }

    .control-point-marker.plane {
      border-color: #ffffff;
    }

    .control-point-marker.car {
      border-color: #ff8800;
    }

    /* Route list styles */
    .route-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
      border-left: 3px solid #667eea;
      transition: all 0.2s;
      cursor: grab;
      user-select: none;
    }

    .route-item:hover {
      background: rgba(255, 255, 255, 0.08);
      transform: translateX(2px);
    }

    .route-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .route-item.drag-over {
      border-top: 2px solid #667eea;
      margin-top: 8px;
    }

    .route-item.plane {
      border-left-color: #ffffff;
    }

    .route-item.train {
      border-left-color: #ff0000;
    }

    .route-item.car {
      border-left-color: #ff8800;
    }

    .route-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .route-info {
      flex: 1;
    }

    .route-destinations {
      color: white;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .route-vehicle {
      color: rgba(255, 255, 255, 0.6);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .route-actions {
      display: flex;
      gap: 4px;
    }

    .route-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .route-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .route-btn.delete {
      background: rgba(220, 38, 38, 0.2);
    }

    .route-btn.delete:hover {
      background: rgba(220, 38, 38, 0.4);
    }

    #routes-list {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 12px;
    }

    #routes-list::-webkit-scrollbar {
      width: 6px;
    }

    #routes-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    #routes-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    #routes-list::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Edit route modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: rgba(30, 30, 40, 0.98);
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .modal h3 {
      color: white;
      margin: 0 0 20px 0;
      font-size: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group label {
      display: block;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: white;
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      box-sizing: border-box;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: #667eea;
      background: rgba(255, 255, 255, 0.08);
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      margin-top: 20px;
    }

    .modal-actions button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    .modal-actions .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .modal-actions .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .modal-actions .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .modal-actions .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Custom Autocomplete Styles */
    .city-input-wrapper {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .autocomplete-wrapper {
      position: relative;
      flex: 1;
    }

    .autocomplete-wrapper input[type="text"] {
      width: 100%;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      box-sizing: border-box;
    }

    .autocomplete-wrapper input[type="text"]:focus {
      outline: none;
      border-color: rgba(102, 126, 234, 0.6);
      background: rgba(255, 255, 255, 0.15);
    }

    .autocomplete-wrapper input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .flag-display {
      width: 50px;
      height: 46px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      font-size: 24px;
      flex-shrink: 0;
    }

    .suggestions-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(30, 30, 40, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .suggestions-dropdown.show {
      display: block;
    }

    .suggestion-item {
      padding: 12px;
      cursor: pointer;
      color: white;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: background 0.2s;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover {
      background: rgba(102, 126, 234, 0.2);
    }

    .suggestion-item .suggestion-name {
      font-weight: 600;
      font-size: 14px;
    }

    .suggestion-item .suggestion-place {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <div id="left-menu">
    <input type="text" id="tour-title-input" value="Travel Highlights" placeholder="Enter tour title..." />

    <div class="menu-section">
      <h3>Controls</h3>
      <div style="margin-bottom: 12px;">
        <label style="display: flex; align-items: center; color: white; font-size: 14px; cursor: pointer;">
          <input type="checkbox" id="record-checkbox" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;" />
          <span>Record tour as video</span>
        </label>
      </div>
      <button id="start-btn" class="btn" onclick="saveAndStartTour()">Save &amp; Start Tour</button>
      <button id="edit-btn" class="btn" onclick="enterEditMode()" style="display: none;">Edit Routes</button>
    </div>

    <div id="edit-mode-info" style="display: none;">
      Click on a route line to add control points. Right-click markers to delete them.
    </div>

    <div class="menu-section">
      <h3>Routes</h3>
      <div id="routes-list"></div>
      <button id="add-route-btn" class="btn" onclick="addNewRoute()">+ Add Route</button>
    </div>
  </div>
  <div id="map">
    <div id="destination-label"></div>
    <div id="distance-counter">0 <span>km</span></div>

    <!-- Completion Modal -->
    <div id="completion-modal">
      <button onclick="closeCompletionModal()" class="modal-close-icon">&times;</button>
      <h2 id="completion-modal-title" style="color: white; margin: 0 0 24px 0; font-size: 28px; text-align: center;">Tour Complete!</h2>
      <div id="routes-summary"></div>
      <div class="total-summary">
        <div style="color: rgba(255, 255, 255, 0.8); font-size: 14px; font-weight: 600; margin-bottom: 8px;">TOTAL DISTANCE</div>
        <div id="total-distance" style="color: white; font-size: 32px; font-weight: bold;"></div>
      </div>
    </div>
  </div>

  <!-- Edit Route Modal -->
  <div id="edit-route-modal" class="modal-overlay">
    <div class="modal">
      <h3 id="modal-title">Edit Route</h3>
      <div class="form-group">
        <label>Origin Location</label>
        <div class="city-input-wrapper">
          <div class="autocomplete-wrapper">
            <input type="text" id="route-origin-input" placeholder="Search for a city..." autocomplete="off" />
            <div id="origin-suggestions" class="suggestions-dropdown"></div>
          </div>
          <div class="flag-display" id="route-origin-flag"></div>
        </div>
        <input type="hidden" id="route-origin-name" />
        <input type="hidden" id="route-origin-coords" />
        <input type="hidden" id="route-origin-flag-value" />
      </div>
      <div class="form-group">
        <label>Destination Location</label>
        <div class="city-input-wrapper">
          <div class="autocomplete-wrapper">
            <input type="text" id="route-destination-input" placeholder="Search for a city..." autocomplete="off" />
            <div id="destination-suggestions" class="suggestions-dropdown"></div>
          </div>
          <div class="flag-display" id="route-destination-flag"></div>
        </div>
        <input type="hidden" id="route-destination" />
        <input type="hidden" id="route-coords" />
        <input type="hidden" id="route-destination-flag-value" />
      </div>
      <div class="form-group">
        <label>Vehicle</label>
        <select id="route-vehicle">
          <option value="plane">Plane</option>
          <option value="train">Train</option>
          <option value="car">Car</option>
        </select>
      </div>
      <div class="modal-actions">
        <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
        <button class="btn-primary" onclick="saveRoute()">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Asset helper function
    function asset(uri) {
      return `https://docs.mapbox.com/mapbox-gl-js/assets/${uri}`;
    }

    const airplaneModelUri = asset('airplane.glb');
    const trainModelUri = 'https://kenji-shima.github.io/resource-files/models/tram.glb';
    const carModelUri = asset('ego_car.glb');

    // Define your travel routes - each route is independent with explicit origin and destination
    // Each route has: origin (name, coords), destination (name, coords), vehicle type
    const destinations = [
      { origin: { name: 'Narita', coords: [140.3929, 35.7719] }, name: 'San Francisco', coords: [-122.4194, 37.7749], flag: 'ðŸ‡ºðŸ‡¸', vehicle: 'plane' },
      { origin: { name: 'San Francisco', coords: [-122.4194, 37.7749] }, name: 'Phoenix', coords: [-112.0740, 33.4484], flag: 'ðŸ‡ºðŸ‡¸', vehicle: 'plane' },
      { origin: { name: 'Phoenix', coords: [-112.0740, 33.4484] }, name: 'Mexico City', coords: [-99.1332, 19.4326], flag: 'ðŸ‡²ðŸ‡½', vehicle: 'plane' },
      { origin: { name: 'Mexico City', coords: [-99.1332, 19.4326] }, name: 'San Francisco', coords: [-122.4194, 37.7749], flag: 'ðŸ‡ºðŸ‡¸', vehicle: 'plane' },
      { origin: { name: 'San Francisco', coords: [-122.4194, 37.7749] }, name: 'Narita', coords: [140.3929, 35.7719], flag: 'ðŸ‡¯ðŸ‡µ', vehicle: 'plane' },
      { origin: { name: 'Narita', coords: [140.3929, 35.7719] }, name: 'Bangkok', coords: [100.5018, 13.7563], flag: 'ðŸ‡¹ðŸ‡­', vehicle: 'plane' },
      { origin: { name: 'Bangkok', coords: [100.5018, 13.7563] }, name: 'Haneda', coords: [139.7798, 35.5494], flag: 'ðŸ‡¯ðŸ‡µ', vehicle: 'plane' },
      { origin: { name: 'Haneda', coords: [139.7798, 35.5494] }, name: 'Hanoi', coords: [105.8542, 21.0285], flag: 'ðŸ‡»ðŸ‡³', vehicle: 'car' },
      { origin: { name: 'Hanoi', coords: [105.8542, 21.0285] }, name: 'Ha Long', coords: [107.0843, 20.9101], flag: 'ðŸ‡»ðŸ‡³', vehicle: 'car' },
      { origin: { name: 'Ha Long', coords: [107.0843, 20.9101] }, name: 'Hanoi', coords: [105.8542, 21.0285], flag: 'ðŸ‡»ðŸ‡³', vehicle: 'car' },
      { origin: { name: 'Hanoi', coords: [105.8542, 21.0285] }, name: 'Da Nang', coords: [108.2022, 16.0544], flag: 'ðŸ‡»ðŸ‡³', vehicle: 'plane' },
      { origin: { name: 'Da Nang', coords: [108.2022, 16.0544] }, name: 'Saigon', coords: [106.6297, 10.8231], flag: 'ðŸ‡»ðŸ‡³', vehicle: 'plane' },
      { origin: { name: 'Saigon', coords: [106.6297, 10.8231] }, name: 'Haneda', coords: [139.7798, 35.5494], flag: 'ðŸ‡¯ðŸ‡µ', vehicle: 'plane' },
      { origin: { name: 'Haneda', coords: [139.7798, 35.5494] }, name: 'Prague', coords: [14.4378, 50.0755], flag: 'ðŸ‡¨ðŸ‡¿', vehicle: 'train' },
      { origin: { name: 'Prague', coords: [14.4378, 50.0755] }, name: 'Budapest', coords: [19.0402, 47.4979], flag: 'ðŸ‡­ðŸ‡º', vehicle: 'train' },
      { origin: { name: 'Budapest', coords: [19.0402, 47.4979] }, name: 'Vienna', coords: [16.3738, 48.2082], flag: 'ðŸ‡¦ðŸ‡¹', vehicle: 'train' },
      { origin: { name: 'Vienna', coords: [16.3738, 48.2082] }, name: 'Prague', coords: [14.4378, 50.0755], flag: 'ðŸ‡¨ðŸ‡¿', vehicle: 'plane' },
      { origin: { name: 'Prague', coords: [14.4378, 50.0755] }, name: 'Haneda', coords: [139.7798, 35.5494], flag: 'ðŸ‡¯ðŸ‡µ', vehicle: 'plane' },
      { origin: { name: 'Haneda', coords: [139.7798, 35.5494] }, name: 'Osaka', coords: [135.5023, 34.6937], flag: 'ðŸ‡¯ðŸ‡µ', vehicle: 'plane' }
    ];

    // Route management state
    let editingRouteIndex = null;
    let draggedRouteIndex = null;

    // Distance tracking
    let totalAccumulatedDistance = 0; // Total distance traveled in km
    let completedLegsDistance = 0; // Distance from completed legs

    // Recording state
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let recordingCanvas = null;
    let recordingContext = null;
    let recordingInterval = null;

    // Autocomplete state
    let selectedOriginCoords = null;
    let selectedDestinationCoords = null;
    let originSessionToken = null;
    let destinationSessionToken = null;
    let originSuggestions = [];
    let destinationSuggestions = [];

    // Generate a random session token for search
    function generateSessionToken() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // Convert country code to flag emoji
    function countryCodeToFlag(countryCode) {
      if (!countryCode) return '';
      return countryCode
        .toUpperCase()
        .split('')
        .map(char => String.fromCodePoint(0x1F1E6 + char.charCodeAt(0) - 65))
        .join('');
    }

    // Initialize custom autocomplete
    function initializeAutocomplete() {
      const originInput = document.getElementById('route-origin-input');
      const destinationInput = document.getElementById('route-destination-input');
      const originDropdown = document.getElementById('origin-suggestions');
      const destinationDropdown = document.getElementById('destination-suggestions');

      // Origin input handler
      let originDebounceTimer;
      originInput.addEventListener('input', () => {
        const query = originInput.value.trim();
        clearTimeout(originDebounceTimer);

        if (query.length < 2) {
          originDropdown.classList.remove('show');
          return;
        }

        originDebounceTimer = setTimeout(() => {
          searchCities(query, 'origin');
        }, 300);
      });

      // Destination input handler
      let destinationDebounceTimer;
      destinationInput.addEventListener('input', () => {
        const query = destinationInput.value.trim();
        clearTimeout(destinationDebounceTimer);

        if (query.length < 2) {
          destinationDropdown.classList.remove('show');
          return;
        }

        destinationDebounceTimer = setTimeout(() => {
          searchCities(query, 'destination');
        }, 300);
      });

      // Close dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-wrapper')) {
          originDropdown.classList.remove('show');
          destinationDropdown.classList.remove('show');
        }
      });
    }

    // Search cities using Mapbox SearchBox API
    async function searchCities(query, type) {
      const accessToken = mapboxgl.accessToken;
      const dropdown = document.getElementById(`${type}-suggestions`);

      // Generate or reuse session token
      if (type === 'origin' && !originSessionToken) {
        originSessionToken = generateSessionToken();
      } else if (type === 'destination' && !destinationSessionToken) {
        destinationSessionToken = generateSessionToken();
      }

      const sessionToken = type === 'origin' ? originSessionToken : destinationSessionToken;

      try {
        const response = await fetch(
          `https://api.mapbox.com/search/searchbox/v1/suggest?q=${encodeURIComponent(query)}&access_token=${accessToken}&language=en&session_token=${sessionToken}&types=region,district,place,city,locality,neighborhood`
        );

        const data = await response.json();

        if (data.suggestions && data.suggestions.length > 0) {
          if (type === 'origin') {
            originSuggestions = data.suggestions;
          } else {
            destinationSuggestions = data.suggestions;
          }
          renderSuggestions(data.suggestions, type);
        } else {
          dropdown.classList.remove('show');
        }
      } catch (error) {
        console.error('Error searching cities:', error);
        dropdown.classList.remove('show');
      }
    }

    // Render suggestions in dropdown
    function renderSuggestions(suggestions, type) {
      const dropdown = document.getElementById(`${type}-suggestions`);
      dropdown.innerHTML = '';

      suggestions.forEach((suggestion, index) => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.innerHTML = `
          <div class="suggestion-name">${suggestion.name}</div>
          <div class="suggestion-place">${suggestion.place_formatted}</div>
        `;

        item.addEventListener('click', () => {
          selectSuggestion(suggestion, type);
        });

        dropdown.appendChild(item);
      });

      dropdown.classList.add('show');
    }

    // Handle suggestion selection and retrieve full details
    async function selectSuggestion(suggestion, type) {
      const accessToken = mapboxgl.accessToken;
      const input = document.getElementById(`${type === 'origin' ? 'route-origin-input' : 'route-destination-input'}`);
      const dropdown = document.getElementById(`${type}-suggestions`);
      const sessionToken = type === 'origin' ? originSessionToken : destinationSessionToken;

      // Show the selected name in input
      input.value = suggestion.name;
      dropdown.classList.remove('show');

      try {
        // Call retrieve API to get coordinates
        const response = await fetch(
          `https://api.mapbox.com/search/searchbox/v1/retrieve/${suggestion.mapbox_id}?access_token=${accessToken}&session_token=${sessionToken}`
        );

        const data = await response.json();
        const feature = data.features[0];

        if (feature && feature.geometry && feature.geometry.coordinates) {
          const coords = feature.geometry.coordinates;
          const name = feature.properties.name || feature.properties.place_name;

          // Get country code from feature context
          const countryCode = feature.properties.context?.country?.country_code;
          const flag = countryCodeToFlag(countryCode);

          if (type === 'origin') {
            selectedOriginCoords = coords;
            document.getElementById('route-origin-name').value = name;
            document.getElementById('route-origin-coords').value = `${coords[0]}, ${coords[1]}`;
            // Auto-set flag display and hidden value
            if (flag) {
              document.getElementById('route-origin-flag').textContent = flag;
              document.getElementById('route-origin-flag-value').value = flag;
            }
            // Reset session token after successful retrieval
            originSessionToken = null;
          } else {
            selectedDestinationCoords = coords;
            document.getElementById('route-destination').value = name;
            document.getElementById('route-coords').value = `${coords[0]}, ${coords[1]}`;
            // Auto-set flag display and hidden value
            if (flag) {
              document.getElementById('route-destination-flag').textContent = flag;
              document.getElementById('route-destination-flag-value').value = flag;
            }
            // Reset session token after successful retrieval
            destinationSessionToken = null;
          }
        }
      } catch (error) {
        console.error('Error retrieving location details:', error);
      }
    }

    // Render routes list in the menu
    function renderRoutesList() {
      const routesList = document.getElementById('routes-list');
      routesList.innerHTML = '';

      for (let i = 0; i < destinations.length; i++) {
        const route = destinations[i];

        // Use explicit origin
        const origin = route.origin ? route.origin.name : 'Unknown';
        const destination = route.name;
        const vehicle = route.vehicle || 'plane';

        const routeItem = document.createElement('div');
        routeItem.className = `route-item ${vehicle}`;
        routeItem.draggable = true;
        routeItem.dataset.index = i;
        routeItem.innerHTML = `
          <div class="route-header">
            <div class="route-info">
              <div class="route-destinations">${origin} â†’ ${destination}</div>
              <div class="route-vehicle">${vehicle} ${route.flag || ''}</div>
            </div>
            <div class="route-actions">
              <button class="route-btn" onclick="editRoute(${i})">Edit</button>
              <button class="route-btn delete" onclick="deleteRoute(${i})">Delete</button>
            </div>
          </div>
        `;

        // Add drag event listeners
        routeItem.addEventListener('dragstart', handleDragStart);
        routeItem.addEventListener('dragover', handleDragOver);
        routeItem.addEventListener('drop', handleDrop);
        routeItem.addEventListener('dragend', handleDragEnd);
        routeItem.addEventListener('dragenter', handleDragEnter);
        routeItem.addEventListener('dragleave', handleDragLeave);

        routesList.appendChild(routeItem);
      }
    }

    // Drag and drop handlers
    function handleDragStart(e) {
      draggedRouteIndex = parseInt(e.currentTarget.dataset.index);
      e.currentTarget.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', e.currentTarget.innerHTML);
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnter(e) {
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }

      e.currentTarget.classList.remove('drag-over');

      const dropIndex = parseInt(e.currentTarget.dataset.index);

      if (draggedRouteIndex !== null && draggedRouteIndex !== dropIndex) {
        // Remove dragged item from array
        const draggedItem = destinations[draggedRouteIndex];
        destinations.splice(draggedRouteIndex, 1);

        // After removing, adjust the drop index if needed
        // If we removed an item before the drop position, shift down by 1
        const adjustedDropIndex = draggedRouteIndex < dropIndex ? dropIndex - 1 : dropIndex;

        // Insert at the adjusted position
        destinations.splice(adjustedDropIndex, 0, draggedItem);

        renderRoutesList();
      }

      return false;
    }

    function handleDragEnd(e) {
      e.currentTarget.classList.remove('dragging');

      // Remove drag-over class from all items
      document.querySelectorAll('.route-item').forEach(item => {
        item.classList.remove('drag-over');
      });

      draggedRouteIndex = null;
    }

    // Open modal to edit route
    function editRoute(index) {
      editingRouteIndex = index;
      const route = destinations[index];

      document.getElementById('modal-title').textContent = 'Edit Route';

      // Set input values
      if (route.origin) {
        document.getElementById('route-origin-input').value = route.origin.name;
        document.getElementById('route-origin-name').value = route.origin.name;
        document.getElementById('route-origin-coords').value = `${route.origin.coords[0]}, ${route.origin.coords[1]}`;
        selectedOriginCoords = route.origin.coords;
        // Set origin flag display and value if available
        if (route.origin.flag) {
          document.getElementById('route-origin-flag').textContent = route.origin.flag;
          document.getElementById('route-origin-flag-value').value = route.origin.flag;
        }
      }

      if (route.name) {
        document.getElementById('route-destination-input').value = route.name;
        document.getElementById('route-destination').value = route.name;
        document.getElementById('route-coords').value = `${route.coords[0]}, ${route.coords[1]}`;
        selectedDestinationCoords = route.coords;
      }

      // Set destination flag display and value
      document.getElementById('route-destination-flag').textContent = route.flag || '';
      document.getElementById('route-destination-flag-value').value = route.flag || '';
      document.getElementById('route-vehicle').value = route.vehicle || 'plane';

      document.getElementById('edit-route-modal').classList.add('show');
    }

    // Open modal to add new route
    function addNewRoute() {
      editingRouteIndex = null;

      document.getElementById('modal-title').textContent = 'Add New Route';

      // Clear input values
      document.getElementById('route-origin-input').value = '';
      document.getElementById('route-destination-input').value = '';
      document.getElementById('route-origin-name').value = '';
      document.getElementById('route-origin-coords').value = '';
      document.getElementById('route-destination').value = '';
      document.getElementById('route-coords').value = '';
      document.getElementById('route-vehicle').value = 'plane';

      // Clear flag displays and values
      document.getElementById('route-origin-flag').textContent = '';
      document.getElementById('route-origin-flag-value').value = '';
      document.getElementById('route-destination-flag').textContent = '';
      document.getElementById('route-destination-flag-value').value = '';

      selectedOriginCoords = null;
      selectedDestinationCoords = null;

      // Reset session tokens
      originSessionToken = null;
      destinationSessionToken = null;

      document.getElementById('edit-route-modal').classList.add('show');
    }

    // Close the edit modal
    // Format number with commas
    function formatNumberWithCommas(num) {
      return Math.round(num).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Start recording - canvas only (automatic, no prompts)
    async function startRecording() {
      try {
        const canvas = map.getCanvas();
        const stream = canvas.captureStream(30); // 30 fps

        mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 5000000
        });

        recordedChunks = [];
        isRecording = true;

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          downloadRecording();
        };

        mediaRecorder.start();
        console.log('Recording started (map canvas only)');

        // Show notification
        const notification = document.createElement('div');
        notification.id = 'recording-indicator';
        notification.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(220, 38, 38, 0.95); color: white; padding: 12px 24px; border-radius: 20px; z-index: 10000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto; font-size: 13px; font-weight: 600; display: flex; align-items: center; gap: 8px;';
        notification.innerHTML = '<span style="width: 8px; height: 8px; background: white; border-radius: 50%; animation: pulse 1.5s ease-in-out infinite;"></span>Recording';
        document.body.appendChild(notification);

        // Add pulse animation
        const style = document.createElement('style');
        style.textContent = '@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }';
        document.head.appendChild(style);

      } catch (error) {
        console.error('Error starting recording:', error);
        alert('Could not start recording: ' + error.message);
        isRecording = false;
      }
    }

    // Stop recording
    function stopRecording() {
      if (mediaRecorder && isRecording) {
        isRecording = false;
        mediaRecorder.stop();
        console.log('Recording stopped');

        // Remove recording indicator
        const indicator = document.getElementById('recording-indicator');
        if (indicator) {
          indicator.remove();
        }
      }
    }

    // Download the recorded video
    function downloadRecording() {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const tourTitle = document.getElementById('tour-title-input').value || 'Travel Highlights';
      const filename = `${tourTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_tour.webm`;

      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();

      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);

      console.log('Recording downloaded:', filename);
    }

    // Confetti animation
    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#ff69b4'];
      const mapElement = document.getElementById('map');
      const confettiCount = 100;

      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.top = '-10px';
          confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.width = (Math.random() * 10 + 5) + 'px';
          confetti.style.height = (Math.random() * 10 + 5) + 'px';
          confetti.style.opacity = Math.random() * 0.5 + 0.5;
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

          const duration = Math.random() * 3 + 2;
          const drift = (Math.random() - 0.5) * 200;

          confetti.style.animation = `confettiFall ${duration}s linear forwards`;
          confetti.style.setProperty('--drift', drift + 'px');

          mapElement.appendChild(confetti);

          setTimeout(() => {
            confetti.remove();
          }, duration * 1000);
        }, i * 30);
      }
    }

    // Show completion modal with route summary
    function showCompletionModal() {
      const modal = document.getElementById('completion-modal');
      const summary = document.getElementById('routes-summary');
      const totalDistanceEl = document.getElementById('total-distance');
      const modalTitle = document.getElementById('completion-modal-title');
      const tourTitle = document.getElementById('tour-title-input').value || 'Travel Highlights';

      // Update modal title with tour title
      modalTitle.textContent = tourTitle;

      // Clear previous content
      summary.innerHTML = '';

      // Vehicle emoji mapping
      const vehicleEmoji = {
        'plane': 'âœˆï¸',
        'train': 'ðŸš†',
        'car': 'ðŸš—'
      };

      // Calculate total distance and create route summaries
      let totalDistance = 0;
      destinations.forEach((route, index) => {
        const distance = route.actualDistance || 0;
        totalDistance += distance;
        const vehicle = route.vehicle || 'plane';

        const routeDiv = document.createElement('div');
        routeDiv.className = 'route-summary';
        routeDiv.innerHTML = `
          <div>
            <span style="font-size: 18px; margin-right: 8px;">${route.origin.flag || ''}</span>
            <span style="color: white; font-weight: 600;">${route.origin.name}</span>
            <span style="color: rgba(255,255,255,0.5); margin: 0 8px;">â†’</span>
            <span style="font-size: 18px; margin-right: 8px;">${route.flag || ''}</span>
            <span style="color: white; font-weight: 600;">${route.name}</span>
          </div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 20px;">${vehicleEmoji[vehicle]}</span>
            <span style="color: #667eea; font-weight: 700;">${formatNumberWithCommas(distance)} km</span>
          </div>
        `;
        summary.appendChild(routeDiv);
      });

      // Set total distance
      totalDistanceEl.textContent = `${formatNumberWithCommas(totalDistance)} km`;

      // Show modal with fade-in
      modal.style.display = 'block';
      setTimeout(() => {
        modal.style.opacity = '1';
      }, 10);

      // Trigger confetti
      createConfetti();

      // Auto-scroll to bottom smoothly after modal appears
      setTimeout(() => {
        modal.scrollTo({
          top: modal.scrollHeight,
          behavior: 'smooth'
        });

        // Stop recording after showing the modal
        if (isRecording) {
          setTimeout(() => {
            stopRecording();
          }, 3000); // 3 seconds after scroll to show final state
        }
      }, 500);
    }

    // Close completion modal
    function closeCompletionModal() {
      const modal = document.getElementById('completion-modal');
      modal.style.opacity = '0';
      setTimeout(() => {
        modal.style.display = 'none';
      }, 300);
    }

    function closeEditModal() {
      document.getElementById('edit-route-modal').classList.remove('show');
      editingRouteIndex = null;
    }

    // Save route changes
    function saveRoute() {
      const originName = document.getElementById('route-origin-name').value.trim();
      const originCoordsStr = document.getElementById('route-origin-coords').value.trim();
      const originFlag = document.getElementById('route-origin-flag-value').value.trim();
      const destinationName = document.getElementById('route-destination').value.trim();
      const destCoordsStr = document.getElementById('route-coords').value.trim();
      const destinationFlag = document.getElementById('route-destination-flag-value').value.trim();
      const vehicle = document.getElementById('route-vehicle').value;

      // Validate required fields
      if (!originName) {
        alert('Please enter an origin city name');
        return;
      }

      if (!originCoordsStr) {
        alert('Please enter origin coordinates');
        return;
      }

      if (!destinationName) {
        alert('Please enter a destination city name');
        return;
      }

      if (!destCoordsStr) {
        alert('Please enter destination coordinates');
        return;
      }

      // Parse origin coordinates
      const originCoordsParts = originCoordsStr.split(',').map(s => parseFloat(s.trim()));
      if (originCoordsParts.length !== 2 || isNaN(originCoordsParts[0]) || isNaN(originCoordsParts[1])) {
        alert('Invalid origin coordinates format. Use: longitude, latitude (e.g., 139.7798, 35.5494)');
        return;
      }

      // Parse destination coordinates
      const destCoordsParts = destCoordsStr.split(',').map(s => parseFloat(s.trim()));
      if (destCoordsParts.length !== 2 || isNaN(destCoordsParts[0]) || isNaN(destCoordsParts[1])) {
        alert('Invalid destination coordinates format. Use: longitude, latitude (e.g., 139.7798, 35.5494)');
        return;
      }

      // Calculate straight-line distance using Turf
      const from = turf.point(originCoordsParts);
      const to = turf.point(destCoordsParts);
      const actualDistance = turf.distance(from, to, { units: 'kilometers' });

      const newRoute = {
        origin: {
          name: originName,
          coords: originCoordsParts,
          flag: originFlag
        },
        name: destinationName,
        coords: destCoordsParts,
        flag: destinationFlag,
        vehicle: vehicle,
        actualDistance: actualDistance
      };

      if (editingRouteIndex !== null) {
        // Update existing route
        destinations[editingRouteIndex] = newRoute;
      } else {
        // Add new route
        destinations.push(newRoute);
      }

      renderRoutesList();
      closeEditModal();
    }

    // Delete a route
    function deleteRoute(index) {
      if (destinations.length <= 1) {
        alert('Cannot delete the last route');
        return;
      }

      if (confirm(`Delete route to ${destinations[index].name}?`)) {
        destinations.splice(index, 1);
        renderRoutesList();
      }
    }

    // Calculate distances for all routes that don't have actualDistance
    function calculateRouteDistances() {
      destinations.forEach(route => {
        if (!route.actualDistance && route.origin && route.coords) {
          const from = turf.point(route.origin.coords);
          const to = turf.point(route.coords);
          route.actualDistance = turf.distance(from, to, { units: 'kilometers' });
        }
      });
    }

    // Helper functions
    function clamp(v) {
      return Math.max(0.0, Math.min(v, 1.0));
    }

    function mix(a, b, mixFactor) {
      const f = clamp(mixFactor);
      return a * (1 - f) + b * f;
    }

    function rad2deg(angRad) {
      return (angRad * 180.0) / Math.PI;
    }

    // Catmull-Rom spline interpolation
    function catmullRomSpline(p0, p1, p2, p3, t) {
      const t2 = t * t;
      const t3 = t2 * t;

      return 0.5 * (
        (2 * p1) +
        (-p0 + p2) * t +
        (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
        (-p0 + 3 * p1 - 3 * p2 + p3) * t3
      );
    }

    // Helper to create GeoJSON geometry from coordinates, handling antimeridian crossing
    function makeLineGeometry(coordinates) {
      if (!coordinates || coordinates.length === 0) {
        return { type: 'LineString', coordinates: [] };
      }

      const segments = [];
      let currentSegment = [coordinates[0]];

      for (let i = 1; i < coordinates.length; i++) {
        const prev = coordinates[i - 1];
        const curr = coordinates[i];

        // Check for antimeridian crossing (big longitude jump)
        if (Math.abs(curr[0] - prev[0]) > 180) {
          segments.push(currentSegment);
          currentSegment = [curr];
        } else {
          currentSegment.push(curr);
        }
      }
      segments.push(currentSegment);

      if (segments.length === 1) {
        return { type: 'LineString', coordinates: segments[0] };
      } else {
        return { type: 'MultiLineString', coordinates: segments };
      }
    }

    // Generate a curved route with optional control points (can be array or single point)
    function generateCurvedRoute(from, to, controlPoints = null, vehicle = 'plane') {
      const numPoints = 200;
      const coordinates = [];
      const elevationData = [];

      // Normalize controlPoints to always be an array of coordinate arrays
      let controlPointsArray = [];
      if (controlPoints) {
        if (Array.isArray(controlPoints)) {
          // Array of control points
          controlPointsArray = controlPoints.map(cp => {
            // Handle both object format {coords: [lng, lat]} and array format [lng, lat]
            if (cp.coords) {
              return cp.coords;
            } else {
              return cp;
            }
          });
        } else if (controlPoints.coords) {
          // Single control point object
          controlPointsArray = [controlPoints.coords];
        } else {
          // Single control point array
          controlPointsArray = [controlPoints];
        }
      }

      if (controlPointsArray.length > 0) {
        // Build full path: start -> control points -> end
        const allPoints = [from, ...controlPointsArray, to];

        // Normalize for Catmull-Rom: make all points use the shortest path
        // If we're going west (like Japan to SF), adjust coordinates to not wrap around
        const normalizedPoints = [];
        normalizedPoints.push([allPoints[0][0], allPoints[0][1]]);

        for (let i = 1; i < allPoints.length; i++) {
          let currLng = allPoints[i][0];
          const currLat = allPoints[i][1];
          const prevLng = normalizedPoints[i - 1][0];

          // Find the shortest path between prevLng and currLng
          // Consider three options: currLng, currLng+360, currLng-360
          const options = [currLng, currLng + 360, currLng - 360];
          let bestLng = currLng;
          let minDist = Math.abs(currLng - prevLng);

          for (const opt of options) {
            const dist = Math.abs(opt - prevLng);
            if (dist < minDist) {
              minDist = dist;
              bestLng = opt;
            }
          }

          normalizedPoints.push([bestLng, currLat]);
        }

        // Use Catmull-Rom spline for smooth curve through all points
        const segments = normalizedPoints.length - 1;
        const pointsPerSegment = Math.floor(numPoints / segments);

        for (let seg = 0; seg < segments; seg++) {
          // Get four points for Catmull-Rom (with padding at ends)
          const p0 = seg > 0 ? normalizedPoints[seg - 1] : normalizedPoints[seg];
          const p1 = normalizedPoints[seg];
          const p2 = normalizedPoints[seg + 1];
          const p3 = seg < segments - 1 ? normalizedPoints[seg + 2] : normalizedPoints[seg + 1];

          const segmentPoints = seg === segments - 1 ? pointsPerSegment + (numPoints % segments) : pointsPerSegment;

          for (let i = 0; i <= segmentPoints; i++) {
            const t = i / segmentPoints;
            let lng = catmullRomSpline(p0[0], p1[0], p2[0], p3[0], t);
            const lat = catmullRomSpline(p0[1], p1[1], p2[1], p3[1], t);

            // Normalize back to -180 to 180 range (may need multiple adjustments for far values)
            while (lng > 180) lng -= 360;
            while (lng < -180) lng += 360;

            if (seg === 0 || i > 0) { // Avoid duplicate points at segment boundaries
              coordinates.push([lng, lat]);

              // Parabolic elevation profile
              const overallT = (seg * pointsPerSegment + i) / numPoints;
              const parabola = -4 * (overallT - 0.5) * (overallT - 0.5) + 1;
              const minAltitude = 0;
              const maxAltitude = (vehicle === 'plane') ? 11000 : 0;
              const elevation = minAltitude + parabola * (maxAltitude - minAltitude);
              elevationData.push(elevation);
            }
          }
        }
      } else {
        // Use great circle (original behavior)
        const startPoint = turf.point(from);
        const endPoint = turf.point(to);

        // Turf's greatCircle always takes the shorter path
        const greatCircleLine = turf.greatCircle(startPoint, endPoint, { npoints: numPoints + 1 });


        let gcCoordinates;
        if (greatCircleLine.geometry.type === 'MultiLineString') {
          // Turf splits at antimeridian into multiple segments
          // Use flat() to combine them into a single array for sampling
          // The jump between segments (e.g. 180 to -180) will be preserved
          gcCoordinates = greatCircleLine.geometry.coordinates.flat();
        } else {
          gcCoordinates = greatCircleLine.geometry.coordinates;
        }

        for (let i = 0; i <= numPoints; i++) {
          const fraction = i / numPoints;
          const coordIndex = Math.floor(fraction * (gcCoordinates.length - 1));
          coordinates.push(gcCoordinates[coordIndex]);

          const parabola = -4 * (fraction - 0.5) * (fraction - 0.5) + 1;
          const minAltitude = 0;
          const maxAltitude = (vehicle === 'plane') ? 11000 : 0;
          const elevation = minAltitude + parabola * (maxAltitude - minAltitude);
          elevationData.push(elevation);
        }
      }

      return {
        coordinates: coordinates,
        elevationData: elevationData
      };
    }

    // Generate a simple flight route between two points
    function generateFlightRoute(from, to, controlPoint = null) {
      return generateCurvedRoute(from, to, controlPoint);
    }

    // FlightRoute class (simplified)
    class FlightRoute {
      constructor(routeData) {
        this.coordinates = routeData.coordinates;
        this.elevationData = routeData.elevationData;
        this.distances = [0];

        for (let i = 1; i < this.coordinates.length; i++) {
          const segmentDistance =
            turf.distance(
              turf.point(this.coordinates[i - 1]),
              turf.point(this.coordinates[i]),
              { units: 'kilometers' }
            ) * 1000.0;
          this.distances.push(this.distances[i - 1] + segmentDistance);
        }
      }

      get totalLength() {
        if (!this.distances || this.distances.length === 0) return 0;
        return this.distances[this.distances.length - 1];
      }

      sample(currentDistance) {
        if (!this.distances || this.distances.length === 0) return null;

        let segmentIndex =
          this.distances.findIndex((d) => d >= currentDistance) - 1;
        if (segmentIndex < 0) segmentIndex = 0;
        if (segmentIndex >= this.coordinates.length - 1) {
          segmentIndex = this.coordinates.length - 2;
        }

        const p1 = this.coordinates[segmentIndex];
        const p2 = this.coordinates[segmentIndex + 1];
        const segmentLength =
          this.distances[segmentIndex + 1] - this.distances[segmentIndex];
        const segmentRatio =
          (currentDistance - this.distances[segmentIndex]) / segmentLength;

        const e1 = this.elevationData[segmentIndex];
        const e2 = this.elevationData[segmentIndex + 1];
        const bearing = turf.bearing(turf.point(p1), turf.point(p2));
        const altitude = e1 + (e2 - e1) * segmentRatio;
        const pitch = rad2deg(Math.atan2(e2 - e1, segmentLength));

        // Handle longitude interpolation across antimeridian
        let lng1 = p1[0];
        let lng2 = p2[0];

        if (Math.abs(lng2 - lng1) > 180) {
          if (lng2 > lng1) {
            lng1 += 360;
          } else {
            lng2 += 360;
          }
        }

        let lng = lng1 + (lng2 - lng1) * segmentRatio;
        const lat = p1[1] + (p2[1] - p1[1]) * segmentRatio;

        // Normalize longitude back to -180 to 180
        while (lng > 180) lng -= 360;
        while (lng < -180) lng += 360;

        return {
          position: [lng, lat],
          altitude: altitude,
          bearing: bearing,
          pitch: pitch
        };
      }
    }

    // Airplane class
    class Airplane {
      constructor(startPos) {
        this.position = startPos || [0, 0];
        this.altitude = 5000;
        this.bearing = 0;
        this.pitch = 0;
        this.roll = 0;
        this.frontGearRotation = 90; // Retracted
        this.rearGearRotation = -90; // Retracted
        this.animTimeS = 0;
      }

      update(target, dtimeMs) {
        this.position[0] = target.position[0];
        this.position[1] = target.position[1];
        this.altitude = target.altitude;
        this.bearing = target.bearing;
        this.pitch = target.pitch;
        this.roll = rad2deg(Math.sin(this.animTimeS * Math.PI * 0.3) * 0.05);
        this.frontGearRotation = 90; // Always retracted
        this.rearGearRotation = -90; // Always retracted
        this.animTimeS += dtimeMs / 1000.0;
      }
    }

    // Map style with model sources and layers
    const style = {
      'version': 8,
      'imports': [
        {
          'id': 'basemap',
          'url': 'mapbox://styles/mapbox/standard',
          'config': {
            'lightPreset': 'night',
            'showPointOfInterestLabels': false,
            'showRoadLabels': false,
          }
        }
      ],
      'sources': {
        'plane-model-source': {
          'type': 'model',
          'models': {
            'plane': {
              'uri': airplaneModelUri,
              'position': [140.3929, 35.7719],
              'orientation': [0, 0, 0]
            }
          }
        },
        'train-model-source': {
          'type': 'model',
          'models': {
            'train': {
              'uri': trainModelUri,
              'position': [-180, -90],
              'orientation': [0, 0, 0],
              'position': [140.3929, 35.7719],
            }
          }
        },
        'car-model-source': {
          'type': 'model',
          'models': {
            'car': {
              'uri': carModelUri,
              'position': [140.3929, 35.7719],
              'orientation': [0, 0, 0],
              'materialOverrides': {
                'body': {
                  'model-color': [1.0, 0.5, 0.0],
                  'model-color-mix-intensity': 1.0,
                  'model-emissive-strength': 5.0
                }
              }
            }
          }
        }
      },
      'layers': [
        {
          'id': 'plane-model-layer',
          'type': 'model',
          'source': 'plane-model-source',
          'slot': 'top',
          'layout': {
            'visibility': 'none'
          },
          'paint': {
            'model-translation': [0, 0, ['feature-state', 'z-elevation']],
            'model-scale': [
              'interpolate',
              ['exponential', 0.5],
              ['zoom'],
              2, ['literal', [20000, 20000, 20000]],
              14, ['literal', [1, 1, 1]]
            ],
            'model-type': 'location-indicator',
            'model-rotation': [
              ['feature-state', 'pitch'],
              ['feature-state', 'roll'],
              ['feature-state', 'bearing']
            ],
            'model-emissive-strength': 2
          }
        },
        {
          'id': 'train-model-layer',
          'type': 'model',
          'source': 'train-model-source',
          'slot': 'top',
          'layout': {
            'visibility': 'none'
          },
          'paint': {
            'model-translation': [0, 0, ['feature-state', 'z-elevation']],
            'model-scale': [
              'interpolate',
              ['exponential', 0.5],
              ['zoom'],
              2, ['literal', [60000, 60000, 60000]],
              14, ['literal', [1000, 1000, 1000]]
            ],
            'model-type': 'location-indicator',
            'model-rotation': [
              ['feature-state', 'pitch'],
              ['feature-state', 'roll'],
              ['feature-state', 'bearing']
            ],
            'model-emissive-strength': 2
          }
        },
        {
          'id': 'car-model-layer',
          'type': 'model',
          'source': 'car-model-source',
          'slot': 'top',
          'layout': {
            'visibility': 'none'
          },
          'paint': {
            'model-translation': [0, 0, ['feature-state', 'z-elevation']],
            'model-scale': [
              'interpolate',
              ['exponential', 0.5],
              ['zoom'],
              2, ['literal', [200000, 200000, 200000]],
              14, ['literal', [5, 5, 5]]
            ],
            'model-type': 'location-indicator',
            'model-rotation': [
              ['feature-state', 'pitch'],
              ['feature-state', 'roll'],
              ['feature-state', 'bearing']
            ],
            'model-emissive-strength': 5
          }
        }
      ]
    };

    // Update 3D model source and feature state
    function updateModelSourceAndFeatureState(airplane) {
      const isUsingTrain = (currentModelUri === trainModelUri);
      const isUsingCar = (currentModelUri === carModelUri);

      let activeLayerId, activeSourceId, activeModelId, vehicleType;
      if (isUsingTrain) {
        activeLayerId = 'train-model-layer';
        activeSourceId = 'train-model-source';
        activeModelId = 'train';
        vehicleType = 'train';
      } else if (isUsingCar) {
        activeLayerId = 'car-model-layer';
        activeSourceId = 'car-model-source';
        activeModelId = 'car';
        vehicleType = 'car';
      } else {
        activeLayerId = 'plane-model-layer';
        activeSourceId = 'plane-model-source';
        activeModelId = 'plane';
        vehicleType = 'plane';
      }

      if (needsModelUpdate) {

        // Show active layer, hide all other layers
        map.setLayoutProperty('plane-model-layer', 'visibility', vehicleType === 'plane' ? 'visible' : 'none');
        map.setLayoutProperty('train-model-layer', 'visibility', vehicleType === 'train' ? 'visible' : 'none');
        map.setLayoutProperty('car-model-layer', 'visibility', vehicleType === 'car' ? 'visible' : 'none');

        needsModelUpdate = false;
      }

      // Update model position
      const source = map.getSource(activeSourceId);
      if (source) {
        source.setModels({
          [activeModelId]: {
            'uri': currentModelUri,
            'position': airplane.position,
            'orientation': [0, 0, 0]
          }
        });
      }

      // Update feature state for rotation and elevation
      // Trains and cars stay level (pitch 0), planes use calculated pitch
      map.setFeatureState(
        { source: activeSourceId, id: activeModelId },
        {
          'z-elevation': airplane.altitude,
          'pitch': (isUsingTrain || isUsingCar) ? 0 : airplane.pitch,
          'roll': airplane.roll,
          'bearing': airplane.bearing + (isUsingTrain ? 90 : (isUsingCar ? 0 : 90))
        }
      );
    }

    // Initialize map
    const map = new mapboxgl.Map({
      container: 'map',
      projection: 'globe',
      style,
      center: destinations[0].origin.coords, // Start at first route's origin 
      zoom: 2,
      bearing: 0,
      pitch: 0,
      preserveDrawingBuffer: true // Required for video recording
    });


    let currentLegIndex = 0;
    let isAnimating = false;
    let flightRoute = null;
    let airplane = null;
    let phase = 0;
    let lastFrameTime = null;
    let animationFrameId = null;
    let currentFlightDuration = 5000; // Will be calculated based on distance
    let currentSegmentTrailCoordinates = []; // Store current segment trail coordinates
    let trailAltitudes = []; // Store altitudes separately
    let segmentCounter = 0; // Counter for unique segment IDs
    // Initialize with the first destination's vehicle
    let currentModelUri = destinations[0].vehicle === 'train' ? trainModelUri :
                          destinations[0].vehicle === 'car' ? carModelUri : airplaneModelUri;
    let lastModelUri = null; // Track last loaded model to avoid unnecessary updates
    let needsModelUpdate = true; // Flag to trigger model switch

    // Route editor state
    let isEditMode = true; // Start in edit mode
    let routeControlPoints = {}; // Store arrays of control points for each route segment: { '0': [[lng, lat], [lng, lat], ...], '1': [...], ... }
    let controlPointMarkers = []; // Store marker objects with metadata
    let previewRoutes = {}; // Store generated preview routes

    // Show destination label
    function showDestinationLabel(destination) {
      const label = document.getElementById('destination-label');
      label.innerHTML = `${destination.flag}<br>${destination.name}`;
      label.classList.add('show');

      setTimeout(() => {
        label.classList.remove('show');
      }, 2000);
    }

    // Update distance counter display
    function updateDistanceDisplay() {
      const counter = document.getElementById('distance-counter');
      const formattedDistance = Math.round(totalAccumulatedDistance).toLocaleString();
      counter.innerHTML = `${formattedDistance} <span>km</span>`;
    }

    // Update route with control points
    function updateRoutePreview(segmentKey) {
      const i = parseInt(segmentKey);
      const route = destinations[i];
      const from = route.origin;
      const to = { name: route.name, coords: route.coords };
      const vehicle = route.vehicle || 'plane';
      const previewSourceId = `preview-route-${i}`;

      // Regenerate route with control points
      const controlPoints = routeControlPoints[segmentKey] || [];
      const updatedRoute = generateCurvedRoute(from.coords, to.coords, controlPoints.length > 0 ? controlPoints : null, vehicle);
      previewRoutes[segmentKey] = updatedRoute;

      // Update preview line
      const source = map.getSource(previewSourceId);
      if (source) {
        source.setData({
          'type': 'Feature',
          'geometry': makeLineGeometry(updatedRoute.coordinates)
        });
      }
    }

    // Add control point to route
    function addControlPoint(segmentKey, lngLat) {
      if (!routeControlPoints[segmentKey]) {
        routeControlPoints[segmentKey] = [];
      }

      const i = parseInt(segmentKey);
      const route = destinations[i];
      const vehicle = route.vehicle || 'plane';
      const markerClass = vehicle === 'train' ? 'train' : (vehicle === 'car' ? 'car' : 'plane');

      // Create the control point object with a unique ID
      const controlPoint = {
        coords: [lngLat.lng, lngLat.lat],
        id: Date.now() + Math.random() // Unique ID
      };

      routeControlPoints[segmentKey].push(controlPoint);


      // Create draggable marker
      const markerEl = document.createElement('div');
      markerEl.className = `control-point-marker ${markerClass}`;

      const marker = new mapboxgl.Marker({
        element: markerEl,
        draggable: true,
        anchor: 'center',
        pitchAlignment: 'viewport',
        rotationAlignment: 'viewport'
      })
        .setLngLat(lngLat)
        .addTo(map);

      // Store marker metadata with reference to the control point object
      const markerData = { marker, segmentKey, controlPoint };
      controlPointMarkers.push(markerData);

      // Handle drag to update route
      marker.on('drag', () => {
        const newLngLat = marker.getLngLat();
        // Update the control point coordinates directly
        controlPoint.coords[0] = newLngLat.lng;
        controlPoint.coords[1] = newLngLat.lat;
        updateRoutePreview(segmentKey);
      });

      // Handle right-click to delete
      markerEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();


        // Find and remove from control points array
        const pointIndex = routeControlPoints[segmentKey].indexOf(controlPoint);
        if (pointIndex > -1) {
          routeControlPoints[segmentKey].splice(pointIndex, 1);
        }

        // Remove marker from tracking array
        const markerIndex = controlPointMarkers.indexOf(markerData);
        if (markerIndex > -1) {
          controlPointMarkers.splice(markerIndex, 1);
        }

        marker.remove();
        updateRoutePreview(segmentKey);
      });

      updateRoutePreview(segmentKey);
    }

    // Initialize route editor
    function initializeRouteEditor() {
      // Show edit mode info
      document.getElementById('edit-mode-info').innerHTML = 'Click on a route line to add control points. Right-click markers to delete them.';
      document.getElementById('edit-mode-info').style.display = 'block';

      // Create preview routes for all segments
      for (let i = 0; i < destinations.length; i++) {
        const route = destinations[i];
        const from = route.origin;
        const to = { name: route.name, coords: route.coords };
        const segmentKey = `${i}`;

        // Initialize empty control points array
        if (!routeControlPoints[segmentKey]) {
          routeControlPoints[segmentKey] = [];
        }

        // Generate preview route (straight line initially)
        const routeData = generateCurvedRoute(from.coords, to.coords, null);
        previewRoutes[segmentKey] = routeData;

        // Determine vehicle type for dash pattern
        const vehicle = route.vehicle || 'plane';
        const isUsingTrain = (vehicle === 'train');

        // Add preview line layer
        const previewSourceId = `preview-route-${i}`;
        const previewLayerId = `preview-route-layer-${i}`;

        map.addSource(previewSourceId, {
          'type': 'geojson',
          'data': {
            'type': 'Feature',
            'properties': { segmentKey },
            'geometry': makeLineGeometry(routeData.coordinates)
          }
        });

        map.addLayer({
          'id': previewLayerId,
          'type': 'line',
          'source': previewSourceId,
          'layout': {
            'line-cap': 'round',
            'line-join': 'round'
          },
          'paint': {
            'line-color': '#ffffff',
            'line-width': 6,
            'line-opacity': 0.8,
            'line-emissive-strength': 5,
            'line-dasharray': isUsingTrain ? [1, 0] : [2, 4]
          }
        });

        // Make line clickable to add control points
        map.on('click', previewLayerId, (e) => {
          e.preventDefault();
          e.originalEvent.stopPropagation();
          const lngLat = e.lngLat;
          addControlPoint(segmentKey, lngLat);
        });

        // Change cursor on hover
        map.on('mouseenter', previewLayerId, () => {
          map.getCanvas().style.cursor = 'crosshair';
        });

        map.on('mouseleave', previewLayerId, () => {
          map.getCanvas().style.cursor = '';
        });
      }
    }

    // Clean up route editor
    function cleanupRouteEditor() {
      // Hide edit mode info
      document.getElementById('edit-mode-info').style.display = 'none';

      // Remove all control point markers
      controlPointMarkers.forEach(({ marker }) => {
        marker.remove();
      });
      controlPointMarkers = [];

      // Remove preview layers and their event listeners
      for (let i = 0; i < destinations.length - 1; i++) {
        const previewLayerId = `preview-route-layer-${i}`;
        const previewSourceId = `preview-route-${i}`;

        // Remove event listeners
        map.off('click', previewLayerId);
        map.off('mouseenter', previewLayerId);
        map.off('mouseleave', previewLayerId);

        // Remove layer and source
        if (map.getLayer(previewLayerId)) {
          map.removeLayer(previewLayerId);
        }
        if (map.getSource(previewSourceId)) {
          map.removeSource(previewSourceId);
        }
      }
    }

    // Save routes and start tour
    function saveAndStartTour() {
      if (isEditMode) {
        // Clean up editor and start animation
        cleanupRouteEditor();
        isEditMode = false;
        document.getElementById('start-btn').textContent = 'Restart Tour';
        document.getElementById('edit-btn').style.display = 'inline-block';

        // Start recording if checkbox is checked
        const recordCheckbox = document.getElementById('record-checkbox');
        if (recordCheckbox && recordCheckbox.checked) {
          startRecording();
        }

        startTour();
      } else {
        // Restart from beginning
        // Start recording if checkbox is checked
        const recordCheckbox = document.getElementById('record-checkbox');
        if (recordCheckbox && recordCheckbox.checked) {
          startRecording();
        }

        startTour();
      }
    }

    // Enter edit mode
    function enterEditMode() {
      isEditMode = true;
      document.getElementById('edit-btn').style.display = 'none';
      document.getElementById('start-btn').textContent = 'Save & Start Tour';
      document.getElementById('start-btn').disabled = false; // Re-enable button

      // Stop animation if running
      if (isAnimating) {
        isAnimating = false;
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
      }

      // Clean up animation layers
      const style = map.getStyle();
      if (style && style.layers) {
        const segmentLayers = style.layers.filter(layer => layer.id.startsWith('trail-segment-layer-'));
        segmentLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.removeLayer(layer.id);
          }
        });
      }
      if (style && style.sources) {
        const segmentSources = Object.keys(style.sources).filter(source => source.startsWith('trail-segment-'));
        segmentSources.forEach(source => {
          if (map.getSource(source)) {
            map.removeSource(source);
          }
        });
      }

      // Re-initialize editor with saved control points
      initializeRouteEditor();

      // Re-add all saved control points as markers
      Object.keys(routeControlPoints).forEach(segmentKey => {
        const points = routeControlPoints[segmentKey];
        if (points && points.length > 0) {
          // Clear the array temporarily to avoid duplicates
          const savedPoints = [...points];
          routeControlPoints[segmentKey] = [];

          // Re-add each point
          savedPoints.forEach(point => {
            // Handle both object format and array format
            const coords = point.coords || point;
            addControlPoint(segmentKey, { lng: coords[0], lat: coords[1] });
          });
        }
      });
    }

    // Smoke effect animation
    let smokeCounter = 0;
    function addSmokeEffect(position) {
      const smokeId = `smoke-${smokeCounter++}`;
      const sourceId = `${smokeId}-source`;
      const layerId = `${smokeId}-layer`;

      // Add source with initial small circle
      map.addSource(sourceId, {
        'type': 'geojson',
        'data': {
          'type': 'Feature',
          'geometry': {
            'type': 'Point',
            'coordinates': position
          }
        }
      });

      // Add circle layer
      map.addLayer({
        'id': layerId,
        'type': 'circle',
        'source': sourceId,
        'paint': {
          'circle-radius': 30,
          'circle-color': '#888888',
          'circle-opacity': 0.8,
          'circle-blur': 0.5,
          'circle-emissive-strength': 3
        }
      });

      // Animate the smoke
      const startTime = Date.now();
      const duration = 500; // Match the delay duration

      function animateSmoke() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        if (progress >= 1) {
          // Remove smoke layer and source
          if (map.getLayer(layerId)) map.removeLayer(layerId);
          if (map.getSource(sourceId)) map.removeSource(sourceId);
          return;
        }

        // Expand radius and fade out
        const radius = 30 + (progress * 120); // Expand from 30 to 150
        const opacity = 0.8 * (1 - progress); // Fade from 0.8 to 0

        map.setPaintProperty(layerId, 'circle-radius', radius);
        map.setPaintProperty(layerId, 'circle-opacity', opacity);

        requestAnimationFrame(animateSmoke);
      }

      animateSmoke();
    }

    // Vehicle pulse effect
    function addVehiclePulseEffect() {
      const isUsingTrain = (currentModelUri === trainModelUri);
      const isUsingCar = (currentModelUri === carModelUri);

      let activeLayerId;
      if (isUsingTrain) {
        activeLayerId = 'train-model-layer';
      } else if (isUsingCar) {
        activeLayerId = 'car-model-layer';
      } else {
        activeLayerId = 'plane-model-layer';
      }

      const startTime = Date.now();
      const duration = 500; // Match the delay duration
      const baseEmissive = 2; // Base emissive strength
      const maxEmissive = 5; // Peak emissive strength (max allowed)

      function animatePulse() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;

        if (progress >= 1) {
          // Reset to base emissive
          map.setPaintProperty(activeLayerId, 'model-emissive-strength', baseEmissive);
          return;
        }

        // Create a sine wave pulse effect (0 -> 1 -> 0)
        const pulse = Math.sin(progress * Math.PI * 2); // 2 full cycles
        const emissive = baseEmissive + (pulse * (maxEmissive - baseEmissive));

        map.setPaintProperty(activeLayerId, 'model-emissive-strength', Math.abs(emissive));

        requestAnimationFrame(animatePulse);
      }

      animatePulse();
    }

    // Animation frame
    function frame(time) {
      if (!isAnimating) return;

      if (!lastFrameTime) lastFrameTime = time;
      const frameDeltaTime = time - lastFrameTime;

      phase += frameDeltaTime / currentFlightDuration;
      lastFrameTime = time;

      if (phase >= 1) {
        // Flight leg complete
        phase = 0;

        // Add completed leg distance
        const completedRoute = destinations[currentLegIndex];
        if (completedRoute.actualDistance) {
          completedLegsDistance += completedRoute.actualDistance;
        }

        currentLegIndex++;

        if (currentLegIndex >= destinations.length) {
          // Tour complete
          isAnimating = false;
          document.getElementById('start-btn').disabled = false;
          document.getElementById('start-btn').textContent = 'Restart Tour';

          // Show final destination
          const lastRoute = destinations[destinations.length - 1];
          showDestinationLabel({ name: lastRoute.name, coords: lastRoute.coords, flag: lastRoute.flag });

          // Show completion modal with confetti
          showCompletionModal();

          return;
        }

        // Start next leg - now each route has explicit origin and destination
        const route = destinations[currentLegIndex];
        const from = route.origin;
        const to = { name: route.name, coords: route.coords, flag: route.flag };

        // Switch vehicle based on the route's vehicle attribute
        const vehicle = route.vehicle || 'plane'; // Default to plane if not specified
        const previousModelUri = currentModelUri;
        if (vehicle === 'train') {
          currentModelUri = trainModelUri;
        } else if (vehicle === 'car') {
          currentModelUri = carModelUri;
        } else {
          currentModelUri = airplaneModelUri;
        }

        // Set flag if vehicle changed
        if (previousModelUri !== currentModelUri) {
          needsModelUpdate = true;
        }

        // Use saved control point if available
        const segmentKey = `${currentLegIndex}`;
        const controlPoint = routeControlPoints[segmentKey] || null;
        const routeData = generateFlightRoute(from.coords, to.coords, controlPoint, vehicle);
        flightRoute = new FlightRoute(routeData);

        // Create new segment source and layer for this route
        segmentCounter++;
        currentSegmentTrailCoordinates = []; // Reset for new segment

        const isUsingTrain = (currentModelUri === trainModelUri);
        const isUsingCar = (currentModelUri === carModelUri);
        const trailColor = isUsingTrain ? '#ff0000' : (isUsingCar ? '#ff8800' : '#ffffff');
        const sourceId = `trail-segment-${segmentCounter}`;
        const layerId = `trail-segment-layer-${segmentCounter}`;

        // Add source for this segment
        map.addSource(sourceId, {
          'type': 'geojson',
          'data': {
            'type': 'Feature',
            'geometry': {
              'type': 'LineString',
              'coordinates': []
            }
          }
        });

        // Add layer for this segment
        map.addLayer({
          'id': layerId,
          'type': 'line',
          'source': sourceId,
          'layout': {
            'line-cap': 'round',
            'line-join': 'round'
          },
          'paint': {
            'line-color': trailColor,
            'line-width': 5,
            'line-opacity': 0.8,
            'line-emissive-strength': 1.5,
            'line-dasharray': (isUsingTrain || isUsingCar) ? [1, 0] : [2, 4] // Solid line for train/car, dashed for plane
          }
        });

        // Vehicle-specific duration: train 2.5s, car 3s, plane 1.5s
        if (isUsingTrain) {
          currentFlightDuration = 2500; // 2.5 seconds
        } else if (isUsingCar) {
          currentFlightDuration = 3000; // 3 seconds
        } else {
          currentFlightDuration = 1500; // 1.5 seconds
        }

        // Fit viewport to show both start and end points
        // For trans-Pacific routes, use the great circle path coordinates
        const bounds = new mapboxgl.LngLatBounds();

        // Use all route coordinates to get proper bounds including great circle path
        for (const coord of routeData.coordinates) {
          bounds.extend(coord);
        }

        // Vehicle-specific camera pitch: plane 30Â°, train/car 70Â°
        const cameraPitch = (isUsingTrain || isUsingCar) ? 70 : 30;

        map.fitBounds(bounds, {
          padding: { top: 10, bottom: 10, left: 10, right: 10 },
          duration: 2000,
          pitch: cameraPitch,
          bearing: 0
        });

        // Show destination label
        showDestinationLabel(to);

        // Pause before next leg
        isAnimating = false;
        setTimeout(() => {
          isAnimating = true;
          lastFrameTime = null;
          animationFrameId = window.requestAnimationFrame(frame);
        }, 0);
        return;
      }

      // Update airplane position
      const alongRoute = flightRoute.sample(flightRoute.totalLength * phase);
      if (alongRoute) {
        airplane.update(alongRoute, frameDeltaTime);

        // For trains and cars, keep at sea level
        const isUsingTrain = (currentModelUri === trainModelUri);
        const isUsingCar = (currentModelUri === carModelUri);
        if (isUsingTrain || isUsingCar) {
          airplane.altitude = 0; // Sea level
        }

        // Update distance tracking
        const currentRoute = destinations[currentLegIndex];
        if (currentRoute.actualDistance) {
          const currentLegProgress = phase * currentRoute.actualDistance;
          totalAccumulatedDistance = completedLegsDistance + currentLegProgress;
          updateDistanceDisplay();
        }

        // Add current position to trail (2D coordinates)
        currentSegmentTrailCoordinates.push([airplane.position[0], airplane.position[1]]);
        trailAltitudes.push(airplane.altitude);

        if (currentSegmentTrailCoordinates.length === 1) {
        }

        // Update trail source
        const trailSourceId = `trail-segment-${segmentCounter}`;

        // Update current segment trail using simple Mapbox line (only if we have at least 2 points)
        const trailSource = map.getSource(trailSourceId);
        if (trailSource && currentSegmentTrailCoordinates.length >= 2) {
          // Split trail into segments when crossing antimeridian
          const trailSegments = [];
          let currentSegment = [currentSegmentTrailCoordinates[0]];

          for (let i = 1; i < currentSegmentTrailCoordinates.length; i++) {
            const prev = currentSegmentTrailCoordinates[i - 1];
            const curr = currentSegmentTrailCoordinates[i];
            const lonDiff = Math.abs(curr[0] - prev[0]);

            // If longitude difference > 180, we crossed the antimeridian
            if (lonDiff > 180) {
              // Close current segment and start new one
              trailSegments.push(currentSegment);
              currentSegment = [curr];
            } else {
              currentSegment.push(curr);
            }
          }

          // Add the last segment
          if (currentSegment.length > 0) {
            trailSegments.push(currentSegment);
          }

          // Create MultiLineString geometry
          trailSource.setData({
            'type': 'Feature',
            'geometry': {
              'type': 'MultiLineString',
              'coordinates': trailSegments
            }
          });
        }
      }

      updateModelSourceAndFeatureState(airplane);

      animationFrameId = window.requestAnimationFrame(frame);
    }

    // Start tour
    function startTour() {
      currentLegIndex = 0;
      phase = 0;
      lastFrameTime = null;
      isAnimating = true;
      currentSegmentTrailCoordinates = []; // Reset current segment trail
      trailAltitudes = []; // Reset altitudes

      // Reset distance tracking
      totalAccumulatedDistance = 0;
      completedLegsDistance = 0;
      updateDistanceDisplay();


      // Clean up all existing segment layers and sources
      const style = map.getStyle();
      if (style && style.layers) {
        const segmentLayers = style.layers.filter(layer => layer.id.startsWith('trail-segment-layer-'));
        segmentLayers.forEach(layer => {
          if (map.getLayer(layer.id)) {
            map.removeLayer(layer.id);
          }
        });
      }
      if (style && style.sources) {
        const segmentSources = Object.keys(style.sources).filter(source => source.startsWith('trail-segment-'));
        segmentSources.forEach(source => {
          if (map.getSource(source)) {
            map.removeSource(source);
          }
        });
      }

      segmentCounter = 0; // Reset segment counter after cleanup

      document.getElementById('start-btn').disabled = true;

      // Generate first route
      const firstRoute = destinations[0];
      const from = firstRoute.origin;
      const to = { name: firstRoute.name, coords: firstRoute.coords };

      // First, center camera on starting point and wait 1 second before starting
      map.flyTo({
        center: from.coords,
        zoom: 2,
        pitch: 0,
        bearing: 0,
        duration: 1500
      });

      // Wait 1 second after camera movement, then start the route
      setTimeout(() => {
      // Switch vehicle based on the route's vehicle attribute
      const vehicle = firstRoute.vehicle || 'plane'; // Default to plane if not specified
      if (vehicle === 'train') {
        currentModelUri = trainModelUri;
      } else if (vehicle === 'car') {
        currentModelUri = carModelUri;
      } else {
        currentModelUri = airplaneModelUri;
      }

      // Set flag for initial model load
      needsModelUpdate = true;

      // Use saved control point if available
      const segmentKey = `${currentLegIndex}`;
      const controlPoint = routeControlPoints[segmentKey] || null;
      const routeData = generateFlightRoute(from.coords, to.coords, controlPoint, vehicle);
      flightRoute = new FlightRoute(routeData);
      airplane = new Airplane(from.coords);

      // Create first segment source and layer
      segmentCounter++;
      const isUsingTrain = (currentModelUri === trainModelUri);
      const isUsingCar = (currentModelUri === carModelUri);
      const trailColor = isUsingTrain ? '#ff0000' : (isUsingCar ? '#ff8800' : '#ffffff');
      const sourceId = `trail-segment-${segmentCounter}`;
      const layerId = `trail-segment-layer-${segmentCounter}`;

      // Add source for first segment
      map.addSource(sourceId, {
        'type': 'geojson',
        'data': {
          'type': 'Feature',
          'geometry': {
            'type': 'LineString',
            'coordinates': []
          }
        }
      });

      // Add layer for first segment
      map.addLayer({
        'id': layerId,
        'type': 'line',
        'source': sourceId,
        'layout': {
          'line-cap': 'round',
          'line-join': 'round'
        },
        'paint': {
          'line-color': trailColor,
          'line-width': 5,
          'line-opacity': 0.8,
          'line-emissive-strength': 1.5,
          'line-dasharray': (isUsingTrain || isUsingCar) ? [1, 0] : [2, 4] // Solid line for train/car, dashed for plane
        }
      });

      // Vehicle-specific duration: train 2.5s, car 3s, plane 1.5s
      if (isUsingTrain) {
        currentFlightDuration = 2500; // 2.5 seconds
      } else if (isUsingCar) {
        currentFlightDuration = 3000; // 3 seconds
      } else {
        currentFlightDuration = 1500; // 1.5 seconds
      }

      // Fit viewport to show both start and end points for first leg
      // For trans-Pacific routes, use the great circle path coordinates
      const bounds = new mapboxgl.LngLatBounds();

      // Use all route coordinates to get proper bounds including great circle path
      for (const coord of routeData.coordinates) {
        bounds.extend(coord);
      }

      // Vehicle-specific camera pitch: plane 30Â°, train/car 70Â°
      const cameraPitch = (isUsingTrain || isUsingCar) ? 70 : 30;

      map.fitBounds(bounds, {
        padding: { top: 120, bottom: 120, left: 120, right: 120 },
        duration: 2000,
        pitch: cameraPitch,
        bearing: 0
      });

      // Initialize plane at starting position
      const startPoint = flightRoute.sample(0);
      if (startPoint) {
        airplane.update(startPoint, 0);
        updateModelSourceAndFeatureState(airplane);
      }

      // Show first destination
      showDestinationLabel(from);
      setTimeout(() => showDestinationLabel(to), 500);

      animationFrameId = window.requestAnimationFrame(frame);
      }, 1000); // Wait 1 second before starting route
    }

    map.on('style.load', () => {
      // Calculate distances for existing routes
      calculateRouteDistances();

      // Initialize route editor on load
      initializeRouteEditor();

      // Render routes list
      renderRoutesList();

      // Initialize autocomplete
      initializeAutocomplete();
    });

    // Cleanup on page unload to free WebGL contexts
    window.addEventListener('beforeunload', () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (map) {
        map.remove();
      }
    });
  </script>
</body>
</html>
