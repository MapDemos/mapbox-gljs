<html lang="ja">

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0-beta.2/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0-beta.2/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
  <style>
    .map {
      position: absolute;
      width: 100%;
      top: 0;
      bottom: 0;
    }
   .control-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      font-family: 'Arial', sans-serif;
      font-size: 14px;
      min-width: 250px;
    }
    .control-panel h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
      font-weight: bold;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 500;
    }
    .control-group select,
    .control-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .control-group input[type="checkbox"] {
      width: auto;
      margin-right: 8px;
    }
    .checkbox-group {
      display: flex;
      align-items: center;
    }
    .checkbox-group label {
      margin-bottom: 0;
      cursor: pointer;
    }
</style>
</head>

<body>
  <div id="map" class="map"></div>
  <div class="control-panel">
    <h3>配達分析</h3>
    <div class="control-group">
      <div class="checkbox-group">
        <input type="checkbox" id="use-mts" />
        <label for="use-mts">MTS（Mapbox Tiling Service）を使用</label>
      </div>
    </div>
    <div class="control-group">
      <label for="isochrone-minutes">到達圏時間:</label>
      <select id="isochrone-minutes">
        <option value="5">5分</option>
        <option value="10" selected="">10分</option>
        <option value="15">15分</option>
        <option value="20">20分</option>
        <option value="30">30分</option>
      </select>
    </div>
    <div class="control-group">
      <label for="travel-profile">移動手段:</label>
      <select id="travel-profile">
        <option value="mapbox/walking" selected="">徒歩</option>
        <option value="mapbox/cycling">自転車</option>
        <option value="mapbox/driving">車</option>
        <option value="mapbox/driving-traffic">車（交通情報含む）</option>
      </select>
    </div>
  </div>
</body>
<script>
  
const defaultCoordinates = [139.76652995236685, 35.67881527736655];

let map
let mts = false

function getControlValues() {
    return {
        useMTS: document.getElementById('use-mts').checked,
        minutes: parseInt(document.getElementById('isochrone-minutes').value),
        profile: document.getElementById('travel-profile').value
    };
}

function setupControlListeners() {
    // Listen for MTS toggle
    document.getElementById('use-mts').addEventListener('change', function () {
        mts = this.checked;
        console.log('MTS mode:', mts);
        // Reload deliveries data when MTS mode changes
        reloadDeliveries();
    });

    // Listen for minutes change
    document.getElementById('isochrone-minutes').addEventListener('change', function () {
        console.log('Isochrone minutes changed to:', this.value);
    });

    // Listen for profile change
    document.getElementById('travel-profile').addEventListener('change', function () {
        console.log('Travel profile changed to:', this.value);
    });
}

function loadDeliveries() {
    if (mts) {
        addDeliveries(null);
    } else {
        fetch('deliveries.geojson')
            .then(response => response.json())
            .then(data => {
                addDeliveries(data)
            })
            .catch(error => console.error('Error loading GeoJSON data:', error));
    }
}

function reloadDeliveries() {
    // Remove existing deliveries layer and source
    if (map.getLayer('symbol-deliveries')) {
        map.removeLayer('symbol-deliveries');
    }
    if (map.getSource('deliveries')) {
        map.removeSource('deliveries');
    }

    loadDeliveries()
}

const loadMap = () => {
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/light-v11',
        center: defaultCoordinates,
        zoom: 12,
        minZoom: 3,
        //maxZoom: 12,
        scrollZoom: true,
        language: 'ja'
    })
    map.on('load', () => {
        setupControlListeners();
        mts = document.getElementById('use-mts').checked;
        map.loadImage('./assets/images/yamato.png', (error, image) => {
            if (error) throw error;
            if (!map.hasImage('yamato')) {
                map.addImage('yamato', image);
            }
        });

        fetch('deliveryCenters.geojson')
            .then(response => response.json())
            .then(data => {
                addDeliveryCenters(data)
            })
            .catch(error => console.error('Error loading GeoJSON data:', error));

        loadDeliveries();
    })
    map.on('click', (event) => {
        const { lng, lat } = event.lngLat;
        console.log(`Longitude: ${lng}, Latitude: ${lat}`);

        // Check if there are any delivery centers at the click point
        const features = map.queryRenderedFeatures(event.point, {
            layers: ['symbol-delivery-centers']
        });

        // If no delivery centers were clicked, reset the action
        if (features.length === 0) {
            resetClickAction();
        }
    })

    map.on('click', 'clusters', (e) => {
        const features = map.queryRenderedFeatures(e.point, {
            layers: ['clusters']
        });
        map.easeTo({
            center: features[0].geometry.coordinates,
            zoom: map.getZoom() + 2
        });
    });

    let popup

    map.on('click', 'symbol-delivery-centers', async (e) => {
        const features = map.queryRenderedFeatures(e.point, {
            layers: ['symbol-delivery-centers']
        });

        if (!features.length) {
            resetClickAction();
            return;
        }
        const feature = features[0];

        // Get values from UI controls
        const controls = getControlValues();

        // Call isochrone API using UI values
        const coordinates = feature.geometry.coordinates;
        const isochroneData = await fetchIsochrone(controls.profile, coordinates, controls.minutes, '5A9FD4');

        // Add isochrone to map if it doesn't exist
        if (!map.getSource('isochrone')) {
            map.addSource('isochrone', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });

            map.addLayer({
                id: 'isochrone-fill',
                type: 'fill',
                source: 'isochrone',
                paint: {
                    'fill-color': '#5A9FD4',
                    'fill-opacity': 0.3
                }
            });

            map.addLayer({
                id: 'isochrone-border',
                type: 'line',
                source: 'isochrone',
                paint: {
                    'line-color': '#5A9FD4',
                    'line-width': 2
                }
            });
        }

        let deliveryCount = 0;

        // Update the source with the isochrone data
        if (isochroneData) {
            map.getSource('isochrone').setData(isochroneData);

            // Get all delivery features using UI MTS setting
            let deliveryFeatures = null
            if (controls.useMTS) {
                deliveryFeatures = map.querySourceFeatures('deliveries', {
                    sourceLayer: 'deliveries'
                });
            } else {
                deliveryFeatures = map.getSource('deliveries')._data.features;
            }

            if (deliveryFeatures) {
                const isochronePolygon = isochroneData.features[0];

                // Filter delivery points that are within the isochrone polygon
                const deliveriesWithin = deliveryFeatures.filter(deliveryFeature => {
                    const point = deliveryFeature.geometry;
                    return turf.booleanPointInPolygon(point, isochronePolygon);
                });

                // Create a filter expression for Mapbox GL JS
                const deliveryIds = deliveriesWithin.map(feature => feature.properties.id || feature.id);
                deliveryCount = deliveriesWithin.length;

                // Apply filter to show only deliveries within the polygon
                if (deliveryIds.length > 0) {
                    map.setFilter('symbol-deliveries', ['in', ['get', 'id'], ['literal', deliveryIds]]);
                } else {
                    // If no deliveries within polygon, hide all
                    map.setFilter('symbol-deliveries', ['==', 'id', 'no-match']);
                }
            }
        }

        let html = '<table>';
        html += `<tr><th>配達数</th><td>${deliveryCount}</td></tr>`;
        html += '</table>';

        if (!popup) popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
        });

        popup.setLngLat(feature.geometry.coordinates)
            .setHTML(html)
            .addTo(map);
    });

    const resetClickAction = () => {
        if (popup) {
            popup.remove();
        }

        // Clear isochrone
        if (map.getSource('isochrone')) {
            map.getSource('isochrone').setData({
                type: 'FeatureCollection',
                features: []
            });
        }

        // Reset delivery filter to show all deliveries
        if (map.getLayer('symbol-deliveries')) {
            map.setFilter('symbol-deliveries', null);
        }
    }
}

const addDeliveryCenters = (data) => {
    map.addSource('delivery-centers', {
        type: 'geojson',
        data: data,
    });

    map.addLayer({
        id: "symbol-delivery-centers",
        type: "symbol",
        source: "delivery-centers",
        // filter: ['!', ['has', 'point_count']],
        layout: {
            "icon-image": "yamato", // ensure you have added this image beforehand
            "icon-size": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0, 0.1,
                10, 0.3,
                15, 0.6
            ],
            "icon-allow-overlap": true
        }
    });
}

const addDeliveries = (data) => {
    const source = {
        type: 'geojson',
        data: data
    }
    const layer = {
        id: "symbol-deliveries",
        type: "circle",
        source: "deliveries",
        paint: {
            "circle-radius": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0, 2,
                10, 4,
                15, 6
            ],
            "circle-color": "#FF0000",
            "circle-opacity": 0.8,
            "circle-stroke-width": 1,
            "circle-stroke-color": "#FFFFFF"
        },
        minzoom: 10
    }
    if (data === null) {
        source.type = 'vector'
        source.url = 'mapbox://kenji-shima.deliveries-z16'
        layer['source-layer'] = 'deliveries'
    }
    map.addSource('deliveries', source);

    map.addLayer(layer);
}

loadMap()
</script>

</html>
