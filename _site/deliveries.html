<html lang="ja">

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
  <style>
    .map {
      position: absolute;
      width: 100%;
      top: 0;
      bottom: 0;
    }
   .control-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      font-family: 'Hiragino Kaku Gothic Pro', 'Yu Gothic', 'Meiryo', sans-serif;
      font-size: 14px;
      min-width: 280px;
    }
    .control-panel h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
      font-weight: bold;
    }
    .control-group {
      margin-bottom: 15px;
    }
    .control-group label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 500;
    }
    .control-group select,
    .control-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .analyze-button {
      width: 100%;
      padding: 12px;
      background-color: #007cbf;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 10px;
    }
    .analyze-button:hover {
      background-color: #005a8b;
    }
    .analyze-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .loading-indicator {
      display: none;
      text-align: center;
      margin-top: 10px;
      color: #666;
    }
</style>
</head>

<body>
  <div id="map" class="map"></div>
  <div class="control-panel">
    <h3>配達分析</h3>
    
    <div class="control-group">
      <label for="isochrone-minutes">到達圏時間:</label>
      <select id="isochrone-minutes">
        <option value="5">5分</option>
        <option value="10" selected="">10分</option>
        <option value="15">15分</option>
        <option value="20">20分</option>
        <option value="30">30分</option>
      </select>
    </div>
    
    <div class="control-group">
      <label for="travel-profile">移動手段:</label>
      <select id="travel-profile">
        <option value="mapbox/walking" selected="">徒歩</option>
        <option value="mapbox/cycling">自転車</option>
        <option value="mapbox/driving">車</option>
        <option value="mapbox/driving-traffic">車（交通情報含む）</option>
      </select>
    </div>
    
    <button id="analyze-button" class="analyze-button">分析開始</button>
    <div id="loading-indicator" class="loading-indicator">処理中...</div>
  </div>
</body>
<script>
  const defaultCoordinates = [139.76652995236685, 35.67881527736655];

let map
let analysisResults = null;
let colorToIndexMap = {}; 
let colorPalette = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
];

// Add throttling variables
const REQUESTS_PER_SECOND = 300; // 300 per minute = 5 per second
const REQUEST_DELAY = 1000 / REQUESTS_PER_SECOND; // 200ms between requests

function getControlValues() {
    return {
        minutes: parseInt(document.getElementById('isochrone-minutes').value),
        profile: document.getElementById('travel-profile').value
    };
}

function setupControlListeners() {
    // Listen for minutes change
    document.getElementById('isochrone-minutes').addEventListener('change', function () {
        console.log('Isochrone minutes changed to:', this.value);
    });

    // Listen for profile change
    document.getElementById('travel-profile').addEventListener('change', function () {
        console.log('Travel profile changed to:', this.value);
    });

    // Add analyze button listener
    document.getElementById('analyze-button').addEventListener('click', function() {
        runAnalysis();
    });
}

async function runAnalysis() {
    const controls = getControlValues();
    const button = document.getElementById('analyze-button');
    const loading = document.getElementById('loading-indicator');
    
    // Show loading state
    button.disabled = true;
    button.textContent = '処理中...';
    
    try {
        // Get all delivery centers from GeoJSON source
        const centerFeatures = map.getSource('delivery-centers')._data.features;
        
        // Get all delivery points from GeoJSON source
        const deliveryFeatures = map.getSource('deliveries')._data.features;
        
        console.log(`Analyzing ${centerFeatures.length} delivery centers and ${deliveryFeatures.length} delivery points`);
        
        // Create all isochrone requests at once but limit concurrency
        const BATCH_SIZE = 50; // Process 50 requests at a time
        const validResults = [];
        
        for (let i = 0; i < centerFeatures.length; i += BATCH_SIZE) {
            const batch = centerFeatures.slice(i, i + BATCH_SIZE);
            
            console.log(`Processing batch ${Math.floor(i/BATCH_SIZE) + 1}/${Math.ceil(centerFeatures.length/BATCH_SIZE)} (${batch.length} centers)...`);
            
            // Process batch concurrently
            const batchPromises = batch.map(async (center, batchIndex) => {
                const globalIndex = i + batchIndex;
                const coordinates = center.geometry.coordinates;
                const color = colorPalette[globalIndex % colorPalette.length];
                
                try {
                    const isochroneData = await fetchIsochrone(controls.profile, coordinates, controls.minutes, color.replace('#', ''));
                    
                    return {
                        centerId: center.properties.id || globalIndex,
                        centerCoords: coordinates,
                        isochrone: isochroneData,
                        color: color,
                        deliveries: []
                    };
                } catch (error) {
                    console.error(`Failed to fetch isochrone for center ${globalIndex}:`, error);
                    return null;
                }
            });
            
            const batchResults = await Promise.all(batchPromises);
            validResults.push(...batchResults.filter(result => result !== null));
            
            // Small delay between batches to be extra safe
            if (i + BATCH_SIZE < centerFeatures.length) {
                await delay(100); // 100ms between batches
            }
        }
        
        console.log(`Successfully fetched ${validResults.length}/${centerFeatures.length} isochrones`);
        
        // Assign deliveries to nearest delivery center
        deliveryFeatures.forEach(delivery => {
            const deliveryPoint = delivery.geometry;
            let assignedCenter = null;
            let minDistance = Infinity;
            
            // Check which delivery centers this point falls within
            const candidateCenters = validResults.filter(result => {
                if (result.isochrone && result.isochrone.features && result.isochrone.features.length > 0) {
                    return turf.booleanPointInPolygon(deliveryPoint, result.isochrone.features[0]);
                }
                return false;
            });
            
            // If multiple centers, find the closest one
            if (candidateCenters.length > 1) {
                candidateCenters.forEach(center => {
                    const distance = turf.distance(deliveryPoint, turf.point(center.centerCoords));
                    if (distance < minDistance) {
                        minDistance = distance;
                        assignedCenter = center;
                    }
                });
            } else if (candidateCenters.length === 1) {
                assignedCenter = candidateCenters[0];
            }
            
            // Add delivery to assigned center
            if (assignedCenter) {
                assignedCenter.deliveries.push({
                    ...delivery,
                    assignedColor: assignedCenter.color
                });
            }
        });
        
        // Store results and update visualization
        analysisResults = validResults;
        updateVisualization();
        hideOriginalDeliveryLayer();

        console.log('Analysis complete:', analysisResults.map(r => ({
            centerId: r.centerId,
            deliveryCount: r.deliveries.length,
            color: r.color
        })));
        
    } catch (error) {
        console.error('Analysis failed:', error);
    } finally {
        // Reset loading state
        button.disabled = false;
        button.textContent = '分析開始';
        // loading.style.display = 'none'; // Remove this line since we're not showing it
    }
}

// Update the updateVisualization to store the mapping globally:
function updateVisualization() {
    if (!analysisResults) return;
    
    // Remove existing analysis layers
    clearAnalysisLayers();
    
    // Create consistent color groups mapping and store globally
    colorToIndexMap = {};
    analysisResults.forEach((result) => {
        if (!colorToIndexMap[result.color]) {
            colorToIndexMap[result.color] = Object.keys(colorToIndexMap).length;
        }
    });
    
    console.log('Color to index mapping:', colorToIndexMap); // Debug log
    
    // Group results by color for both isochrones and deliveries
    const colorGroups = {};
    analysisResults.forEach((result, index) => {
        const color = result.color;
        if (!colorGroups[color]) {
            colorGroups[color] = {
                color: color,
                isochroneFeatures: [],
                deliveryFeatures: [],
                centerIds: []
            };
        }
        
        // Add isochrone features with centerId property
        if (result.isochrone && result.isochrone.features) {
            const featuresWithCenterId = result.isochrone.features.map(feature => ({
                ...feature,
                properties: {
                    ...feature.properties,
                    centerId: result.centerId
                }
            }));
            colorGroups[color].isochroneFeatures.push(...featuresWithCenterId);
        }
        
        // Add delivery features
        if (result.deliveries.length > 0) {
            colorGroups[color].deliveryFeatures.push(...result.deliveries);
        }
        
        colorGroups[color].centerIds.push(result.centerId);
    });
    
    // Create layers by color using consistent indexing
    Object.keys(colorGroups).forEach((color) => {
        const group = colorGroups[color];
        const index = colorToIndexMap[color]; // Use consistent index
        
        console.log(`Creating layers for color ${color} with index ${index}`); // Debug log
        
        // Create isochrone layers
        if (group.isochroneFeatures.length > 0) {
            const isochroneSourceId = `isochrone-color-${index}`;
            const combinedIsochroneGeoJSON = {
                type: 'FeatureCollection',
                features: group.isochroneFeatures
            };
            
            map.addSource(isochroneSourceId, {
                type: 'geojson',
                data: combinedIsochroneGeoJSON
            });
            
            map.addLayer({
                id: `isochrone-fill-color-${index}`,
                type: 'fill',
                source: isochroneSourceId,
                paint: {
                    'fill-color': color,
                    'fill-opacity': 0
                },
                filter: ['==', 'centerId', ''] // Initial filter to hide all
            });
            
            map.addLayer({
                id: `isochrone-border-color-${index}`,
                type: 'line',
                source: isochroneSourceId,
                paint: {
                    'line-color': color,
                    'line-width': 2,
                    'line-opacity': 0
                },
                filter: ['==', 'centerId', ''] // Initial filter to hide all
            });
        }
        
        // Create delivery point layers
        if (group.deliveryFeatures.length > 0) {
            const deliverySourceId = `deliveries-color-${index}`;
            const combinedDeliveryGeoJSON = {
                type: 'FeatureCollection',
                features: group.deliveryFeatures
            };
            
            map.addSource(deliverySourceId, {
                type: 'geojson',
                data: combinedDeliveryGeoJSON
            });
            
            map.addLayer({
                id: `deliveries-color-${index}`,
                type: 'circle',
                source: deliverySourceId,
                paint: {
                    "circle-radius": [
                        "interpolate",
                        ["linear"],
                        ["zoom"],
                        0, 2,
                        10, 4,
                        15, 6
                    ],
                    "circle-color": color,
                    "circle-opacity": 0.8,
                    "circle-stroke-width": 1,
                    "circle-stroke-color": "#FFFFFF"
                },
                minzoom: 10
            });
        }
    });
    
    // Create layer for unassigned deliveries
    createUnassignedDeliveriesLayer();
    
    // Add mouseover events for delivery centers
    addDeliveryCenterHoverEvents();
}

function createUnassignedDeliveriesLayer() {
    // Get all assigned delivery IDs
    const assignedIds = new Set();
    if (analysisResults) {
        analysisResults.forEach(result => {
            result.deliveries.forEach(delivery => {
                assignedIds.add(delivery.properties.id || delivery.id);
            });
        });
    }
    
    // Get all delivery features
    const allDeliveries = map.getSource('deliveries')._data.features;
    
    // Filter unassigned deliveries
    const unassignedDeliveries = allDeliveries.filter(delivery => {
        const id = delivery.properties.id || delivery.id;
        return !assignedIds.has(id);
    });
    
    if (unassignedDeliveries.length > 0) {
        const unassignedGeoJSON = {
            type: 'FeatureCollection',
            features: unassignedDeliveries
        };
        
        map.addSource('deliveries-unassigned', {
            type: 'geojson',
            data: unassignedGeoJSON
        });
        
        map.addLayer({
            id: 'deliveries-unassigned',
            type: 'circle',
            source: 'deliveries-unassigned',
            paint: {
                "circle-radius": [
                    "interpolate",
                    ["linear"],
                    ["zoom"],
                    0, 2,
                    10, 4,
                    15, 6
                ],
                "circle-color": "#CCCCCC",
                "circle-opacity": 0.8,
                "circle-stroke-width": 1,
                "circle-stroke-color": "#FFFFFF"
            },
            minzoom: 10
        });
    }
}

// Update the addDeliveryCenterHoverEvents function:
function addDeliveryCenterHoverEvents() {
    // Remove existing event listeners to prevent duplicates
    map.off('mouseenter', 'symbol-delivery-centers');
    map.off('mouseleave', 'symbol-delivery-centers');
    
    let popup = null; // Track popup
    
    map.on('mouseenter', 'symbol-delivery-centers', (e) => {
        const feature = e.features[0];
        const centerId = feature.properties.id;
        
        // Find matching analysis result
        const result = analysisResults.find(r => r.centerId === centerId);
        if (result) {
            const color = result.color;
            
            // Use the global color mapping
            const colorIndex = colorToIndexMap[color];
            
            console.log(`Hovering center ${centerId}, color: ${color}, index: ${colorIndex}`); // Debug log
            
            const fillLayerId = `isochrone-fill-color-${colorIndex}`;
            const borderLayerId = `isochrone-border-color-${colorIndex}`;
            
            // Check if layers exist before setting properties and filters
            if (map.getLayer(fillLayerId)) {
                // Set filter to show only this center's isochrone
                map.setFilter(fillLayerId, ['==', 'centerId', centerId]);
                map.setPaintProperty(fillLayerId, 'fill-opacity', 0.3);
            } else {
                console.warn(`Layer ${fillLayerId} does not exist`); // Debug log
            }
            if (map.getLayer(borderLayerId)) {
                // Set filter to show only this center's isochrone
                map.setFilter(borderLayerId, ['==', 'centerId', centerId]);
                map.setPaintProperty(borderLayerId, 'line-opacity', 1);
            } else {
                console.warn(`Layer ${borderLayerId} does not exist`); // Debug log
            }
            
            // Filter delivery points - hide all delivery layers first
            Object.keys(colorToIndexMap).forEach((c) => {
                const cIndex = colorToIndexMap[c];
                const deliveryLayerId = `deliveries-color-${cIndex}`;
                if (map.getLayer(deliveryLayerId)) {
                    if (cIndex === colorIndex) {
                        // For the matching color, show only deliveries assigned to this center
                        const deliveryIds = result.deliveries.map(d => d.properties.id || d.id);
                        if (deliveryIds.length > 0) {
                            map.setFilter(deliveryLayerId, ['in', ['get', 'id'], ['literal', deliveryIds]]);
                        } else {
                            map.setFilter(deliveryLayerId, ['==', 'id', 'no-match']); // Hide if no deliveries
                        }
                    } else {
                        // Hide all other color delivery layers
                        map.setFilter(deliveryLayerId, ['==', 'id', 'no-match']);
                    }
                }
            });
            
            // Hide unassigned deliveries during hover
            if (map.getLayer('deliveries-unassigned')) {
                map.setFilter('deliveries-unassigned', ['==', 'id', 'no-match']);
            }
            
            // Create popup with delivery count (removed delivery center ID)
            const deliveryCount = result.deliveries.length;
            const html = `<div style="text-align: center; font-family: 'Hiragino Kaku Gothic Pro', 'Yu Gothic', 'Meiryo', sans-serif; font-size: 14px; padding: 5px;">
                <span style="color: ${result.color}; font-weight: bold;">配達数: ${deliveryCount}</span>
            </div>`;
            
            popup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false,
                offset: [0, -10] // Offset popup above the icon
            });

            popup.setLngLat(feature.geometry.coordinates)
                .setHTML(html)
                .addTo(map);
        }
    });
    
    map.on('mouseleave', 'symbol-delivery-centers', (e) => {
        // Remove popup
        if (popup) {
            popup.remove();
            popup = null;
        }
        
        // Use the global color mapping
        Object.keys(colorToIndexMap).forEach((color) => {
            const colorIndex = colorToIndexMap[color];
            const fillLayerId = `isochrone-fill-color-${colorIndex}`;
            const borderLayerId = `isochrone-border-color-${colorIndex}`;
            
            console.log(`Hiding layers for color ${color}, index: ${colorIndex}`); // Debug log
            
            // Check if layers exist before setting properties and filters
            if (map.getLayer(fillLayerId)) {
                map.setFilter(fillLayerId, ['==', 'centerId', '']); // Filter to show nothing
                map.setPaintProperty(fillLayerId, 'fill-opacity', 0);
            }
            if (map.getLayer(borderLayerId)) {
                map.setFilter(borderLayerId, ['==', 'centerId', '']); // Filter to show nothing
                map.setPaintProperty(borderLayerId, 'line-opacity', 0);
            }
            
            // Reset delivery point filters to show all deliveries of each color
            const deliveryLayerId = `deliveries-color-${colorIndex}`;
            if (map.getLayer(deliveryLayerId)) {
                map.setFilter(deliveryLayerId, null); // Show all deliveries of this color
            }
        });
        
        // Show unassigned deliveries again
        if (map.getLayer('deliveries-unassigned')) {
            map.setFilter('deliveries-unassigned', null);
        }
    });
}

function clearAnalysisLayers() {
    // Remove existing analysis layers
    const layers = map.getStyle().layers;
    layers.forEach(layer => {
        if (layer.id.startsWith('isochrone-') || 
            layer.id.startsWith('deliveries-color-') || 
            layer.id === 'deliveries-unassigned') {
            map.removeLayer(layer.id);
        }
    });
    
    // Remove existing analysis sources
    const sources = map.getStyle().sources;
    Object.keys(sources).forEach(sourceId => {
        if (sourceId.startsWith('isochrone-') || 
            sourceId.startsWith('deliveries-color-') || 
            sourceId === 'deliveries-unassigned') {
            map.removeSource(sourceId);
        }
    });
    
    // Show original delivery layer when clearing analysis
    showOriginalDeliveryLayer();
}

// Remove the updateDeliveryColors function since we're not using it anymore

// Keep the original delivery layer hidden during analysis
function hideOriginalDeliveryLayer() {
    if (map.getLayer('symbol-deliveries')) {
        map.setLayoutProperty('symbol-deliveries', 'visibility', 'none');
    }
}

// Show original delivery layer when analysis is cleared
function showOriginalDeliveryLayer() {
    if (map.getLayer('symbol-deliveries')) {
        map.setLayoutProperty('symbol-deliveries', 'visibility', 'visible');
    }
}

// Add these missing functions at the end of your file:

const loadMap = () => {
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/light-v11',
        center: defaultCoordinates,
        zoom: 12,
        minZoom: 3,
        scrollZoom: true,
        language: 'ja'
    })
    
    map.on('load', () => {
        setupControlListeners();
        
        map.loadImage('./assets/images/yamato.png', (error, image) => {
            if (error) throw error;
            if (!map.hasImage('yamato')) {
                map.addImage('yamato', image);
            }
        });

        fetch('deliveryCenters.geojson')
            .then(response => response.json())
            .then(data => {
                addDeliveryCenters(data)
            })
            .catch(error => console.error('Error loading delivery centers:', error));

        fetch('deliveries.geojson')
            .then(response => response.json())
            .then(data => {
                addDeliveries(data)
            })
            .catch(error => console.error('Error loading deliveries:', error));
    })
    
    map.on('click', (event) => {
        const { lng, lat } = event.lngLat;
        console.log(`Longitude: ${lng}, Latitude: ${lat}`);
    })
}

const addDeliveryCenters = (data) => {
    map.addSource('delivery-centers', {
        type: 'geojson',
        data: data,
    });

    map.addLayer({
        id: "symbol-delivery-centers",
        type: "symbol",
        source: "delivery-centers",
        layout: {
            "icon-image": "yamato",
            "icon-size": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0, 0.1,
                10, 0.3,
                15, 0.6
            ],
            "icon-allow-overlap": true
        }
    });
}

const addDeliveries = (data) => {
    map.addSource('deliveries', {
        type: 'geojson',
        data: data
    });

    map.addLayer({
        id: "symbol-deliveries",
        type: "circle",
        source: "deliveries",
        paint: {
            "circle-radius": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0, 2,
                10, 4,
                15, 6
            ],
            "circle-color": "#CCCCCC", // Changed from "#FF0000" to gray
            "circle-opacity": 0.8,
            "circle-stroke-width": 1,
            "circle-stroke-color": "#FFFFFF"
        },
        minzoom: 10
    });
}

// Update the fetchIsochrone function to include retry logic:
async function fetchIsochrone(profile, coordinates, minutes, colors) {
    let contourColors = ''
    if (colors) {
        contourColors = `contours_colors=${colors}`
    }
    const isochrone_uri = 'https://api.mapbox.com/isochrone/v1/';
    const url = `${isochrone_uri}${profile}/${coordinates[0]},${coordinates[1]}?contours_minutes=${minutes}&polygons=true&${contourColors}&access_token=${mapboxgl.accessToken}`;
    
    const maxRetries = 3;
    let retries = 0;
    
    while (retries < maxRetries) {
        try {
            const response = await fetch(url);
            
            if (response.status === 429) {
                // Rate limited, wait and retry
                const retryAfter = response.headers.get('Retry-After') || 2; // Default 2 seconds
                console.warn(`Rate limited, waiting ${retryAfter} seconds before retry ${retries + 1}/${maxRetries}`);
                await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                retries++;
                continue;
            }
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return await response.json();
            
        } catch (error) {
            retries++;
            if (retries >= maxRetries) {
                console.error(`Failed to fetch isochrone after ${maxRetries} retries:`, error);
                throw error;
            }
            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
}

// Add a throttled request function:
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Initialize the map
loadMap()
</script>

</html>
