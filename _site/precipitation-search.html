<p>&lt;!DOCTYPE html&gt;</p>
<html lang="ja">
<head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body, html {
            height: 100%;
            width: 100%;
            font-family: 'Open Sans', sans-serif;
        }

        #map {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            bottom: 0;
        }

        .time-display-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 10px 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            height: 48px;
            display: flex;
            align-items: center;
        }

        .time-display {
            flex-shrink: 0;
        }

        .current-time {
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .date-display {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .time-display-large {
            color: #ffffff;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
        }

        .time-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 50px 12px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            width: 90%;
            max-width: 800px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .time-controls.collapsed {
            min-width: auto;
            width: auto;
            padding: 10px 16px;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .time-controls.collapsed .playback-controls,
        .time-controls.collapsed .timeline-container {
            display: none;
        }

        .controls-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
            display: none;
            order: 1;
        }

        .time-controls.collapsed .controls-title {
            display: inline-block;
        }

        .toggle-btn-dark {
            position: absolute;
            top: 12px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
            order: 2;
        }

        .toggle-btn-dark:hover {
            color: rgba(255, 255, 255, 0.9);
            transform: scale(1.1);
        }

        .time-controls.collapsed .toggle-btn-dark {
            position: static;
        }

        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.98);
        }

        .play-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .play-btn:hover {
            background: linear-gradient(135deg, #5cb85c, #4CAF50);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .play-btn.playing {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .play-btn.playing:hover {
            background: linear-gradient(135deg, #ffa726, #ff9800);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        .timeline-container {
            position: relative;
            padding-bottom: 20px;
            width: 100%;
        }

        .timeline-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            pointer-events: none;
            display: flex;
        }

        .timeline-zone {
            height: 100%;
            transition: all 0.3s ease;
        }

        .timeline-zone.nowcast {
            background: rgba(100, 180, 255, 0.15);
        }

        .timeline-zone.forecast {
            background: rgba(255, 180, 100, 0.15);
        }

        .zone-boundary {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 12px;
            background: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            z-index: 1;
        }

        .zone-label {
            position: absolute;
            top: -18px;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
            pointer-events: none;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .timeline-slider {
            position: relative;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: transparent;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            z-index: 2;
        }

        .timeline-ticks {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            height: 20px;
            pointer-events: none;
        }

        .timeline-tick {
            position: absolute;
            width: 1px;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%);
        }

        .timeline-tick.major {
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        .timeline-tick.nowcast-zone {
            background: rgba(100, 180, 255, 0.5);
        }

        .timeline-tick.nowcast-zone.major {
            background: rgba(100, 180, 255, 0.7);
        }

        .timeline-tick.forecast-zone {
            background: rgba(255, 180, 100, 0.5);
        }

        .timeline-tick.forecast-zone.major {
            background: rgba(255, 180, 100, 0.7);
        }

        .timeline-label {
            position: absolute;
            top: 14px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            transform: translateX(-50%);
            white-space: nowrap;
            font-family: 'Courier New', monospace;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.5);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .timeline-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.5);
        }

        .legend {
            position: absolute;
            bottom: 150px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .legend.collapsed {
            padding: 8px 12px;
        }

        .legend.collapsed .legend-content,
        .legend.collapsed .legend-unit {
            display: none;
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .legend-title {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        .legend.collapsed .legend-title {
            margin-bottom: 0;
        }

        .toggle-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            color: #333;
            transform: scale(1.1);
        }

        .legend-bar {
            width: 20px;
            height: 200px;
            background: linear-gradient(to top,
                rgba(102, 255, 255, 0.9) 0%,
                rgba(0, 204, 255, 0.9) 12.5%,
                rgba(51, 102, 255, 0.9) 25%,
                rgba(51, 255, 0, 0.9) 37.5%,
                rgba(255, 255, 0, 0.9) 50%,
                rgba(255, 153, 0, 0.9) 62.5%,
                rgba(255, 0, 0, 0.9) 75%,
                rgba(183, 0, 16, 0.9) 87.5%,
                rgba(183, 0, 16, 1) 100%
            );
            border-radius: 4px;
            position: relative;
            margin-bottom: 8px;
        }

        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 200px;
            margin-left: 8px;
        }

        .legend-content {
            display: flex;
            margin-top: 8px;
        }

        .label {
            font-size: 11px;
            color: #333;
            font-weight: 500;
        }

        .legend-unit {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        /* Search Box Styles */
        .search-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            z-index: 1000;
        }

        .search-box {
            width: 100%;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            color: #ffffff;
            font-size: 14px;
            font-family: 'Open Sans', sans-serif;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-box:focus {
            border-color: rgba(76, 175, 80, 0.5);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
        }

        .search-results {
            margin-top: 8px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.98), rgba(20, 20, 30, 0.98));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .search-results.visible {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ffffff;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: rgba(76, 175, 80, 0.2);
        }

        .result-name {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .result-address {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 4px;
        }

        .result-precipitation {
            font-size: 11px;
            color: #4CAF50;
            font-weight: 500;
        }

        /* User Location Marker */
        .user-location-marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            border: 3px solid #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        /* Highlighted marker on hover */
        .mapboxgl-marker.highlighted svg {
            transform: scale(1.3);
            filter: drop-shadow(0 0 8px rgba(33, 150, 243, 0.8));
            transition: all 0.2s ease;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .search-container {
                top: 10px;
                right: 10px;
                width: 280px;
            }

            .search-box {
                padding: 10px 14px;
                font-size: 13px;
            }

            .time-display-panel {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
                border-radius: 6px;
            }

            .date-display {
                font-size: 10px;
            }

            .time-display-large {
                font-size: 16px;
            }

            .time-controls {
                bottom: 15px;
                width: 95%;
                padding: 10px 45px 10px 15px;
                gap: 8px;
            }

            .toggle-btn-dark {
                top: 10px;
                right: 15px;
                width: 20px;
                height: 20px;
                font-size: 12px;
            }

            .control-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .play-btn {
                width: 42px;
                height: 42px;
            }

            .timeline-slider {
                height: 10px;
            }

            .timeline-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .timeline-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            .legend {
                bottom: 120px;
                left: 10px;
                padding: 8px;
                border-radius: 6px;
            }

            .legend-title {
                font-size: 11px;
            }

            .legend-bar {
                width: 16px;
                height: 150px;
            }

            .legend-labels {
                height: 150px;
            }

            .label {
                font-size: 10px;
            }

            .legend-unit {
                font-size: 9px;
            }

            .timeline-label {
                font-size: 9px;
            }
        }

        @media (max-width: 480px) {
            .search-container {
                top: 5px;
                right: 5px;
                width: calc(100% - 10px);
                max-width: 300px;
            }

            .search-box {
                padding: 8px 12px;
                font-size: 12px;
            }

            .time-display-panel {
                top: 5px;
                left: 5px;
                padding: 6px 10px;
            }

            .date-display {
                font-size: 9px;
            }

            .time-display-large {
                font-size: 14px;
            }

            .time-controls {
                bottom: 10px;
                width: 98%;
                padding: 8px 40px 8px 12px;
                gap: 6px;
            }

            .toggle-btn-dark {
                top: 8px;
                right: 12px;
                width: 18px;
                height: 18px;
                font-size: 11px;
            }

            .control-btn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }

            .play-btn {
                width: 38px;
                height: 38px;
            }

            .timeline-container {
                padding-bottom: 18px;
            }

            .legend {
                bottom: 110px;
                left: 5px;
                padding: 6px;
            }

            .legend-bar {
                width: 14px;
                height: 120px;
            }

            .legend-labels {
                height: 120px;
            }

            .timeline-label {
                font-size: 8px;
            }

            .timeline-tick {
                height: 4px;
            }

            .timeline-tick.major {
                height: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Search Box -->
    <div class="search-container">
        <input type="text" id="search-box" class="search-box" placeholder="場所を検索..." autocomplete="off" />
        <div id="search-results" class="search-results"></div>
    </div>

    <div class="legend" id="legend">
        <div class="legend-header">
            <div class="legend-title">降水量</div>
            <button class="toggle-btn" id="legend-toggle" title="Toggle Legend">
                <span id="legend-toggle-icon">−</span>
            </button>
        </div>
        <div class="legend-content">
            <div class="legend-bar"></div>
            <div class="legend-labels">
                <span class="label">80</span>
                <span class="label">60</span>
                <span class="label">40</span>
                <span class="label">20</span>
                <span class="label">0</span>
            </div>
        </div>
        <div class="legend-unit">mm/h</div>
    </div>

    <div class="time-display-panel">
        <div class="time-display">
            <div class="current-time">
                <div id="active-date" class="date-display">Loading...</div>
                <div id="active-time" class="time-display-large">--:--</div>
            </div>
        </div>
    </div>

    <div class="time-controls" id="time-controls">
        <button class="toggle-btn-dark" id="controls-toggle" title="Toggle Controls">
            <span id="controls-toggle-icon">−</span>
        </button>
        <span class="controls-title">時刻</span>

        <div class="playback-controls">
            <button id="prev-frame" class="control-btn" title="Previous">
                <span>◀</span>
            </button>
            <button id="play-pause" class="control-btn play-btn" title="Play/Pause">
                <span id="play-icon">▶</span>
            </button>
            <button id="next-frame" class="control-btn" title="Next">
                <span>▶</span>
            </button>
        </div>

        <div class="timeline-container">
            <input type="range" min="0" step="1" value="0" max="0" class="timeline-slider" id="slider" />
            <div class="timeline-ticks" id="timeline-ticks"></div>
        </div>
    </div>

    <script>
        // Initial location (Tokyo)
lat = 35.681236;
lng = 139.767125;

// Define precipitation tilesets
const tilesets = {
    nowcast: {
        value: 'mapbox://mapbox.weather-jp-nowcast',
        label: 'Current Precipitation',
        colorscale: 'Rain'
    },
    nowcast_last60min: {
        value: 'mapbox://mapbox.weather-jp-nowcast-last-60m',
        label: 'Past 60 Minutes',
        colorscale: 'Rain'
    },
    rain_6: {
        value: 'mapbox://mapbox.weather-jp-rain-1-6',
        label: '1-6 Hour Forecast',
        colorscale: 'Rain'
    },
    rain_15: {
        value: 'mapbox://mapbox.weather-jp-rain-7-15',
        label: '7-15 Hour Forecast',
        colorscale: 'Rain'
    }
};

// Global state
let map;
let unifiedBands = [];
let currentBandIndex = 0;
let nowBandIndex = 0; // Band index closest to current time
let allTilesetData = {};
let isPlaying = false;
let playInterval = null;
let userLocationMarker = null;
let userCoordinates = null;
let suggestionMarkers = [];
let selectedMarker = null;
let sessionToken = null;

// Generate UUIDv4 for session token
function generateSessionToken() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Clear all suggestion markers from the map
function clearSuggestionMarkers() {
    suggestionMarkers.forEach(marker => marker.remove());
    suggestionMarkers = [];

    // Also clear selected marker if any
    if (selectedMarker) {
        selectedMarker.remove();
        selectedMarker = null;
    }
}

// Highlight marker for a specific suggestion
function highlightMarkerForSuggestion(mapboxId) {
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === mapboxId);
    if (marker) {
        marker.getElement().classList.add('highlighted');
    }
}

// Remove highlight from marker
function unhighlightMarkerForSuggestion(mapboxId) {
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === mapboxId);
    if (marker) {
        marker.getElement().classList.remove('highlighted');
    }
}

// Create color scale for precipitation
function createRainColorScale() {
    const domain = [2, 10, 20, 30, 40, 50, 60, 70, 80];
    const colors = [
        'rgba(102, 255, 255, 0.7)',
        'rgba(0, 204, 255, 0.7)',
        'rgba(51, 102, 255, 0.7)',
        'rgba(51, 255, 0, 0.7)',
        'rgba(255, 255, 0, 0.7)',
        'rgba(255, 153, 0, 0.7)',
        'rgba(255, 0, 0, 0.7)',
        'rgba(183, 0, 16, 0.7)',
        'rgba(183, 0, 16, 0.9)'
    ];

    return ['step', ['raster-value'], 'rgba(0, 0, 0, 0)', ...domain.flatMap((d, i) => [d, colors[i]])];
}

// Convert band timestamp to JST date/time
function formatBandTime(band) {
    // Validate input
    if (band === undefined || band === null || isNaN(band)) {
        console.error('Invalid band value:', band);
        return { date: 'Invalid', time: '--:--' };
    }

    // Band is a Unix timestamp in seconds
    const utcDate = new Date(band * 1000);

    // Check if date is valid
    if (isNaN(utcDate.getTime())) {
        console.error('Invalid date calculated from band:', band);
        return { date: 'Invalid', time: '--:--' };
    }

    try {
        // Convert to JST by creating a date string with timezone
        const formatter = new Intl.DateTimeFormat('ja-JP', {
            timeZone: 'Asia/Tokyo',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
        });

        const parts = formatter.formatToParts(utcDate);
        const year = parts.find(p => p.type === 'year').value;
        const month = parts.find(p => p.type === 'month').value;
        const day = parts.find(p => p.type === 'day').value;
        const hour = parts.find(p => p.type === 'hour').value;
        const minute = parts.find(p => p.type === 'minute').value;

        return {
            date: `${year}/${month}/${day}`,
            time: `${hour}:${minute}`
        };
    } catch (error) {
        console.error('Error formatting date:', error);
        return { date: 'Error', time: '--:--' };
    }
}

// Load all precipitation tilesets
async function loadAllTilesets() {
    console.log('Loading all tilesets...');

    const promises = Object.entries(tilesets).map(async ([id, config]) => {
        const tilesetId = config.value.split('/').pop();
        const tilejsonUrl = `https://api.mapbox.com/v4/${tilesetId}.json?access_token=${mapboxgl.accessToken}`;

        try {
            const response = await fetch(tilejsonUrl);
            const tilejson = await response.json();
            allTilesetData[id] = tilejson;
            return { id, tilejson };
        } catch (error) {
            console.error(`Error loading ${id}:`, error);
            return null;
        }
    });

    const results = await Promise.all(promises);

    // Build unified band list
    unifiedBands = [];
    let globalIndex = 0;

    results.forEach(result => {
        if (!result || !result.tilejson) return;

        const { id, tilejson } = result;
        const layer = tilejson.raster_layers?.[0];

        if (layer && layer.fields.bands) {
            layer.fields.bands.forEach((band, bandIndex) => {
                unifiedBands.push({
                    tilesetId: id,
                    band: band,
                    timestamp: band,
                    localIndex: bandIndex,
                    globalIndex: globalIndex++,
                    layer: layer.fields.name,
                    colorRange: layer.fields.range
                });
            });
        }
    });

    // Sort by timestamp
    unifiedBands.sort((a, b) => a.timestamp - b.timestamp);

    // Re-index after sorting
    unifiedBands.forEach((item, idx) => {
        item.globalIndex = idx;
    });

    console.log(`Loaded ${unifiedBands.length} bands total`);

    // Find current time band (timestamps are Unix timestamps in seconds)
    const now = new Date();
    const nowValue = Math.floor(now.getTime() / 1000);

    let minDiff = Infinity;
    unifiedBands.forEach((item, idx) => {
        const diff = Math.abs(item.timestamp - nowValue);
        if (diff < minDiff) {
            minDiff = diff;
            nowBandIndex = idx;
        }
    });

    currentBandIndex = nowBandIndex; // Start at current time

    console.log(`Current band index: ${currentBandIndex}, time: ${formatBandTime(unifiedBands[currentBandIndex].band).time}`);

    return unifiedBands[0]; // Return first band info
}

// Update time display
function updateTimeDisplay(index) {
    const band = unifiedBands[index];
    if (!band) return;

    const { date, time } = formatBandTime(band.band);

    // Determine if this is past, current, or forecast
    let suffix = '';
    if (index === nowBandIndex) {
        suffix = ' （現在）';
    } else if (index > nowBandIndex) {
        suffix = ' （予報）';
    }
    // Past times have no suffix

    document.getElementById('active-date').textContent = date;
    document.getElementById('active-time').textContent = time + suffix;
}

// Track current active layer
let currentActiveLayer = null;

// Initialize all precipitation layers upfront
function initializePrecipitationLayers() {
    // Create a layer for each tileset
    Object.entries(tilesets).forEach(([tilesetId, config]) => {
        const sourceId = `precipitation-source-${tilesetId}`;
        const layerId = `precipitation-layer-${tilesetId}`;

        // Add source
        map.addSource(sourceId, {
            type: 'raster-array',
            url: config.value
        });

        // Get layer info from first band of this tileset
        const firstBandOfTileset = unifiedBands.find(b => b.tilesetId === tilesetId);
        if (!firstBandOfTileset) return;

        // Add layer with initial opacity 0
        map.addLayer({
            id: layerId,
            type: 'raster',
            source: sourceId,
            'source-layer': firstBandOfTileset.layer,
            paint: {
                'raster-color-range': firstBandOfTileset.colorRange,
                'raster-color': createRainColorScale(),
                'raster-resampling': 'nearest',
                'raster-color-range-transition': { duration: 0 },
                'raster-opacity': 0, // Start invisible
                'raster-array-band': firstBandOfTileset.band,
                'raster-emissive-strength': 1.0,
                'raster-fade-duration': 0
            }
        }, 'road-label');
    });

    console.log('Initialized all precipitation layers');
}

// Change to a specific band
function changeBand(index) {
    if (!unifiedBands.length) return;

    currentBandIndex = parseInt(index);
    const bandInfo = unifiedBands[currentBandIndex];

    // Validate bandInfo
    if (!bandInfo) {
        console.error('Invalid band index:', index);
        return;
    }

    // Validate tilesetId
    if (!tilesets[bandInfo.tilesetId]) {
        console.error('Invalid tilesetId:', bandInfo.tilesetId, 'Available:', Object.keys(tilesets));
        return;
    }

    updateTimeDisplay(currentBandIndex);

    const targetLayerId = `precipitation-layer-${bandInfo.tilesetId}`;

    // If switching to a different tileset layer
    if (currentActiveLayer && currentActiveLayer !== targetLayerId) {
        // Hide the old layer
        map.setPaintProperty(currentActiveLayer, 'raster-opacity', 0);
    }

    // Show the target layer and set its band
    map.setPaintProperty(targetLayerId, 'raster-opacity', 0.8);
    map.setPaintProperty(targetLayerId, 'raster-array-band', bandInfo.band);

    currentActiveLayer = targetLayerId;
}

// Playback controls
function previousFrame() {
    if (currentBandIndex > 0) {
        document.getElementById('slider').value = currentBandIndex - 1;
        changeBand(currentBandIndex - 1);
    }
}

function nextFrame() {
    if (currentBandIndex < unifiedBands.length - 1) {
        document.getElementById('slider').value = currentBandIndex + 1;
        changeBand(currentBandIndex + 1);
    }
}

function togglePlay() {
    const playBtn = document.getElementById('play-pause');
    const playIcon = document.getElementById('play-icon');

    if (isPlaying) {
        isPlaying = false;
        playBtn.classList.remove('playing');
        playIcon.textContent = '▶';
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
    } else {
        isPlaying = true;
        playBtn.classList.add('playing');
        playIcon.textContent = '⏸';
        playInterval = setInterval(() => {
            if (currentBandIndex < unifiedBands.length - 1) {
                nextFrame();
            } else {
                currentBandIndex = -1;
                nextFrame();
            }
        }, 1000);
    }
}

// Calculate zone boundaries
function calculateZoneBoundaries() {
    // Find the last nowcast band index (nowcast and nowcast_last60min)
    let lastNowcastIndex = -1;
    for (let i = unifiedBands.length - 1; i >= 0; i--) {
        const tilesetId = unifiedBands[i].tilesetId;
        if (tilesetId === 'nowcast' || tilesetId === 'nowcast_last60min') {
            lastNowcastIndex = i;
            break;
        }
    }

    const totalBands = unifiedBands.length;
    const nowcastPercent = lastNowcastIndex >= 0 ? ((lastNowcastIndex + 1) / totalBands) * 100 : 0;
    const forecastPercent = 100 - nowcastPercent;

    return {
        nowcastEnd: lastNowcastIndex,
        nowcastPercent,
        forecastPercent
    };
}

// Generate zone backgrounds and labels
function generateZoneBackgrounds() {
    const container = document.querySelector('.timeline-container');
    if (!container || !unifiedBands.length) return;

    // Remove existing zones
    const existingZones = container.querySelector('.timeline-zones');
    if (existingZones) existingZones.remove();

    const existingBoundary = container.querySelector('.zone-boundary');
    if (existingBoundary) existingBoundary.remove();

    const existingLabels = container.querySelectorAll('.zone-label');
    existingLabels.forEach(label => label.remove());

    const zones = calculateZoneBoundaries();
    const slider = document.getElementById('slider');
    const sliderRect = slider.getBoundingClientRect();
    const thumbWidth = window.innerWidth <= 768 ? 24 : 20;
    const trackWidth = sliderRect.width;
    const offsetPercent = (thumbWidth / 2 / trackWidth) * 100;

    // Create zones container
    const zonesDiv = document.createElement('div');
    zonesDiv.className = 'timeline-zones';

    // Nowcast zone
    const nowcastZone = document.createElement('div');
    nowcastZone.className = 'timeline-zone nowcast';
    nowcastZone.style.width = zones.nowcastPercent + '%';
    zonesDiv.appendChild(nowcastZone);

    // Forecast zone
    const forecastZone = document.createElement('div');
    forecastZone.className = 'timeline-zone forecast';
    forecastZone.style.width = zones.forecastPercent + '%';
    zonesDiv.appendChild(forecastZone);

    container.insertBefore(zonesDiv, slider);

    // Add boundary line at transition
    if (zones.nowcastEnd >= 0 && zones.nowcastEnd < unifiedBands.length - 1) {
        const boundaryIndex = zones.nowcastEnd + 0.5; // Between nowcast and forecast
        const rawPosition = (boundaryIndex / (unifiedBands.length - 1)) * 100;
        const position = offsetPercent + (rawPosition * (100 - 2 * offsetPercent) / 100);

        const boundary = document.createElement('div');
        boundary.className = 'zone-boundary';
        boundary.style.left = position + '%';
        container.appendChild(boundary);
    }

    // Add zone labels
    if (zones.nowcastPercent > 5) {
        const nowcastCenter = zones.nowcastPercent / 2;
        const nowcastLabel = document.createElement('div');
        nowcastLabel.className = 'zone-label';
        nowcastLabel.textContent = '5分間隔';
        nowcastLabel.style.left = nowcastCenter + '%';
        container.appendChild(nowcastLabel);
    }

    if (zones.forecastPercent > 5) {
        const forecastCenter = zones.nowcastPercent + (zones.forecastPercent / 2);
        const forecastLabel = document.createElement('div');
        forecastLabel.className = 'zone-label';
        forecastLabel.textContent = '1時間間隔';
        forecastLabel.style.left = forecastCenter + '%';
        container.appendChild(forecastLabel);
    }
}

// Generate timeline tick marks and labels
function generateTimelineTicks() {
    const ticksContainer = document.getElementById('timeline-ticks');
    const slider = document.getElementById('slider');
    if (!ticksContainer || !slider || !unifiedBands.length) return;

    ticksContainer.innerHTML = '';
    const totalBands = unifiedBands.length;
    const zones = calculateZoneBoundaries();

    // Get slider dimensions to account for thumb offset
    const sliderRect = slider.getBoundingClientRect();
    // Detect thumb width based on screen size (mobile has larger thumbs)
    const thumbWidth = window.innerWidth <= 768 ? 24 : 20;
    const trackWidth = sliderRect.width;
    const offsetPercent = (thumbWidth / 2 / trackWidth) * 100;

    // Determine tick interval (show tick every N bands)
    const minorTickInterval = Math.max(1, Math.floor(totalBands / 40)); // ~40 minor ticks
    const majorTickInterval = Math.max(5, Math.floor(totalBands / 8));  // ~8 major ticks with labels

    for (let i = 0; i < totalBands; i++) {
        const isMajor = i % majorTickInterval === 0 || i === totalBands - 1;
        const isMinor = i % minorTickInterval === 0;

        if (!isMajor && !isMinor) continue;

        // Calculate position accounting for thumb offset
        const rawPosition = (i / (totalBands - 1)) * 100;
        const position = offsetPercent + (rawPosition * (100 - 2 * offsetPercent) / 100);

        // Determine zone class
        const isNowcast = i <= zones.nowcastEnd;
        const zoneClass = isNowcast ? 'nowcast-zone' : 'forecast-zone';

        // Create tick mark
        const tick = document.createElement('div');
        tick.className = isMajor ? `timeline-tick major ${zoneClass}` : `timeline-tick ${zoneClass}`;
        tick.style.left = position + '%';
        tick.dataset.bandIndex = i;
        ticksContainer.appendChild(tick);

        // Add label for major ticks
        if (isMajor) {
            const band = unifiedBands[i];
            const { time } = formatBandTime(band.band);

            const label = document.createElement('div');
            label.className = 'timeline-label';
            label.textContent = time;
            label.style.left = position + '%';
            label.dataset.bandIndex = i;
            ticksContainer.appendChild(label);
        }
    }

    console.log(`Generated ticks with offset: ${offsetPercent.toFixed(2)}%, track width: ${trackWidth}px`);
}

// Initialize map
async function initMap() {
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/kenji-shima/cmfurpm8w00j101r86qp530c8',
        center: [lng, lat],
        zoom: 4,
        projection: 'mercator',
        language: 'ja'
    });

    map.on('load', async () => {
        console.log('Map loaded');

        // Load all tilesets
        await loadAllTilesets();

        // Initialize all precipitation layers
        initializePrecipitationLayers();

        // Set up slider
        const slider = document.getElementById('slider');
        slider.max = unifiedBands.length - 1;
        slider.value = currentBandIndex;

        // Generate zone backgrounds
        generateZoneBackgrounds();

        // Generate timeline ticks
        generateTimelineTicks();

        // Initialize display (show current band)
        changeBand(currentBandIndex);

        // Initialize user location
        initUserLocation();

        // Initialize search functionality
        initSearch();

        // Set up event listeners
        slider.addEventListener('input', (e) => changeBand(e.target.value));
        document.getElementById('prev-frame').addEventListener('click', previousFrame);
        document.getElementById('next-frame').addEventListener('click', nextFrame);
        document.getElementById('play-pause').addEventListener('click', togglePlay);

        // Legend toggle
        document.getElementById('legend-toggle').addEventListener('click', () => {
            const legend = document.getElementById('legend');
            const icon = document.getElementById('legend-toggle-icon');
            legend.classList.toggle('collapsed');
            icon.textContent = legend.classList.contains('collapsed') ? '+' : '−';
        });

        // Controls toggle
        document.getElementById('controls-toggle').addEventListener('click', () => {
            const controls = document.getElementById('time-controls');
            const icon = document.getElementById('controls-toggle-icon');
            controls.classList.toggle('collapsed');
            icon.textContent = controls.classList.contains('collapsed') ? '+' : '−';
        });

        console.log('Initialization complete');
    });
}

// Debounce function for resize events
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Get user's current location
function getUserLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error('Geolocation is not supported by your browser'));
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const coords = {
                    lng: position.coords.longitude,
                    lat: position.coords.latitude
                };
                resolve(coords);
            },
            (error) => {
                console.error('Error getting user location:', error);
                reject(error);
            },
            {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            }
        );
    });
}

// Add user location marker to map
function addUserLocationMarker(coordinates) {
    // Remove existing marker if any
    if (userLocationMarker) {
        userLocationMarker.remove();
    }

    // Create marker element
    const el = document.createElement('div');
    el.className = 'user-location-marker';
    el.title = 'Your Location';

    // Create and add marker
    userLocationMarker = new mapboxgl.Marker({
        element: el,
        anchor: 'center'
    })
        .setLngLat([coordinates.lng, coordinates.lat])
        .addTo(map);

    // Store coordinates
    userCoordinates = coordinates;

    console.log('User location marker added at:', coordinates);
}

// Initialize user location
async function initUserLocation() {
    try {
        const coords = await getUserLocation();
        console.log('User location obtained:', coords);

        // Add marker to map
        addUserLocationMarker(coords);

        // Optionally fly to user location
        map.flyTo({
            center: [coords.lng, coords.lat],
            zoom: 8,
            duration: 2000
        });
    } catch (error) {
        console.error('Could not get user location:', error.message);
        // Fallback to default Tokyo location
        console.log('Using default location (Tokyo)');
    }
}

// Get precipitation value at a specific coordinate using queryRasterValue
function getPrecipitationAtLocation(lng, lat) {
    return new Promise((resolve) => {
        try {
            // Get the current active band
            const bandInfo = unifiedBands[currentBandIndex];
            if (!bandInfo) {
                resolve(null);
                return;
            }

            const sourceId = `precipitation-source-${bandInfo.tilesetId}`;
            const sourceLayer = bandInfo.layer;

            // Query raster value at the coordinate
            const features = map.queryRasterValue(sourceId, [lng, lat], {
                sourceLayer: sourceLayer
            });

            if (features && features.length > 0) {
                const value = features[0];
                // The value should be the precipitation amount
                resolve(value);
            } else {
                resolve(null);
            }
        } catch (error) {
            console.error('Error querying raster value:', error);
            resolve(null);
        }
    });
}

// Format precipitation value for display
function formatPrecipitation(value) {
    if (value === null || value === undefined || isNaN(value)) {
        return '降水なし';
    }
    if (value < 0.5) {
        return '降水なし';
    }
    return `降水量: ${value.toFixed(1)} mm/h`;
}

// Initialize search functionality
function initSearch() {
    try {
        const searchInput = document.getElementById('search-box');
        const searchResults = document.getElementById('search-results');

        // Generate initial session token
        sessionToken = generateSessionToken();
        console.log('Search session token:', sessionToken);

        // Debounce search input
        let searchTimeout;

        searchInput.addEventListener('input', async (e) => {
            const query = e.target.value.trim();

            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            // Hide results if query is empty
            if (query === '') {
                searchResults.classList.remove('visible');
                searchResults.innerHTML = '';
                clearSuggestionMarkers();
                return;
            }

            // Debounce search
            searchTimeout = setTimeout(async () => {
                await performSearch(query);
            }, 300);
        });

        // Note: Results will stay visible until user types again or selects a result
        // This allows users to click on the map or interact with markers without losing results

        console.log('Search initialized successfully');
    } catch (error) {
        console.error('Error initializing search:', error);
    }
}

// Perform search using SearchBox API /suggest endpoint
async function performSearch(query) {
    const searchResults = document.getElementById('search-results');

    try {
        // Clear previous suggestion markers
        clearSuggestionMarkers();

        // Build SearchBox API suggest URL
        const encodedQuery = encodeURIComponent(query);
        let url = `https://api.mapbox.com/search/searchbox/v1/suggest?q=${encodedQuery}&access_token=${mapboxgl.accessToken}&session_token=${sessionToken}&language=ja&country=JP&limit=10`;

        // Add proximity if user location is available
        if (userCoordinates) {
            url += `&proximity=${userCoordinates.lng},${userCoordinates.lat}`;
        }

        const response = await fetch(url);
        const data = await response.json();

        if (!data.suggestions || data.suggestions.length === 0) {
            searchResults.innerHTML = '<div class="search-result-item">結果が見つかりませんでした</div>';
            searchResults.classList.add('visible');
            return;
        }

        // Display results
        searchResults.innerHTML = '';
        searchResults.classList.add('visible');

        // Process each suggestion
        for (const suggestion of data.suggestions) {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';

            // Create result HTML structure
            const nameDiv = document.createElement('div');
            nameDiv.className = 'result-name';
            nameDiv.textContent = suggestion.name || 'Unknown';

            const addressDiv = document.createElement('div');
            addressDiv.className = 'result-address';
            addressDiv.textContent = suggestion.place_formatted || '';

            const precipDiv = document.createElement('div');
            precipDiv.className = 'result-precipitation';
            precipDiv.textContent = '読み込み中...';

            resultItem.appendChild(nameDiv);
            resultItem.appendChild(addressDiv);
            resultItem.appendChild(precipDiv);

            // Store the suggestion data for retrieval
            resultItem.dataset.mapboxId = suggestion.mapbox_id;

            // Add click handler
            resultItem.addEventListener('click', async () => {
                await handleResultSelection(suggestion);
            });

            // Add hover handlers to highlight marker
            resultItem.addEventListener('mouseenter', () => {
                highlightMarkerForSuggestion(suggestion.mapbox_id);
            });

            resultItem.addEventListener('mouseleave', () => {
                unhighlightMarkerForSuggestion(suggestion.mapbox_id);
            });

            searchResults.appendChild(resultItem);

            // Retrieve full details to get coordinates, add marker, and query precipitation
            retrieveAndAddMarker(suggestion, precipDiv);
        }
    } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div class="search-result-item">検索エラーが発生しました</div>';
        searchResults.classList.add('visible');
    }
}

// Retrieve feature details, add marker, and query precipitation
async function retrieveAndAddMarker(suggestion, precipDiv) {
    try {
        const url = `https://api.mapbox.com/search/searchbox/v1/retrieve/${suggestion.mapbox_id}?access_token=${mapboxgl.accessToken}&session_token=${sessionToken}`;

        const response = await fetch(url);
        const data = await response.json();

        if (data.features && data.features.length > 0) {
            const feature = data.features[0];
            const [lng, lat] = feature.geometry.coordinates;

            // Add marker for this suggestion
            const marker = new mapboxgl.Marker({ color: '#2196F3' })
                .setLngLat([lng, lat])
                .setPopup(
                    new mapboxgl.Popup({ offset: 25 })
                        .setHTML(`<strong>${suggestion.name}</strong><br>${suggestion.place_formatted || ''}`)
                )
                .addTo(map);

            // Store marker reference with suggestion data
            marker.suggestionData = suggestion;
            suggestionMarkers.push(marker);

            // Query precipitation value
            const value = await getPrecipitationAtLocation(lng, lat);
            precipDiv.textContent = formatPrecipitation(value);
        } else {
            precipDiv.textContent = '位置情報なし';
        }
    } catch (error) {
        console.error('Error retrieving feature:', error);
        precipDiv.textContent = 'エラー';
    }
}

// Handle search result selection
async function handleResultSelection(suggestion) {
    const searchInput = document.getElementById('search-box');
    const searchResults = document.getElementById('search-results');

    // Hide results
    searchResults.classList.remove('visible');

    // Update search input
    searchInput.value = suggestion.name || '';

    // Find the marker for this suggestion
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === suggestion.mapbox_id);

    if (marker) {
        // Remove previous selected marker if any
        if (selectedMarker && selectedMarker !== marker) {
            selectedMarker.remove();
        }

        // Create a highlighted marker at the same location
        const lngLat = marker.getLngLat();

        // Remove the blue marker
        marker.remove();

        // Add orange/red selected marker
        selectedMarker = new mapboxgl.Marker({ color: '#FF5722' })
            .setLngLat(lngLat)
            .setPopup(
                new mapboxgl.Popup({ offset: 25 })
                    .setHTML(`<strong>${suggestion.name}</strong><br>${suggestion.place_formatted || ''}`)
            )
            .addTo(map);

        // Fly to location
        map.flyTo({
            center: lngLat,
            zoom: 12,
            duration: 1500
        });

        // Show popup
        selectedMarker.togglePopup();

        // Generate new session token after selection (session ends after retrieve)
        sessionToken = generateSessionToken();
        console.log('New session token generated after selection:', sessionToken);
    } else {
        console.error('Marker not found for suggestion:', suggestion.name);
    }
}

// Handle window resize
const handleResize = debounce(() => {
    if (unifiedBands.length > 0) {
        generateZoneBackgrounds();
        generateTimelineTicks();
        console.log('Zones and ticks regenerated for new screen size');
    }
}, 250);

// Add resize listener
window.addEventListener('resize', handleResize);

// Start the app
initMap();

    </script>
</body>
</html>
