<p>&lt;!DOCTYPE html&gt;</p>
<html lang="ja">
<head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body, html {
            height: 100%;
            width: 100%;
            font-family: 'Open Sans', sans-serif;
        }

        #map {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            bottom: 0;
        }

        .time-display-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 10px 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            height: 48px;
            display: flex;
            align-items: center;
        }

        .time-display {
            flex-shrink: 0;
        }

        .current-time {
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .date-display {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .time-display-large {
            color: #ffffff;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 0.5px;
            font-family: 'Courier New', monospace;
        }

        .time-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 50px 12px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            width: 90%;
            max-width: 800px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
        }

        .time-controls.collapsed {
            min-width: auto;
            width: auto;
            padding: 10px 16px;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .time-controls.collapsed .playback-controls,
        .time-controls.collapsed .timeline-container {
            display: none;
        }

        .controls-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 0.5px;
            display: none;
            order: 1;
        }

        .time-controls.collapsed .controls-title {
            display: inline-block;
        }

        .toggle-btn-dark {
            position: absolute;
            top: 12px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
            order: 2;
        }

        .toggle-btn-dark:hover {
            color: rgba(255, 255, 255, 0.9);
            transform: scale(1.1);
        }

        .time-controls.collapsed .toggle-btn-dark {
            position: static;
        }

        .playback-controls {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.98);
        }

        .play-btn {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .play-btn:hover {
            background: linear-gradient(135deg, #5cb85c, #4CAF50);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .play-btn.playing {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }

        .play-btn.playing:hover {
            background: linear-gradient(135deg, #ffa726, #ff9800);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
        }

        .timeline-container {
            position: relative;
            padding-bottom: 20px;
            width: 100%;
        }

        .timeline-zones {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            pointer-events: none;
            display: flex;
        }

        .timeline-zone {
            height: 100%;
            transition: all 0.3s ease;
        }

        .timeline-zone.nowcast {
            background: rgba(100, 180, 255, 0.15);
        }

        .timeline-zone.forecast {
            background: rgba(255, 180, 100, 0.15);
        }

        .zone-boundary {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 12px;
            background: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            z-index: 1;
        }

        .zone-label {
            position: absolute;
            top: -18px;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
            pointer-events: none;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .timeline-slider {
            position: relative;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: transparent;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            z-index: 2;
        }

        .timeline-ticks {
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            height: 20px;
            pointer-events: none;
        }

        .timeline-tick {
            position: absolute;
            width: 1px;
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(-50%);
        }

        .timeline-tick.major {
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        .timeline-tick.nowcast-zone {
            background: rgba(100, 180, 255, 0.5);
        }

        .timeline-tick.nowcast-zone.major {
            background: rgba(100, 180, 255, 0.7);
        }

        .timeline-tick.forecast-zone {
            background: rgba(255, 180, 100, 0.5);
        }

        .timeline-tick.forecast-zone.major {
            background: rgba(255, 180, 100, 0.7);
        }

        .timeline-label {
            position: absolute;
            top: 14px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            transform: translateX(-50%);
            white-space: nowrap;
            font-family: 'Courier New', monospace;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.5);
        }

        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        .timeline-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.5);
        }

        .legend {
            position: absolute;
            bottom: 150px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .legend.collapsed {
            padding: 8px 12px;
        }

        .legend.collapsed .legend-content,
        .legend.collapsed .legend-unit {
            display: none;
        }

        .legend-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .legend-title {
            font-size: 12px;
            font-weight: 600;
            color: #333;
        }

        .legend.collapsed .legend-title {
            margin-bottom: 0;
        }

        .toggle-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            color: #333;
            transform: scale(1.1);
        }

        .legend-bar {
            width: 20px;
            height: 200px;
            background: linear-gradient(to top,
                rgba(102, 255, 255, 0.9) 0%,
                rgba(0, 204, 255, 0.9) 12.5%,
                rgba(51, 102, 255, 0.9) 25%,
                rgba(51, 255, 0, 0.9) 37.5%,
                rgba(255, 255, 0, 0.9) 50%,
                rgba(255, 153, 0, 0.9) 62.5%,
                rgba(255, 0, 0, 0.9) 75%,
                rgba(183, 0, 16, 0.9) 87.5%,
                rgba(183, 0, 16, 1) 100%
            );
            border-radius: 4px;
            position: relative;
            margin-bottom: 8px;
        }

        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 200px;
            margin-left: 8px;
        }

        .legend-content {
            display: flex;
            margin-top: 8px;
        }

        .label {
            font-size: 11px;
            color: #333;
            font-weight: 500;
        }

        .legend-unit {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        /* Search Box Styles */
        .search-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 480px;
            z-index: 1000;
        }

        .search-box {
            width: 100%;
            padding: 12px 40px 12px 16px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.95), rgba(20, 20, 30, 0.95));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            color: #ffffff;
            font-size: 14px;
            font-family: 'Open Sans', sans-serif;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-box:focus {
            border-color: rgba(76, 175, 80, 0.5);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
        }

        .clear-search-btn {
            position: absolute;
            right: 8px;
            top: 8px;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.7);
            font-size: 20px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
        }

        .clear-search-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .search-results {
            margin-top: 8px;
            background: linear-gradient(135deg, rgba(30, 30, 40, 0.98), rgba(20, 20, 30, 0.98));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .search-results.visible {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
            color: #ffffff;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover,
        .search-result-item.marker-hovered {
            background: rgba(76, 175, 80, 0.2);
        }

        .result-name {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .result-address {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 4px;
        }

        .result-precipitation {
            font-size: 11px;
            color: #4CAF50;
            font-weight: 500;
        }

        .result-arrival-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .result-eta {
            font-size: 11px;
            color: #2196F3;
            font-weight: 500;
        }

        /* Mapbox Popup Styling */
        .mapboxgl-popup-content {
            background: transparent !important;
            padding: 0 !important;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.5) !important;
            position: relative !important;
            overflow: visible !important;
            display: block !important;
        }

        .mapboxgl-popup-tip {
            border-top-color: #2c2c2c !important;
            border-bottom-color: #2c2c2c !important;
        }

        .mapboxgl-popup-close-button {
            display: none !important;
        }

        /* User Location Marker */
        .user-location-marker {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            border: 3px solid #ffffff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        /* Highlighted marker on hover */
        .mapboxgl-marker.highlighted svg {
            transform: scale(1.3);
            transition: all 0.2s ease;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .search-container {
                top: 70px;
                right: 10px;
                left: 10px;
                width: auto;
                max-width: 100%;
            }

            .search-box {
                padding: 10px 14px;
                font-size: 13px;
            }

            .time-display-panel {
                top: 10px;
                left: 10px;
                padding: 8px 12px;
                border-radius: 6px;
            }

            .date-display {
                font-size: 10px;
            }

            .time-display-large {
                font-size: 16px;
            }

            .time-controls {
                bottom: 15px;
                width: 95%;
                padding: 10px 45px 10px 15px;
                gap: 8px;
            }

            .toggle-btn-dark {
                top: 10px;
                right: 15px;
                width: 20px;
                height: 20px;
                font-size: 12px;
            }

            .control-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .play-btn {
                width: 42px;
                height: 42px;
            }

            .timeline-slider {
                height: 10px;
            }

            .timeline-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .timeline-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            .legend {
                bottom: 120px;
                left: 10px;
                padding: 8px;
                border-radius: 6px;
            }

            .legend-title {
                font-size: 11px;
            }

            .legend-bar {
                width: 16px;
                height: 150px;
            }

            .legend-labels {
                height: 150px;
            }

            .label {
                font-size: 10px;
            }

            .legend-unit {
                font-size: 9px;
            }

            .timeline-label {
                font-size: 9px;
            }
        }

        @media (max-width: 480px) {
            .search-container {
                top: 60px;
                right: 5px;
                left: 5px;
                width: auto;
                max-width: 100%;
            }

            .search-box {
                padding: 8px 12px;
                font-size: 12px;
            }

            .time-display-panel {
                top: 5px;
                left: 5px;
                padding: 6px 10px;
            }

            .date-display {
                font-size: 9px;
            }

            .time-display-large {
                font-size: 14px;
            }

            .time-controls {
                bottom: 10px;
                width: 98%;
                padding: 8px 40px 8px 12px;
                gap: 6px;
            }

            .toggle-btn-dark {
                top: 8px;
                right: 12px;
                width: 18px;
                height: 18px;
                font-size: 11px;
            }

            .control-btn {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }

            .play-btn {
                width: 38px;
                height: 38px;
            }

            .timeline-container {
                padding-bottom: 18px;
            }

            .legend {
                bottom: 110px;
                left: 5px;
                padding: 6px;
            }

            .legend-bar {
                width: 14px;
                height: 120px;
            }

            .legend-labels {
                height: 120px;
            }

            .timeline-label {
                font-size: 8px;
            }

            .timeline-tick {
                height: 4px;
            }

            .timeline-tick.major {
                height: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Search Box -->
    <div class="search-container">
        <input type="text" id="search-box" class="search-box" placeholder="場所を検索..." autocomplete="off" />
        <button id="clear-search" class="clear-search-btn" style="display: none;">×</button>
        <div id="search-results" class="search-results"></div>
    </div>

    <div class="legend" id="legend">
        <div class="legend-header">
            <div class="legend-title">降水量</div>
            <button class="toggle-btn" id="legend-toggle" title="Toggle Legend">
                <span id="legend-toggle-icon">−</span>
            </button>
        </div>
        <div class="legend-content">
            <div class="legend-bar"></div>
            <div class="legend-labels">
                <span class="label">80</span>
                <span class="label">60</span>
                <span class="label">40</span>
                <span class="label">20</span>
                <span class="label">0</span>
            </div>
        </div>
        <div class="legend-unit">mm/h</div>
    </div>

    <div class="time-display-panel">
        <div class="time-display">
            <div class="current-time">
                <div id="active-date" class="date-display">Loading...</div>
                <div id="active-time" class="time-display-large">--:--</div>
            </div>
        </div>
    </div>

    <div class="time-controls" id="time-controls">
        <button class="toggle-btn-dark" id="controls-toggle" title="Toggle Controls">
            <span id="controls-toggle-icon">−</span>
        </button>
        <span class="controls-title">時刻</span>

        <div class="playback-controls">
            <button id="prev-frame" class="control-btn" title="Previous">
                <span>◀</span>
            </button>
            <button id="play-pause" class="control-btn play-btn" title="Play/Pause">
                <span id="play-icon">▶</span>
            </button>
            <button id="next-frame" class="control-btn" title="Next">
                <span>▶</span>
            </button>
        </div>

        <div class="timeline-container">
            <input type="range" min="0" step="1" value="0" max="0" class="timeline-slider" id="slider" />
            <div class="timeline-ticks" id="timeline-ticks"></div>
        </div>
    </div>

    <script>
        // Initial location (Tokyo Station)
lat = 35.681236;
lng = 139.767125;

// Define precipitation tilesets
const tilesets = {
    nowcast: {
        //value: 'mapbox://mapbox.weather-jp-nowcast',
        //value: 'mapbox://kenji-shima.nowcast-r-20240620195000',
        value: 'mapbox://mapbox.weather-jp-nowcast-sample',
        label: 'Current Precipitation',
        colorscale: 'Rain'
    },
    nowcast_last60min: {
        //value: 'mapbox://mapbox.weather-jp-nowcast-last-60m',
        //value: 'mapbox://mapbox.weather-jp-nowcast-last-60m',
        value: 'mapbox://mapbox.weather-jp-nowcast-last-60m-samp',
        label: 'Past 60 Minutes',
        colorscale: 'Rain'
    },
    rain_6: {
        //value: 'mapbox://mapbox.weather-jp-rain-1-6',
        //value: 'mapbox://kenji-shima.forecast-20240620203000-6h',
        value: 'mapbox://mapbox.weather-jp-rain-1-6-sample',
        label: '1-6 Hour Forecast',
        colorscale: 'Rain'
    },
    rain_15: {
        //value: 'mapbox://mapbox.weather-jp-rain-7-15',
        // value: 'mapbox://kenji-shima.forecast-20240620200000-15h',
        value: 'mapbox://mapbox.weather-jp-rain-7-15-sample',
        label: '7-15 Hour Forecast',
        colorscale: 'Rain'
    }
};

// Global state
let map;
let unifiedBands = [];
let currentBandIndex = 0;
let nowBandIndex = 0; // Band index closest to current time
let allTilesetData = {};
let isPlaying = false;
let playInterval = null;
let userLocationMarker = null;
let userCoordinates = null;
let suggestionMarkers = [];
let selectedMarker = null;
let sessionToken = null;
let routeLayers = []; // Track route layer IDs for cleanup
let originalBounds = null; // Store original bounds showing all results
let clickedMarkerId = null; // Track which marker is currently clicked/highlighted

// Generate UUIDv4 for session token
function generateSessionToken() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Clear all suggestion markers from the map
function clearSuggestionMarkers() {
    suggestionMarkers.forEach(marker => marker.remove());
    suggestionMarkers = [];

    // Also clear selected marker if any
    if (selectedMarker) {
        selectedMarker.remove();
        selectedMarker = null;
    }

    // Clear clicked marker tracking
    clickedMarkerId = null;

    // Clear all routes
    clearRoutes();

    // Reset original bounds so new search results get fresh bounds
    originalBounds = null;
}

// Highlight marker and route for a specific suggestion
function highlightMarkerForSuggestion(mapboxId) {
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === mapboxId);
    if (marker) {
        const markerElement = marker.getElement();
        markerElement.classList.add('highlighted');

        // Bring marker to front by re-appending it to the DOM
        // This makes it appear on top of all other markers
        if (markerElement.parentNode) {
            markerElement.parentNode.appendChild(markerElement);
        }

        // Change marker color to red (only the colored marker paths, not shadow or white center)
        const svg = markerElement.querySelector('svg');
        if (svg) {
            // Change only path elements that have the orange color
            const paths = svg.querySelectorAll('path[fill="#FF9800"]');
            paths.forEach(path => {
                path.style.fill = '#FF0000';  // Red
                path.setAttribute('fill', '#FF0000');  // Red
            });
        }

        // Zoom to route (user location + marker location)
        if (userCoordinates) {
            const markerLngLat = marker.getLngLat();
            const bounds = [
                [
                    Math.min(userCoordinates.lng, markerLngLat.lng),
                    Math.min(userCoordinates.lat, markerLngLat.lat)
                ],
                [
                    Math.max(userCoordinates.lng, markerLngLat.lng),
                    Math.max(userCoordinates.lat, markerLngLat.lat)
                ]
            ];

            // Use dynamic padding
            const padding = calculateDynamicPadding();
            map.fitBounds(bounds, {
                padding: padding,
                duration: 800,
                maxZoom: 14
            });
        }
    }
    // Also highlight the route
    highlightRoute(mapboxId);
}

// Remove highlight from marker and route
function unhighlightMarkerForSuggestion(mapboxId) {
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === mapboxId);
    if (marker) {
        const markerElement = marker.getElement();
        markerElement.classList.remove('highlighted');

        // Change marker color back to orange (only the colored marker paths)
        const svg = markerElement.querySelector('svg');
        if (svg) {
            // Change path elements that are currently red back to orange
            const paths = svg.querySelectorAll('path[fill="#FF0000"]');
            paths.forEach(path => {
                path.style.fill = '#FF9800';  // Orange
                path.setAttribute('fill', '#FF9800');  // Orange
            });
        }

        // Restore original bounds (showing all results)
        if (originalBounds) {
            // Use dynamic padding
            const padding = calculateDynamicPadding();
            map.fitBounds(originalBounds, {
                padding: padding,
                duration: 800
            });
        }
    }
    // Also unhighlight the route
    unhighlightRoute(mapboxId);
}

// Decode polyline string to GeoJSON coordinates
function decodePolyline(str, precision = 5) {
    let index = 0;
    let lat = 0;
    let lng = 0;
    const coordinates = [];
    let shift = 0;
    let result = 0;
    let byte = null;
    let latitude_change;
    let longitude_change;
    const factor = Math.pow(10, precision);

    while (index < str.length) {
        byte = null;
        shift = 0;
        result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
        shift = result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lng / factor, lat / factor]);
    }

    return coordinates;
}

// Fetch route from Directions API
async function getDirections(fromLng, fromLat, toLng, toLat) {
    try {
        const url = `https://api.mapbox.com/directions/v5/mapbox.tmp.valhalla-zenrin/driving/${fromLng},${fromLat};${toLng},${toLat}?geometries=polyline&overview=full&access_token=${mapboxgl.accessToken}`;

        const response = await fetch(url);
        const data = await response.json();

        if (data.routes && data.routes.length > 0) {
            // Decode polyline to GeoJSON LineString coordinates
            const coordinates = decodePolyline(data.routes[0].geometry);

            return {
                geometry: {
                    type: 'LineString',
                    coordinates: coordinates
                },
                duration: data.routes[0].duration // Duration in seconds
            };
        }
        return null;
    } catch (error) {
        console.error('Error fetching directions:', error);
        return null;
    }
}

// Format duration from seconds to readable format
function formatDuration(seconds) {
    if (seconds === null || seconds === undefined) {
        return 'N/A';
    }
    const minutes = Math.round(seconds / 60);
    if (minutes < 60) {
        return `${minutes}分`;
    }
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    if (remainingMinutes === 0) {
        return `${hours}時間`;
    }
    return `${hours}時間${remainingMinutes}分`;
}

// Calculate arrival time in JST from duration, based on first nowcast band timestamp
function formatArrivalTime(seconds) {
    if (seconds === null || seconds === undefined) {
        return 'N/A';
    }

    // Get the timestamp of the first nowcast band
    const firstNowcastBand = unifiedBands[nowBandIndex];

    if (!firstNowcastBand || !firstNowcastBand.band) {
        return 'N/A';
    }

    // Band is Unix timestamp in seconds, convert to milliseconds
    const startTime = new Date(firstNowcastBand.band * 1000);
    const arrivalTime = new Date(startTime.getTime() + seconds * 1000);

    // Format in JST
    const formatter = new Intl.DateTimeFormat('ja-JP', {
        timeZone: 'Asia/Tokyo',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    });

    const arrivalTimeStr = formatter.format(arrivalTime);
    const durationStr = formatDuration(seconds);
    const formatted = `${arrivalTimeStr} (${durationStr})`;

    return formatted;
}

// Draw route on map
function drawRoute(routeGeometry, mapboxId) {
    if (!routeGeometry) return;

    const sourceId = `route-${mapboxId}`;
    const layerId = `route-layer-${mapboxId}`;

    // Add source
    if (!map.getSource(sourceId)) {
        map.addSource(sourceId, {
            type: 'geojson',
            data: {
                type: 'Feature',
                geometry: routeGeometry
            }
        });
    }

    // Add layer
    if (!map.getLayer(layerId)) {
        map.addLayer({
            id: layerId,
            type: 'line',
            source: sourceId,
            paint: {
                'line-color': '#FF9800',  // Orange
                'line-width': 3,
                'line-opacity': 0.7
            }
        });

        // Track for cleanup
        routeLayers.push({ sourceId, layerId });
    }
}

// Clear all routes from map
function clearRoutes() {
    routeLayers.forEach(({ sourceId, layerId }) => {
        if (map.getLayer(layerId)) {
            map.removeLayer(layerId);
        }
        if (map.getSource(sourceId)) {
            map.removeSource(sourceId);
        }
    });
    routeLayers = [];
}

// Highlight route by changing color to red
function highlightRoute(mapboxId) {
    const layerId = `route-layer-${mapboxId}`;
    if (map.getLayer(layerId)) {
        map.setPaintProperty(layerId, 'line-color', '#FF0000');  // Red
        map.setPaintProperty(layerId, 'line-width', 4);
    }

    // Set opacity of all other routes to 0.2
    routeLayers.forEach(route => {
        if (route.layerId !== layerId && map.getLayer(route.layerId)) {
            map.setPaintProperty(route.layerId, 'line-opacity', 0.2);
        }
    });
}

// Unhighlight route by changing color back to orange
function unhighlightRoute(mapboxId) {
    const layerId = `route-layer-${mapboxId}`;
    if (map.getLayer(layerId)) {
        map.setPaintProperty(layerId, 'line-color', '#FF9800');  // Orange
        map.setPaintProperty(layerId, 'line-width', 3);
    }

    // Restore opacity of all routes to 1
    routeLayers.forEach(route => {
        if (map.getLayer(route.layerId)) {
            map.setPaintProperty(route.layerId, 'line-opacity', 1);
        }
    });
}

// Create color scale for precipitation
function createRainColorScale() {
    const domain = [0.05, 0.99, 4.99, 9.99, 19.99, 29.99, 49.99, 79.99];

    const range = [
        "rgba(242, 242, 255, 0.9)",
        "rgba(160, 210, 255, 0.9)",
        "rgba(33, 140, 255, 0.9)",
        "rgba(0, 65, 255, 0.9)",
        "rgba(250, 245, 0, 0.9)",
        "rgba(255, 153, 0, 0.9)",
        "rgba(255, 40, 0, 0.9)",
        "rgba(180, 0, 104, 0.9)"
    ];

    return ['step', ['raster-value'], 'rgba(0, 0, 0, 0)', ...domain.flatMap((d, i) => [d, range[i]])];
}

// Convert band timestamp to JST date/time
function formatBandTime(band) {
    // Validate input
    if (band === undefined || band === null || isNaN(band)) {
        console.error('Invalid band value:', band);
        return { date: 'Invalid', time: '--:--' };
    }

    // Band is a Unix timestamp in seconds
    const utcDate = new Date(band * 1000);

    // Check if date is valid
    if (isNaN(utcDate.getTime())) {
        console.error('Invalid date calculated from band:', band);
        return { date: 'Invalid', time: '--:--' };
    }

    try {
        // Convert to JST by creating a date string with timezone
        const formatter = new Intl.DateTimeFormat('ja-JP', {
            timeZone: 'Asia/Tokyo',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
        });

        const parts = formatter.formatToParts(utcDate);
        const year = parts.find(p => p.type === 'year').value;
        const month = parts.find(p => p.type === 'month').value;
        const day = parts.find(p => p.type === 'day').value;
        const hour = parts.find(p => p.type === 'hour').value;
        const minute = parts.find(p => p.type === 'minute').value;

        return {
            date: `${year}/${month}/${day}`,
            time: `${hour}:${minute}`
        };
    } catch (error) {
        console.error('Error formatting date:', error);
        return { date: 'Error', time: '--:--' };
    }
}

// Load all precipitation tilesets
async function loadAllTilesets() {
    console.log('Loading all tilesets...');

    const promises = Object.entries(tilesets).map(async ([id, config]) => {
        const tilesetId = config.value.split('/').pop();
        const tilejsonUrl = `https://api.mapbox.com/v4/${tilesetId}.json?access_token=${mapboxgl.accessToken}`;

        try {
            const response = await fetch(tilejsonUrl);
            const tilejson = await response.json();
            allTilesetData[id] = tilejson;
            return { id, tilejson };
        } catch (error) {
            console.error(`Error loading ${id}:`, error);
            return null;
        }
    });

    const results = await Promise.all(promises);

    // Build unified band list
    unifiedBands = [];
    let globalIndex = 0;

    results.forEach(result => {
        if (!result || !result.tilejson) return;

        const { id, tilejson } = result;
        const layer = tilejson.raster_layers?.[0];

        if (layer && layer.fields.bands) {
            layer.fields.bands.forEach((band, bandIndex) => {
                unifiedBands.push({
                    tilesetId: id,
                    band: band,
                    timestamp: band,
                    localIndex: bandIndex,
                    globalIndex: globalIndex++,
                    layer: layer.fields.name,
                    colorRange: layer.fields.range
                });
            });
        }
    });

    // Sort by timestamp
    unifiedBands.sort((a, b) => a.timestamp - b.timestamp);

    // Re-index after sorting
    unifiedBands.forEach((item, idx) => {
        item.globalIndex = idx;
    });

    console.log(`Loaded ${unifiedBands.length} bands total`);

    // Find the first band of the 'nowcast' tileset
    let foundNowBandIndex = 0;
    for (let idx = 0; idx < unifiedBands.length; idx++) {
        if (unifiedBands[idx].tilesetId === 'nowcast') {
            foundNowBandIndex = idx;
            break; // Take the first nowcast band
        }
    }

    nowBandIndex = foundNowBandIndex; // Set global nowBandIndex
    currentBandIndex = nowBandIndex; // Start at first nowcast band

    return unifiedBands[0]; // Return first band info
}

// Update time display
function updateTimeDisplay(index) {
    const band = unifiedBands[index];
    if (!band) return;

    const { date, time } = formatBandTime(band.band);

    // Determine if this is past, current, or forecast
    let suffix = '';
    if (index === nowBandIndex) {
        suffix = ' （現在）';
    } else if (index > nowBandIndex) {
        suffix = ' （予報）';
    }
    // Past times have no suffix

    document.getElementById('active-date').textContent = date;
    document.getElementById('active-time').textContent = time + suffix;
}

// Track current active layer
let currentActiveLayer = null;

// Initialize all precipitation layers upfront
function initializePrecipitationLayers() {
    // Create a layer for each tileset
    Object.entries(tilesets).forEach(([tilesetId, config]) => {
        const sourceId = `precipitation-source-${tilesetId}`;
        const layerId = `precipitation-layer-${tilesetId}`;

        // Add source
        map.addSource(sourceId, {
            type: 'raster-array',
            url: config.value
        });

        // Get layer info from first band of this tileset
        const firstBandOfTileset = unifiedBands.find(b => b.tilesetId === tilesetId);
        if (!firstBandOfTileset) return;

        // Add layer with initial opacity 0
        map.addLayer({
            id: layerId,
            type: 'raster',
            source: sourceId,
            'source-layer': firstBandOfTileset.layer,
            paint: {
                'raster-color-range': firstBandOfTileset.colorRange,
                'raster-color': createRainColorScale(),
                'raster-resampling': 'nearest',
                'raster-color-range-transition': { duration: 0 },
                'raster-opacity': 0, // Start invisible
                'raster-array-band': firstBandOfTileset.band,
                'raster-emissive-strength': 1.0,
                'raster-fade-duration': 0
            }
            //}, 'road-label');
        }, 'airport-label');
    });

    console.log('Initialized all precipitation layers');
}

// Change to a specific band
function changeBand(index) {
    if (!unifiedBands.length) return;

    currentBandIndex = parseInt(index);
    const bandInfo = unifiedBands[currentBandIndex];

    // Validate bandInfo
    if (!bandInfo) {
        console.error('Invalid band index:', index);
        return;
    }

    // Validate tilesetId
    if (!tilesets[bandInfo.tilesetId]) {
        console.error('Invalid tilesetId:', bandInfo.tilesetId, 'Available:', Object.keys(tilesets));
        return;
    }

    updateTimeDisplay(currentBandIndex);

    const targetLayerId = `precipitation-layer-${bandInfo.tilesetId}`;

    // If switching to a different tileset layer
    if (currentActiveLayer && currentActiveLayer !== targetLayerId) {
        // Hide the old layer
        map.setPaintProperty(currentActiveLayer, 'raster-opacity', 0);
    }

    // Show the target layer and set its band
    map.setPaintProperty(targetLayerId, 'raster-opacity', 0.8);
    map.setPaintProperty(targetLayerId, 'raster-array-band', bandInfo.band);

    currentActiveLayer = targetLayerId;
}

// Playback controls
function previousFrame() {
    if (currentBandIndex > 0) {
        document.getElementById('slider').value = currentBandIndex - 1;
        changeBand(currentBandIndex - 1);
    }
}

function nextFrame() {
    if (currentBandIndex < unifiedBands.length - 1) {
        document.getElementById('slider').value = currentBandIndex + 1;
        changeBand(currentBandIndex + 1);
    }
}

function togglePlay() {
    const playBtn = document.getElementById('play-pause');
    const playIcon = document.getElementById('play-icon');

    if (isPlaying) {
        isPlaying = false;
        playBtn.classList.remove('playing');
        playIcon.textContent = '▶';
        if (playInterval) {
            clearInterval(playInterval);
            playInterval = null;
        }
    } else {
        isPlaying = true;
        playBtn.classList.add('playing');
        playIcon.textContent = '⏸';
        playInterval = setInterval(() => {
            if (currentBandIndex < unifiedBands.length - 1) {
                nextFrame();
            } else {
                currentBandIndex = -1;
                nextFrame();
            }
        }, 1000);
    }
}

// Calculate zone boundaries
function calculateZoneBoundaries() {
    // Find the last nowcast band index (nowcast and nowcast_last60min)
    let lastNowcastIndex = -1;
    for (let i = unifiedBands.length - 1; i >= 0; i--) {
        const tilesetId = unifiedBands[i].tilesetId;
        if (tilesetId === 'nowcast' || tilesetId === 'nowcast_last60min') {
            lastNowcastIndex = i;
            break;
        }
    }

    const totalBands = unifiedBands.length;
    const nowcastPercent = lastNowcastIndex >= 0 ? ((lastNowcastIndex + 1) / totalBands) * 100 : 0;
    const forecastPercent = 100 - nowcastPercent;

    return {
        nowcastEnd: lastNowcastIndex,
        nowcastPercent,
        forecastPercent
    };
}

// Generate zone backgrounds and labels
function generateZoneBackgrounds() {
    const container = document.querySelector('.timeline-container');
    if (!container || !unifiedBands.length) return;

    // Remove existing zones
    const existingZones = container.querySelector('.timeline-zones');
    if (existingZones) existingZones.remove();

    const existingBoundary = container.querySelector('.zone-boundary');
    if (existingBoundary) existingBoundary.remove();

    const existingLabels = container.querySelectorAll('.zone-label');
    existingLabels.forEach(label => label.remove());

    const zones = calculateZoneBoundaries();
    const slider = document.getElementById('slider');
    const sliderRect = slider.getBoundingClientRect();
    const thumbWidth = window.innerWidth <= 768 ? 24 : 20;
    const trackWidth = sliderRect.width;
    const offsetPercent = (thumbWidth / 2 / trackWidth) * 100;

    // Create zones container
    const zonesDiv = document.createElement('div');
    zonesDiv.className = 'timeline-zones';

    // Nowcast zone
    const nowcastZone = document.createElement('div');
    nowcastZone.className = 'timeline-zone nowcast';
    nowcastZone.style.width = zones.nowcastPercent + '%';
    zonesDiv.appendChild(nowcastZone);

    // Forecast zone
    const forecastZone = document.createElement('div');
    forecastZone.className = 'timeline-zone forecast';
    forecastZone.style.width = zones.forecastPercent + '%';
    zonesDiv.appendChild(forecastZone);

    container.insertBefore(zonesDiv, slider);

    // Add boundary line at transition
    if (zones.nowcastEnd >= 0 && zones.nowcastEnd < unifiedBands.length - 1) {
        const boundaryIndex = zones.nowcastEnd + 0.5; // Between nowcast and forecast
        const rawPosition = (boundaryIndex / (unifiedBands.length - 1)) * 100;
        const position = offsetPercent + (rawPosition * (100 - 2 * offsetPercent) / 100);

        const boundary = document.createElement('div');
        boundary.className = 'zone-boundary';
        boundary.style.left = position + '%';
        container.appendChild(boundary);
    }

    // Add zone labels
    if (zones.nowcastPercent > 5) {
        const nowcastCenter = zones.nowcastPercent / 2;
        const nowcastLabel = document.createElement('div');
        nowcastLabel.className = 'zone-label';
        nowcastLabel.textContent = '5分間隔';
        nowcastLabel.style.left = nowcastCenter + '%';
        container.appendChild(nowcastLabel);
    }

    if (zones.forecastPercent > 5) {
        const forecastCenter = zones.nowcastPercent + (zones.forecastPercent / 2);
        const forecastLabel = document.createElement('div');
        forecastLabel.className = 'zone-label';
        forecastLabel.textContent = '1時間間隔';
        forecastLabel.style.left = forecastCenter + '%';
        container.appendChild(forecastLabel);
    }
}

// Generate timeline tick marks and labels
function generateTimelineTicks() {
    const ticksContainer = document.getElementById('timeline-ticks');
    const slider = document.getElementById('slider');
    if (!ticksContainer || !slider || !unifiedBands.length) return;

    ticksContainer.innerHTML = '';
    const totalBands = unifiedBands.length;
    const zones = calculateZoneBoundaries();

    // Get slider dimensions to account for thumb offset
    const sliderRect = slider.getBoundingClientRect();
    // Detect thumb width based on screen size (mobile has larger thumbs)
    const thumbWidth = window.innerWidth <= 768 ? 24 : 20;
    const trackWidth = sliderRect.width;
    const offsetPercent = (thumbWidth / 2 / trackWidth) * 100;

    // Determine tick interval (show tick every N bands)
    const minorTickInterval = Math.max(1, Math.floor(totalBands / 40)); // ~40 minor ticks
    const majorTickInterval = Math.max(5, Math.floor(totalBands / 8));  // ~8 major ticks with labels

    for (let i = 0; i < totalBands; i++) {
        const isMajor = i % majorTickInterval === 0 || i === totalBands - 1;
        const isMinor = i % minorTickInterval === 0;

        if (!isMajor && !isMinor) continue;

        // Calculate position accounting for thumb offset
        const rawPosition = (i / (totalBands - 1)) * 100;
        const position = offsetPercent + (rawPosition * (100 - 2 * offsetPercent) / 100);

        // Determine zone class
        const isNowcast = i <= zones.nowcastEnd;
        const zoneClass = isNowcast ? 'nowcast-zone' : 'forecast-zone';

        // Create tick mark
        const tick = document.createElement('div');
        tick.className = isMajor ? `timeline-tick major ${zoneClass}` : `timeline-tick ${zoneClass}`;
        tick.style.left = position + '%';
        tick.dataset.bandIndex = i;
        ticksContainer.appendChild(tick);

        // Add label for major ticks
        if (isMajor) {
            const band = unifiedBands[i];
            const { time } = formatBandTime(band.band);

            const label = document.createElement('div');
            label.className = 'timeline-label';
            label.textContent = time;
            label.style.left = position + '%';
            label.dataset.bandIndex = i;
            ticksContainer.appendChild(label);
        }
    }

    console.log(`Generated ticks with offset: ${offsetPercent.toFixed(2)}%, track width: ${trackWidth}px`);
}

// Initialize map
async function initMap() {
    map = new mapboxgl.Map({
        container: 'map',
        //style: 'mapbox://styles/kenji-shima/cmfurpm8w00j101r86qp530c8',
        //style: 'mapbox://styles/kenji-shima/clnxv0r9k003b01rff933dq05',
        style: 'mapbox://styles/mapbox/light-v11',
        center: [lng, lat],
        zoom: 4,
        projection: 'mercator',
        language: 'ja',
        maxTileCacheSize: 12
    });

    map.on('load', async () => {
        console.log('Map loaded');

        // Load all tilesets
        await loadAllTilesets();

        // Initialize all precipitation layers
        initializePrecipitationLayers();

        // Set up slider
        const slider = document.getElementById('slider');
        slider.max = unifiedBands.length - 1;
        slider.value = currentBandIndex;

        // Generate zone backgrounds
        generateZoneBackgrounds();

        // Generate timeline ticks
        generateTimelineTicks();

        // Initialize display (show current band)
        changeBand(currentBandIndex);

        // Initialize user location
        initUserLocation();

        // Initialize search functionality
        initSearch();

        // Set up event listeners
        slider.addEventListener('input', (e) => changeBand(e.target.value));
        document.getElementById('prev-frame').addEventListener('click', previousFrame);
        document.getElementById('next-frame').addEventListener('click', nextFrame);
        document.getElementById('play-pause').addEventListener('click', togglePlay);

        // Legend toggle
        document.getElementById('legend-toggle').addEventListener('click', () => {
            const legend = document.getElementById('legend');
            const icon = document.getElementById('legend-toggle-icon');
            legend.classList.toggle('collapsed');
            icon.textContent = legend.classList.contains('collapsed') ? '+' : '−';
        });

        // Controls toggle
        document.getElementById('controls-toggle').addEventListener('click', () => {
            const controls = document.getElementById('time-controls');
            const icon = document.getElementById('controls-toggle-icon');
            controls.classList.toggle('collapsed');
            icon.textContent = controls.classList.contains('collapsed') ? '+' : '−';
        });

        console.log('Initialization complete');
    });

    map.on('click', async (e) => {
        const lng = e.lngLat.lng;
        const lat = e.lngLat.lat;
        console.log(`Map clicked at: ${lng}, ${lat}`);
    });
}

// Debounce function for resize events
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Get user's current location
function getUserLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error('Geolocation is not supported by your browser'));
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const coords = {
                    lng: position.coords.longitude,
                    lat: position.coords.latitude
                };
                resolve(coords);
            },
            (error) => {
                console.error('Error getting user location:', error);
                reject(error);
            },
            {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
            }
        );
    });
}

// Add user location marker to map
function addUserLocationMarker(coordinates) {
    // Remove existing marker if any
    if (userLocationMarker) {
        userLocationMarker.remove();
    }

    // Create marker element
    const el = document.createElement('div');
    el.className = 'user-location-marker';
    el.title = 'Your Location';

    // Create and add marker
    userLocationMarker = new mapboxgl.Marker({
        element: el,
        anchor: 'center'
    })
        .setLngLat([coordinates.lng, coordinates.lat])
        .addTo(map);

    // Store coordinates
    userCoordinates = coordinates;

    console.log('User location marker added at:', coordinates);
}

// Initialize user location
async function initUserLocation() {
    // Start with default location (Tokyo Station)
    const defaultCoords = {
        lng: 139.767125,
        lat: 35.681236
    };

    console.log('Setting default location (Tokyo Station):', defaultCoords);

    // Set default coordinates immediately
    userCoordinates = defaultCoords;
    addUserLocationMarker(defaultCoords);

    // Fly to default location
    map.flyTo({
        center: [defaultCoords.lng, defaultCoords.lat],
        zoom: 8,
        duration: 2000
    });

    // Try to get actual user location in the background
    try {
        console.log('Requesting user location...');
        const coords = await getUserLocation();
        console.log('User location obtained:', coords);

        // Update to real location
        userCoordinates = coords;

        // Update marker position
        if (userLocationMarker) {
            userLocationMarker.setLngLat([coords.lng, coords.lat]);
        } else {
            addUserLocationMarker(coords);
        }

        // Smoothly transition to real location
        map.flyTo({
            center: [coords.lng, coords.lat],
            zoom: 8,
            duration: 2000
        });

        console.log('Updated to actual user location');
    } catch (error) {
        console.log('Could not get user location, using default (Tokyo Station):', error.message);
        // Keep using default location (already set above)
    }
}

// Get precipitation value at a specific coordinate using queryRasterValue
async function getPrecipitationAtLocation(lng, lat, bandIndex = null) {
    try {
        // Use provided bandIndex or default to current active band
        const targetBandIndex = bandIndex !== null ? bandIndex : currentBandIndex;
        const bandInfo = unifiedBands[targetBandIndex];
        if (!bandInfo) {
            return null;
        }

        const sourceId = `precipitation-source-${bandInfo.tilesetId}`;
        const sourceLayer = bandInfo.layer;

        // Query raster value at the coordinate - await the Promise
        const result = await map.queryRasterValue(sourceId, { lon: lng, lat: lat }, {
            bands: [bandInfo.band]
        });

        // Parse nested structure: { "precipitation": { "1718913000": [30] } }
        if (result && typeof result === 'object') {
            // Get the layer name (e.g., "precipitation")
            const layerData = result[sourceLayer];

            if (layerData && typeof layerData === 'object') {
                // Get the band data (keyed by band timestamp)
                const bandData = layerData[bandInfo.band];

                if (Array.isArray(bandData) && bandData.length > 0) {
                    const value = bandData[0];
                    return value;
                }
            }
        }
        return null;
    } catch (error) {
        console.error('Error querying raster value:', error);
        return null;
    }
}

// Find the band index closest to a given timestamp
function findBandIndexForTimestamp(targetTimestamp) {
    if (unifiedBands.length === 0) {
        return null;
    }

    let closestIndex = 0;
    let minDiff = Math.abs(unifiedBands[0].band - targetTimestamp);

    for (let i = 1; i < unifiedBands.length; i++) {
        const diff = Math.abs(unifiedBands[i].band - targetTimestamp);
        if (diff < minDiff) {
            minDiff = diff;
            closestIndex = i;
        }
    }

    return closestIndex;
}

// Format precipitation value for display
function formatPrecipitation(value) {
    if (value === null || value === undefined || isNaN(value)) {
        return '降水なし';
    }
    if (value < 0.5) {
        return '降水なし';
    }
    return `${value.toFixed(1)} mm/h`;
}

// Initialize search functionality
function initSearch() {
    try {
        const searchInput = document.getElementById('search-box');
        const searchResults = document.getElementById('search-results');
        const clearBtn = document.getElementById('clear-search');

        // Generate initial session token
        sessionToken = generateSessionToken();
        console.log('Search session token:', sessionToken);

        // Debounce search input
        let searchTimeout;

        searchInput.addEventListener('input', async (e) => {
            const query = e.target.value.trim();

            // Show/hide clear button based on input
            clearBtn.style.display = e.target.value ? 'flex' : 'none';

            // Clear previous timeout
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            // Hide results if query is empty
            if (query === '') {
                searchResults.classList.remove('visible');
                searchResults.innerHTML = '';
                clearSuggestionMarkers();
                return;
            }

            // Debounce search
            searchTimeout = setTimeout(async () => {
                await performSearch(query);
            }, 300);
        });

        // Clear button handler
        clearBtn.addEventListener('click', () => {
            searchInput.value = '';
            clearBtn.style.display = 'none';
            searchResults.classList.remove('visible');
            searchResults.innerHTML = '';
            clearSuggestionMarkers();
            searchInput.focus();
        });

        // Note: Results will stay visible until user types again or selects a result
        // This allows users to click on the map or interact with markers without losing results

        console.log('Search initialized successfully');
    } catch (error) {
        console.error('Error initializing search:', error);
    }
}

// Fit map to show all suggestion markers
function fitMapToBounds(coordinates) {
    if (coordinates.length === 0) return;

    // Calculate bounding box
    const lngs = coordinates.map(c => c.lng);
    const lats = coordinates.map(c => c.lat);

    const minLng = Math.min(...lngs);
    const maxLng = Math.max(...lngs);
    const minLat = Math.min(...lats);
    const maxLat = Math.max(...lats);

    // Create bounds
    const bounds = [
        [minLng, minLat], // Southwest
        [maxLng, maxLat]  // Northeast
    ];

    // Include user location in bounds if available
    if (userCoordinates) {
        bounds[0][0] = Math.min(bounds[0][0], userCoordinates.lng);
        bounds[0][1] = Math.min(bounds[0][1], userCoordinates.lat);
        bounds[1][0] = Math.max(bounds[1][0], userCoordinates.lng);
        bounds[1][1] = Math.max(bounds[1][1], userCoordinates.lat);
    }

    // Calculate dynamic padding based on UI element dimensions
    const padding = calculateDynamicPadding();

    // Fit map to bounds with dynamic padding
    map.fitBounds(bounds, {
        padding: padding,
        duration: 1000,
        maxZoom: 12
    });

    // Save these bounds as the original bounds to restore on unhighlight
    originalBounds = bounds;
}

// Calculate dynamic padding based on UI element dimensions
function calculateDynamicPadding() {
    const padding = {
        top: 20,
        bottom: 20,
        left: 20,
        right: 20
    };

    // Add padding for date/time display at top
    const dateTimeDisplay = document.querySelector('.date-time-display');
    if (dateTimeDisplay) {
        const rect = dateTimeDisplay.getBoundingClientRect();
        padding.top = Math.max(padding.top, rect.bottom + 20); // 20px extra margin
    }

    // Add padding for timeline controls at bottom
    const timeControls = document.getElementById('time-controls');
    if (timeControls && !timeControls.classList.contains('collapsed')) {
        const rect = timeControls.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        padding.bottom = Math.max(padding.bottom, viewportHeight - rect.top + 20);
    }

    // Add padding for legend on left
    const legend = document.getElementById('legend');
    if (legend && !legend.classList.contains('collapsed')) {
        const rect = legend.getBoundingClientRect();
        padding.left = Math.max(padding.left, rect.width + 40); // 40px extra margin (20px on each side)
    }

    // Add padding for search box on right
    const searchContainer = document.querySelector('.search-container');
    if (searchContainer) {
        const rect = searchContainer.getBoundingClientRect();
        // Include search box width + search results dropdown if visible
        const searchResults = document.getElementById('search-results');
        const resultsVisible = searchResults && searchResults.classList.contains('visible');

        if (resultsVisible) {
            const resultsRect = searchResults.getBoundingClientRect();
            padding.right = Math.max(padding.right, window.innerWidth - resultsRect.left + 20);
        } else {
            padding.right = Math.max(padding.right, window.innerWidth - rect.left + 20);
        }
    }

    return padding;
}

// Perform search using SearchBox API /suggest endpoint
async function performSearch(query) {
    const searchResults = document.getElementById('search-results');

    try {
        // Clear previous suggestion markers
        clearSuggestionMarkers();

        // Build SearchBox API suggest URL
        const encodedQuery = encodeURIComponent(query);
        let url = `https://api.mapbox.com/search/searchbox/v1/suggest?q=${encodedQuery}&access_token=${mapboxgl.accessToken}&session_token=${sessionToken}&language=ja&country=JP&limit=10&types=poi`;

        // Add proximity - use user location if available, otherwise use map center
        const proximityCoords = userCoordinates || map.getCenter();
        url += `&proximity=${proximityCoords.lng},${proximityCoords.lat}`;
        console.log('Search URL:', url);

        const response = await fetch(url);
        const data = await response.json();

        if (!data.suggestions || data.suggestions.length === 0) {
            searchResults.innerHTML = '<div class="search-result-item">結果が見つかりませんでした</div>';
            searchResults.classList.add('visible');
            return;
        }

        // Display results
        searchResults.innerHTML = '';
        searchResults.classList.add('visible');

        // Collect coordinates for bounding box
        const coordinatesPromises = [];

        // Process each suggestion
        for (const suggestion of data.suggestions) {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';

            // Create result HTML structure
            const nameDiv = document.createElement('div');
            nameDiv.className = 'result-name';
            nameDiv.textContent = suggestion.name || 'Unknown';

            const addressDiv = document.createElement('div');
            addressDiv.className = 'result-address';
            addressDiv.textContent = suggestion.place_formatted || '';

            const currentPrecipDiv = document.createElement('div');
            currentPrecipDiv.className = 'result-precipitation';
            currentPrecipDiv.textContent = '現在降水量: 読み込み中...';

            // Container for arrival time and precipitation on same row
            const arrivalRowDiv = document.createElement('div');
            arrivalRowDiv.className = 'result-arrival-row';

            const etaDiv = document.createElement('span');
            etaDiv.className = 'result-eta';
            etaDiv.textContent = '到着時間: 計算中...';

            const arrivalPrecipDiv = document.createElement('span');
            arrivalPrecipDiv.className = 'result-precipitation';
            arrivalPrecipDiv.textContent = '予想降水量: 読み込み中...';

            arrivalRowDiv.appendChild(etaDiv);
            arrivalRowDiv.appendChild(arrivalPrecipDiv);

            resultItem.appendChild(nameDiv);
            resultItem.appendChild(addressDiv);
            resultItem.appendChild(currentPrecipDiv);
            resultItem.appendChild(arrivalRowDiv);

            // Store the suggestion data for retrieval
            resultItem.dataset.mapboxId = suggestion.mapbox_id;

            // Add click handler
            resultItem.addEventListener('click', async () => {
                await handleResultSelection(suggestion);
            });

            // Add hover handlers to highlight marker
            resultItem.addEventListener('mouseenter', () => {
                // If there's a clicked marker that's different, temporarily unhighlight it
                if (clickedMarkerId && clickedMarkerId !== suggestion.mapbox_id) {
                    unhighlightMarkerForSuggestion(clickedMarkerId);
                    const clickedResultItem = document.querySelector(`[data-mapbox-id="${clickedMarkerId}"]`);
                    if (clickedResultItem) {
                        clickedResultItem.classList.remove('marker-hovered');
                    }
                }

                // Highlight the hovered suggestion
                highlightMarkerForSuggestion(suggestion.mapbox_id);
            });

            resultItem.addEventListener('mouseleave', () => {
                // Unhighlight the hovered suggestion
                unhighlightMarkerForSuggestion(suggestion.mapbox_id);

                // Restore the clicked marker if there was one and it's different from what we just unhovered
                if (clickedMarkerId && clickedMarkerId !== suggestion.mapbox_id) {
                    highlightMarkerForSuggestion(clickedMarkerId);
                    const clickedResultItem = document.querySelector(`[data-mapbox-id="${clickedMarkerId}"]`);
                    if (clickedResultItem) {
                        clickedResultItem.classList.add('marker-hovered');
                    }
                }
            });

            searchResults.appendChild(resultItem);

            // Retrieve full details to get coordinates, add marker, and query precipitation
            const coordPromise = retrieveAndAddMarker(suggestion, currentPrecipDiv, etaDiv, arrivalPrecipDiv);
            coordinatesPromises.push(coordPromise);
        }

        // Wait for all coordinates to be retrieved, then fit bounds
        Promise.all(coordinatesPromises).then(coordinates => {
            const validCoords = coordinates.filter(coord => coord !== null);
            if (validCoords.length > 0) {
                fitMapToBounds(validCoords);
            }
        });
    } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div class="search-result-item">検索エラーが発生しました</div>';
        searchResults.classList.add('visible');
    }
}

// Create popup HTML for suggestions
function createSuggestionPopupHTML(suggestion, currentPrecipText, etaText, arrivalPrecipText) {
    return `
        <div style="
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 16px;
            min-width: 350px;
            background: #2c2c2c;
            border-radius: 4px;
            box-sizing: border-box;
        ">
            <div style="font-weight: 600; font-size: 16px; margin-bottom: 4px; color: #ffffff;">
                ${suggestion.name}
            </div>
            <div style="font-size: 12px; color: rgba(255,255,255,0.5); margin-bottom: 16px;">
                ${suggestion.place_formatted || ''}
            </div>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div style="
                    background: rgba(102, 187, 106, 0.15);
                    padding: 8px 12px;
                    border-radius: 6px;
                    border-left: 3px solid #66BB6A;
                ">
                    <span style="font-size: 11px; color: #81C784; font-weight: 500;">${currentPrecipText}</span>
                </div>
                <div style="display: flex; gap: 10px;">
                    <div style="
                        flex: 1;
                        background: rgba(66, 165, 245, 0.15);
                        padding: 8px 12px;
                        border-radius: 6px;
                        border-left: 3px solid #42A5F5;
                    ">
                        <span style="font-size: 11px; color: #64B5F6; font-weight: 500;">${etaText}</span>
                    </div>
                    <div style="
                        flex: 1;
                        background: rgba(102, 187, 106, 0.15);
                        padding: 8px 12px;
                        border-radius: 6px;
                        border-left: 3px solid #66BB6A;
                    ">
                        <span style="font-size: 11px; color: #81C784; font-weight: 500;">${arrivalPrecipText}</span>
                    </div>
                </div>
            </div>
        </div>
    `;
}

// Retrieve feature details, add marker, draw route, and query precipitation
async function retrieveAndAddMarker(suggestion, currentPrecipDiv, etaDiv, arrivalPrecipDiv) {
    try {
        const url = `https://api.mapbox.com/search/searchbox/v1/retrieve/${suggestion.mapbox_id}?access_token=${mapboxgl.accessToken}&session_token=${sessionToken}&language=ja`;

        const response = await fetch(url);
        const data = await response.json();

        if (data.features && data.features.length > 0) {
            const feature = data.features[0];
            const [lng, lat] = feature.geometry.coordinates;

            // Add marker for this suggestion (popup will be set later with full data)
            const marker = new mapboxgl.Marker({ color: '#FF9800' })  // Orange
                .setLngLat([lng, lat])
                .addTo(map);

            // Store marker reference with suggestion data
            marker.suggestionData = suggestion;
            suggestionMarkers.push(marker);

            // Add click handler to marker element - same as selecting from list
            const markerElement = marker.getElement();
            markerElement.style.cursor = 'pointer';
            markerElement.addEventListener('click', async (e) => {
                e.stopPropagation(); // Prevent map click from triggering

                // Call the same function as when selecting from the list
                await handleResultSelection(suggestion);
            });

            // Add hover handlers to show/hide popup
            markerElement.addEventListener('mouseenter', () => {
                marker.togglePopup(); // Open popup on hover
            });
            markerElement.addEventListener('mouseleave', () => {
                marker.togglePopup(); // Close popup on mouse leave
            });

            // Draw route from user location to this suggestion and get route data
            let routeData = null;
            if (userCoordinates) {
                routeData = await getDirections(
                    userCoordinates.lng,
                    userCoordinates.lat,
                    lng,
                    lat
                );
                if (routeData) {
                    drawRoute(routeData.geometry, suggestion.mapbox_id);
                    etaDiv.textContent = `到着時間: ${formatArrivalTime(routeData.duration)}`;
                } else {
                    etaDiv.textContent = '到着時間: N/A';
                }
            } else {
                etaDiv.textContent = '到着時間: N/A';
            }

            // Query current precipitation value
            const currentValue = await getPrecipitationAtLocation(lng, lat, nowBandIndex);
            currentPrecipDiv.textContent = `現在降水量: ${formatPrecipitation(currentValue)}`;

            // Query arrival precipitation value
            if (routeData && routeData.duration) {
                // Calculate arrival timestamp
                const firstNowcastBand = unifiedBands[nowBandIndex];
                const arrivalTimestamp = Number(firstNowcastBand.band) + Number(routeData.duration);

                // Format the target arrival time for logging
                const targetArrivalTime = formatBandTime(arrivalTimestamp);

                console.log('=== Arrival Calculation ===');
                console.log('Current band timestamp:', firstNowcastBand.band);
                console.log('Current band JST:', formatBandTime(firstNowcastBand.band).time);
                console.log('Travel duration (seconds):', routeData.duration);
                console.log('Calculated arrival timestamp:', arrivalTimestamp);
                console.log('Target arrival JST:', targetArrivalTime.time, targetArrivalTime.date);

                // Find the band closest to arrival time
                const arrivalBandIndex = findBandIndexForTimestamp(arrivalTimestamp);

                if (arrivalBandIndex !== null) {
                    const arrivalBand = unifiedBands[arrivalBandIndex];
                    const arrivalBandTime = formatBandTime(arrivalBand.band);

                    console.log('--- Selected Band ---');
                    console.log('Arrival band index:', arrivalBandIndex);
                    console.log('Arrival band tileset:', arrivalBand.tilesetId);
                    console.log('Arrival band timestamp:', arrivalBand.band);
                    console.log('Arrival band JST time:', arrivalBandTime.time);
                    console.log('Arrival band JST date:', arrivalBandTime.date);
                    console.log('Time difference (seconds):', Math.abs(arrivalBand.band - arrivalTimestamp));

                    const arrivalValue = await getPrecipitationAtLocation(lng, lat, arrivalBandIndex);
                    console.log('Arrival precipitation value:', arrivalValue);
                    console.log('===================================');

                    arrivalPrecipDiv.textContent = `予想降水量: ${formatPrecipitation(arrivalValue)}`;
                } else {
                    arrivalPrecipDiv.textContent = '予想降水量: データなし';
                }
            } else {
                arrivalPrecipDiv.textContent = '予想降水量: N/A';
            }

            // Build detailed popup HTML with all the information
            const currentPrecipText = currentPrecipDiv.textContent;
            // Transform ETA text to add line break for popup: "14:30 (25分)" -> "14:30<br>(25分)"
            const etaTextWithBreak = etaDiv.textContent.replace(/\s+\(/g, '<br>(');
            const arrivalPrecipText = arrivalPrecipDiv.textContent;

            const popupHTML = createSuggestionPopupHTML(suggestion, currentPrecipText, etaTextWithBreak, arrivalPrecipText);

            // Set the popup on the marker with the detailed information
            marker.setPopup(
                new mapboxgl.Popup({ offset: 25 })
                    .setHTML(popupHTML)
            );

            // Return coordinates for bounding box calculation
            return { lng, lat };
        } else {
            currentPrecipDiv.textContent = '現在降水量: 位置情報なし';
            arrivalPrecipDiv.textContent = '予想降水量: 位置情報なし';
            return null;
        }
    } catch (error) {
        console.error('Error retrieving feature:', error);
        currentPrecipDiv.textContent = '現在降水量: エラー';
        arrivalPrecipDiv.textContent = '予想降水量: エラー';
        return null;
    }
}

// Handle search result selection
async function handleResultSelection(suggestion) {
    const searchInput = document.getElementById('search-box');
    const searchResults = document.getElementById('search-results');

    // Hide results
    searchResults.classList.remove('visible');

    // Update search input
    searchInput.value = suggestion.name || '';

    // Find the marker for this suggestion
    const marker = suggestionMarkers.find(m => m.suggestionData?.mapbox_id === suggestion.mapbox_id);

    if (marker) {
        // Get the result item from the dropdown to extract calculated data
        const resultItem = document.querySelector(`[data-mapbox-id="${suggestion.mapbox_id}"]`);
        let currentPrecipText = '現在降水量: N/A';
        let etaText = '到着時間: N/A';
        let arrivalPrecipText = '予想降水量: N/A';

        if (resultItem) {
            const currentPrecipDiv = resultItem.querySelector('.result-precipitation');
            const arrivalRow = resultItem.querySelector('.result-arrival-row');

            if (currentPrecipDiv) {
                currentPrecipText = currentPrecipDiv.textContent;
            }

            if (arrivalRow) {
                const etaSpan = arrivalRow.querySelector('.result-eta');
                const arrivalPrecipSpan = arrivalRow.querySelector('.result-precipitation');

                if (etaSpan) {
                    etaText = etaSpan.textContent;
                }
                if (arrivalPrecipSpan) {
                    arrivalPrecipText = arrivalPrecipSpan.textContent;
                }
            }
        }

        // Clear originalBounds so we don't restore to the all-suggestions view
        originalBounds = null;

        // Remove ALL other suggestion markers except this one
        suggestionMarkers.forEach(m => {
            if (m !== marker) {
                m.remove();
            }
        });
        suggestionMarkers = [marker]; // Keep only the selected marker

        // Remove ALL routes except the selected one
        const selectedRouteLayerId = `route-layer-${suggestion.mapbox_id}`;
        routeLayers.forEach(route => {
            if (route.layerId !== selectedRouteLayerId) {
                if (map.getLayer(route.layerId)) {
                    map.removeLayer(route.layerId);
                }
                if (map.getSource(route.sourceId)) {
                    map.removeSource(route.sourceId);
                }
            }
        });
        // Keep only the selected route in the array
        routeLayers = routeLayers.filter(route => route.layerId === selectedRouteLayerId);

        // Change the selected route to red and thicker (without calling highlightRoute which dims other routes)
        if (map.getLayer(selectedRouteLayerId)) {
            map.setPaintProperty(selectedRouteLayerId, 'line-color', '#FF0000');  // Red
            map.setPaintProperty(selectedRouteLayerId, 'line-width', 4);
        }

        // Get the marker element and change it to red with scale
        const markerElement = marker.getElement();
        markerElement.classList.add('highlighted');
        const svg = markerElement.querySelector('svg');
        if (svg) {
            // Change only path elements that have the orange color
            const paths = svg.querySelectorAll('path[fill="#FF9800"]');
            paths.forEach(path => {
                path.style.fill = '#FF0000';  // Red
                path.setAttribute('fill', '#FF0000');  // Red
            });
        }

        // Remove previous selected marker if any
        if (selectedMarker && selectedMarker !== marker) {
            selectedMarker.remove();
        }

        // Create a highlighted marker at the same location
        const lngLat = marker.getLngLat();

        // Remove the orange marker (now highlighted red)
        marker.remove();

        // Build popup HTML with all information
        // Transform ETA text to add line break for popup: "14:30 (25分)" -> "14:30<br>(25分)"
        const etaTextWithBreak = etaText.replace(/\s+\(/g, '<br>(');
        const popupHTML = createSuggestionPopupHTML(suggestion, currentPrecipText, etaTextWithBreak, arrivalPrecipText);

        // Add orange/red selected marker
        selectedMarker = new mapboxgl.Marker({ color: '#FF5722' })
            .setLngLat(lngLat)
            .setPopup(
                new mapboxgl.Popup({ offset: 25 })
                    .setHTML(popupHTML)
            )
            .addTo(map);

        // Zoom to bounding box that includes start (user location), end (destination), and route
        if (userCoordinates) {
            const bounds = [
                [
                    Math.min(userCoordinates.lng, lngLat.lng),
                    Math.min(userCoordinates.lat, lngLat.lat)
                ],
                [
                    Math.max(userCoordinates.lng, lngLat.lng),
                    Math.max(userCoordinates.lat, lngLat.lat)
                ]
            ];

            // Use dynamic padding
            const padding = calculateDynamicPadding();
            map.fitBounds(bounds, {
                padding: padding,
                duration: 1500,
                maxZoom: 14
            });
        } else {
            // Fallback if no user coordinates - just fly to destination
            map.flyTo({
                center: lngLat,
                zoom: 12,
                duration: 1500
            });
        }

        // Show popup
        selectedMarker.togglePopup();

        // Generate new session token after selection (session ends after retrieve)
        sessionToken = generateSessionToken();
        console.log('New session token generated after selection:', sessionToken);
    } else {
        console.error('Marker not found for suggestion:', suggestion.name);
    }
}

// Handle window resize
const handleResize = debounce(() => {
    if (unifiedBands.length > 0) {
        generateZoneBackgrounds();
        generateTimelineTicks();
        console.log('Zones and ticks regenerated for new screen size');
    }
}, 250);

// Add resize listener
window.addEventListener('resize', handleResize);

// Start the app
initMap();

    </script>
</body>
</html>
