<html lang="ja">

<head>
  <meta charset="utf-8" />
<meta name='viewport' content='width=device-width, initial-scale=1' />
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js'></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src='https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.js'></script>
<link href='https://api.mapbox.com/mapbox-gl-js/v3.17.0/mapbox-gl.css' rel='stylesheet' />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js'></script>
<link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css' type='text/css' />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
  <style>
    * {
  box-sizing: border-box;
}

table {
  border-collapse: collapse;
  width: 100%;
}

td,
th {
  border: 1px solid black;
  text-align: left;
  padding: 8px;
}

th {
  background-color: #f2f2f2;
}

h1 {
  font-size: 22px;
  margin: 0;
  font-weight: 400;
  line-height: 20px;
  padding: 20px 2px;
}

a {
  color: red;
  text-decoration: underline;
  cursor: pointer;
  font: 400 14px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
}

.map {
  position: absolute;
  /*left: 20%;*/
  width: 100%;
  top: 0;
  bottom: 0;
}

::-webkit-scrollbar {
  width: 3px;
  height: 3px;
  border-left: 0;
  background: rgba(0, 0, 0, 0.1);
}

::-webkit-scrollbar-track {
  background: none;
}

::-webkit-scrollbar-thumb {
  background: #fff;
  border-radius: 0;
}

.map-overlay-right {
  position: absolute;
  top: 20px;
  right: 20px;
  opacity: 0.8;
  background-color: black;
  color: white;
  opacity: 0.8;
  text-align: left;
  overflow: auto;
  border-radius: 3px;
  padding: 10px;
  font: 400 12px/22px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
  animation: slide-up 1s;
}

.title {
  font-weight: bold;
}

@keyframes slide-up {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

@keyframes slide-right {
  from {
    transform: translateX(-100%);
  }

  to {
    transform: translateX(0%);
  }
}

a.boxclose {
  float: right;
  cursor: pointer;
  display: block;
  box-sizing: border-box;
  width: 20px;
  height: 20px;
  border-width: 3px;
  border-style: solid;
  border-color: #605F61;
  border-radius: 100%;
  background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%);
  background-color: #605F61;
  box-shadow: 0px 0px 5px 2px rgba(0, 0, 0, 0.5);
  transition: all 0.3s ease;
}

h3 {
  /*background: #0076D1;
  color: #fff;*/
  margin: 0;
  padding: 10px;
  border-radius: 3px 3px 0 0;
  font-weight: 700;
  /*margin-top: -15px;*/
}

body,
html {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  font-family: 'Open Sans', sans-serif;
  color: red;
}

h1 {
  margin: 0;
  position: relative;
  top: 50%;
  left: 0;
  right: 0;
  transform: translateY(-50%);
  text-align: center;
  font-size: 40px;
}

.map-overlay-legend {
  position: absolute;
  opacity: 0.8;
  top: 30;
  right: 0;
  background: #fff;
  margin-right: 20px;
  overflow: auto;
  border-radius: 3px;
  width: 300px;
  padding: 10px;
  font: 400 12px/22px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
  transition: transform .5s ease-in-out;
}

.mapboxgl-popup {
  padding-bottom: 10px;
  opacity: 0.8;
  width: 500px;
}

.mapboxgl-popup-content {
  padding-bottom: 10px;
  opacity: 0.8;
  width: fit-content;
}

.marker {
  border: none;
  cursor: pointer;
  height: 56px;
  width: 56px;
  background-image: url(../images/alert.png);
}

.blinking {
  -webkit-animation: blink .5s ease-in-out infinite alternate;
  -moz-animation: blink .5s ease-in-out infinite alternate;
  animation: blink .5s ease-in-out infinite alternate;
}

@-webkit-keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@-moz-keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

a.replay {
  color: blue;
  text-decoration: underline;
  cursor: pointer;
  font: 400 18px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
}


.legend {
  position: absolute;
  bottom: 120px;
  right: 40px;
  background: black;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
  z-index: 1;
  width: 50%;
  opacity: 0.8;
}

.legend-title {
  font-size: 14px;
  text-align: center;
  margin-bottom: 5px;
  color: #000000;
}

.legend-scale {
  text-align: center;
}

.legend-bar {
  position: relative;
  height: 30px;
  background: linear-gradient(to right,
      rgba(80, 74, 154, 1),
      rgba(84, 172, 162, 1),
      rgba(193, 228, 148, 1),
      rgba(252, 244, 162, 1),
      rgba(251, 166, 91, 1),
      rgba(216, 66, 65, 1),
      rgba(143, 3, 58, 1));
  border: 1px solid #999;
  border-radius: 3px;
  margin-bottom: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 5px;
}

.label {
  font-size: 12px;
  color: #fff;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.hidden {
  display: none;
}

.map-overlay-bottom {
  position: absolute;
  bottom: 30px;
  right: 20px;
  left: 20px;
  background-color: black;
  color: white;
  opacity: 0.8;
  margin-right: 20px;
  font-family: Arial, sans-serif;
  overflow: auto;
  border-radius: 3px;
  padding: 10px;
  height: 80px;
}
.slider {
  position: relative;
  top: 20px;
  width: 100%;
}
.time {
  display: flex;
  justify-content: space-between;
  position: relative;
  width: 100%;
  top: 10px;
}
.time span {
  font-size: 11px;
  text-align: center;
}

#active-datetime {
  font-size: 14px;
  width: 100%;
  position: relative;
}

button {
  height: 14px;
  padding: 0 10px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 10px;
}

button:hover {
  background-color: #45a049;
}
</style>
</head>

<body>
  <div id="map" class="map"></div>
  <style>
    #time-display-container {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 2; /* Ensure it's on top of other elements */
        background-color: #e6ecf2;
        padding: 8px 15px;
        border-radius: 5px;
        border: 1px solid #c8d0d8;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        font-family: sans-serif;
        opacity: 0.9;
    }

    .time-display-text {
        font-size: 24px;
        font-weight: 600;
        color: #3d4752;
        white-space: nowrap;
    }
</style>

<div id="time-display-container">
    <span class="time-display-text" id="active-date"></span>
    <span class="time-display-text" id="active-time"></span>
</div>
  <div class="map-overlay-right">
    <div>
        <div class="title">Tileset</div>
    </div>
    <div id="layers">
        <select id="tileset-selector" onchange="changeTileset(this.value)">
        </select>
    </div>
    <div class="title">Projection</div>
    <div>
        <select id="projection-selector" onchange="changeProjection(this.value)">
            <option value="mercator">Mercator</option>
            <option value="globe">Globe</option>
            <option value="albers">Albers</option>
            <option value="equalEarth">Equal Earth</option>
            <option value="equirectangular">Equirectangular</option>
            <option value="naturalEarth">Natural Earth</option>
            <option value="lambertConformalConic">Lambert Conformal Conic</option>
            <option value="winkelTripel">Winkel Tripel</option>
        </select>
    </div>
    <br />
    <div id='raster-array-options'>
        <div id='raster-array-coloring-options'>
            <div>
                <div class="title">Layer</div>
            </div>
            <div id="layers">
                <select id="layer-selector">
                </select>
            </div>
            <div>
                <div class="title">Color Scale</div>
            </div>
            <div id="colorscales">
                <select id="colorscale-selector" onchange="changeColorscaleType(this.value)">
                </select>
            </div>
            <div>
                <div class="title">Color Steps</div>
            </div>
            <div id="colorsteps">
                <select id="colorsteps-selector" onchange="changeColorSteps(this.value)">
                    <option value="256">256</option>
                    <option value="128">128</option>
                    <option value="64">64</option>
                    <option value="32">32</option>
                    <option value="16">16</option>
                    <option value="8">8</option>
                </select>
            </div>
        </div>
        <br>
        <div id="particles-options-wrapper" class="">
            <div class="title"><input type="checkbox" id="show-particles" onchange="showWind(this)" checked /><label
                    for="show-particles">Show Particles</label></div>
            <div id="particle-options">
                <div>
                    Count<br>
                    <input id="particle-count-slider" type="range" step="1" min="1" max="30000"
                        oninput="setParticleCount(this.value)" />
                    <span id="particle-count" style="vertical-align: top;"></span>
                </div>
                <div>
                    Speed<br>
                    <input id="particle-speed-slider" type="range" step="0.01" min="0.01" max="1"
                        onchange="setParticleSpeed(this.value)" />
                    <span id="particle-speed" style="vertical-align: top;"></span>
                </div>
                <div>
                    Color<br>
                    <input id="particle-color" type="color" oninput="setParticleColor(this.value)" />
                </div>
            </div>
        </div>
    </div>
    <div class="title">Zoom Level</div>
    <div id="zoom"></div>
    <div id="zoom-adjust"></div>
    <div id="load-time"></div>
</div>
  <div id="legend" class="legend">
    <div class="legend-scale">
        <div class="legend-bar"></div>
    </div>
</div>
  <style>
    /* A simple reset and basic body styling for demonstration */
    .kikikuru-warning-container-wrapper {
        position: absolute;
        bottom: 40px;
        right: 20px;
        z-index: 1; /* Ensures it's on top of the map */
        width: 350px; /* Set a fixed width for the container */
        /*font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        /* background-color: #f0f2f5; */
        margin: 0;
        color: #333;
        opacity: 0.9;
    }

    /* Main container for the entire component */
    .kikikuru-warning-container {
        background-color: #ffffff;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        /* max-width: 550px; */
        /* width: 100%; */ /* This was causing the collapse */
    }

    /* Title styling */
    .kikikuru-warning-container h2 {
        text-align: left;
        margin-top: 0;
        font-size: 0.9rem;
        color: #333;
    }

    /* Flex container for the meter and legend */
    .warning-display {
        display: flex;
        align-items: flex-start; /* Align tops of meter and legend */
        justify-content: left;
        gap: 40px;
        /* Space between meter and legend */
    }

    /* The meter graphic container */
    .danger-meter {
        position: relative;
        width: 60px;
        height: 120px;
        display: flex;
        flex-direction: column;
        /* Creates the inverted trapezoid shape */
        clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%);
    }

    /* Styling for each colored level inside the meter */
    .level {
        flex: 1;
        /* Makes each level have equal height */
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.8rem;
        font-weight: bold;
        color: white;
    }

    /* Specific colors for each level */
    .level-black {
        background-color: #231815;
    }

    .level-purple {
        background-color: #6c2484;
    }

    .level-red {
        background-color: #d71920;
    }

    .level-yellow {
        background-color: #fff100;
        color: #555;
    }

    .level-white {
        background-color: #ffffff;
        border-top: 1px solid #ccc;
        /* Border to distinguish from background */
        color: black;
    }

    /* Common styling for labels on the meter */
    .meter-label {
        position: absolute;
        background-color: white;
        padding: 2px 6px;
        font-weight: bold;
        color: black;
        border: 1px solid black;
        font-size: 0.9rem;
        white-space: nowrap;
        /* Prevents text wrapping */
    }

    /* Positioning for the "High" label */
    .label-high {
        top: -15px;
        left: 50%;
        transform: translateX(-50%);
    }

    /* Positioning for the "Low" label */
    .label-low {
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
    }

    /* Styling and positioning for the vertical "Danger Level" label */
    .label-vertical {
        writing-mode: vertical-rl;
        text-orientation: mixed;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: gray;
        font-size: 0.8rem;
        font-weight: bold;
        pointer-events: none; /* Allows clicks to pass through */
        letter-spacing: 0.5em; /* Adds space between characters */
    }

    /* The legend section to the right of the meter */
    .legend-kikikuru {
        display: flex;
        flex-direction: column;
    }

    .legend-kikikuru-item {
        flex: 1; /* Each item takes up equal space, matching the 'level' divs */
        display: flex;
        align-items: center;
        font-size: 0.8rem;
        height: 24px;
    }

    /* The colored square (swatch) in the legend */
    .swatch {
        width: 24px;
        height: 14px;
        margin-right: 12px;
        flex-shrink: 0;
        /* Prevents swatch from shrinking */
    }

    .swatch-label {
        height: 24px;
    }

    /* Specific colors for each swatch */
    .swatch-black {
        background-color: #231815;
    }

    .swatch-purple {
        background-color: #6c2484;
    }

    .swatch-red {
        background-color: #d71920;
    }

    .swatch-yellow {
        background-color: #fff100;
    }

    .swatch-white {
        background-color: #ffffff;
        border: 1px solid #333;
    }
</style>
<div class="kikikuru-warning-container-wrapper" id="kikikuru-legend">
    <div class="kikikuru-warning-container">
        <h2><span id="kikikuru-type">浸水害</span>の危険度</h2>
        <div class="warning-display">
            <div class="danger-meter">
                <div class="level level-black">高</div>
                <div class="level level-purple"></div>
                <div class="level level-red"></div>
                <div class="level level-yellow"></div>
                <div class="level level-white" id="kikikuru-level-lowest">低</div>
                <div class="label-vertical">危険度</div>
            </div>

            <div class="legend-kikikuru">
                <div class="legend-kikikuru-item">
                    <div class="swatch swatch-black"></div>
                    <div class="swatch-label">災害切迫【警戒レベル５相当】</div>
                </div>
                <div class="legend-kikikuru-item">
                    <div class="swatch swatch-purple"></div>
                    <div class="swatch-label">危険【警戒レベル４相当】</div>
                </div>
                <div class="legend-kikikuru-item">
                    <div class="swatch swatch-red"></div>
                    <div class="swatch-label">警戒【警戒レベル３相当】</div>
                </div>
                <div class="legend-kikikuru-item">
                    <div class="swatch swatch-yellow"></div>
                    <div class="swatch-label">注意【警戒レベル２相当】</div>
                </div>
                <div class="legend-kikikuru-item">
                    <div class="swatch swatch-white" id="swatch-level-lowest"></div>
                    <div class="swatch-label">今後の情報等に留意</div>
                </div>
            </div>
        </div>
    </div>
</div>
  <div id="map-overlay-bottom" class="map-overlay-bottom" style="width: 600px;">
    <button id="auto" onclick="play()">Play</button>
    <div class="time" id="timediv"></div>
    <input type="range" min="0" step="1" value="0" max="5" class="slider" id="slider" oninput="changeBand(this.value)" />
</div>
  

</body>
<script>
  lat = -24.635070733310073;
lng = 134.6455347407337;

const tilesets = {
    wind_4: {
        value: 'mapbox://kenji-shima.bom-wind-z4',
        label: 'wind zoom 4',
        type: 'raster-array-particle',
        mapstyle: 'mapbox://styles/mapbox/satellite-v9',
        maplayer_above: 'satellite',
    },
    wind_6: {
        value: 'mapbox://kenji-shima.bom-wind-z6',
        label: 'wind zoom 6',
        type: 'raster-array-particle',
        mapstyle: 'mapbox://styles/mapbox/satellite-v9',
        maplayer_above: 'satellite',
    },
    wind_8: {
        value: 'mapbox://kenji-shima.bom-wind-z8',
        label: 'wind zoom 8',
        type: 'raster-array-particle',
        mapstyle: 'mapbox://styles/mapbox/satellite-v9',
        maplayer_above: 'satellite',
    },
    wind_10: {
        value: 'mapbox://kenji-shima.bom-wind-z10',
        label: 'wind zoom 10',
        type: 'raster-array-particle',
        mapstyle: 'mapbox://styles/mapbox/satellite-v9',
        maplayer_above: 'satellite',
    },
};
  const defaultzoom = 4;
let zoom = defaultzoom;
let particlelayerid = null;
let currentprojection = 'mercator';

//const defaultStyle = 'mapbox://styles/mapbox/streets-v12'
const defaultStyle = 'mapbox://styles/kenji-shima/cmfurpm8w00j101r86qp530c8';
const firsttileset = Object.keys(tilesets)[0];
let tilesetid = firsttileset;
let tileset = tilesets[firsttileset].value;
let tilesettype = tilesets[firsttileset].type;
let tilesetvectortype = null;
let tilesetvectorsource = null;
let mapstyle = tilesets[firsttileset].mapstyle || defaultStyle;
let tilesetsuffix = '';
let tilesetresampling = 'nearest';
let bandlist = [];
let lastBandIndex = 0;
let layers = {};
let currentLayer = null;

let map = new mapboxgl.Map({
    container: 'map',
    //style: defaultStyle,
    style: mapstyle,
    center: [lng, lat],
    zoom: zoom,
    //maxZoom: 12,
    scrollZoom: true,
    projection: currentprojection,
    language: 'ja'
});

map.on('style.load', () => {
    map.showTileBoundaries = true;
    showAllOptions();

    // map.setFog({
    //     color: 'rgba(61, 70, 79, 1)', // Lower atmosphere
    //     'high-color': 'rgb(36, 92, 223)', // Upper atmosphere
    //     'horizon-blend': 0.02, // Atmosphere thickness (default 0.2 at low zooms)
    //     'space-color': 'rgb(11, 11, 25)', // Background color
    //     'star-intensity': 0.6 // Background star brightness (default 0.35 at low zoooms )
    // })

    let popup = null;
    map.on('mousemove', async (e) => {

        if (tilesettype === 'raster-array') {
            if (!popup) {
                popup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: false,
                });
            }
            try {
                // Check if the source exists before querying
                if (!map.getSource('rastersource')) {
                    if (popup) {
                        popup.remove();
                    }
                    return;
                }

                const result = await map.queryRasterValue('rastersource', e.lngLat, {
                    layerName: currentLayer,
                    bands: bandlist.length > 0 ? [bandlist[lastBandIndex].toString()] : undefined
                });

                if (result && result[currentLayer][bandlist[lastBandIndex].toString()]) {
                    const value = result[currentLayer][bandlist[lastBandIndex].toString()][0];
                    popup.setLngLat(e.lngLat)
                        .setHTML(`<div><strong>Value:</strong> ${value}</div>`)
                        .addTo(map);
                } else {
                    if (popup) {
                        popup.remove();
                    }
                }
            } catch (error) {
                console.error('Error querying raster value:', error);
            }
        } else {
            if (popup) {
                popup.remove();
            }
        }

    });

});

function changeProjection(projectionType) {
    currentprojection = projectionType;
    map.setProjection(projectionType);
}
window.changeProjection = changeProjection;

map.on('zoom', () => {
    let zoom = map.getZoom();
    zoom = Math.round((zoom + Number.EPSILON) * 100) / 100;
    document.getElementById('zoom').innerHTML = zoom;
});

// map.on('movestart', (e) => {
//     if (tilesettype !== 'raster-array') {
//         return;
//     }
//     changeBand(lastBandIndex);
// });

map.on('click', (e) => {
    const coordinates = e.lngLat;
    console.log('Latitude: ' + coordinates.lat + ', Longitude: ' + coordinates.lng);
});

let sourceSetStart = 0;
map.on('sourcedata', (e) => {
    // console.log('Source data event:', e);
    // console.log('currenttileset:', tileset);
    if (e.source.url !== tileset + tilesetsuffix) {
        return;
    }
    if (e.isSourceLoaded) {
        document.getElementById('load-time').innerHTML = `<div class="title">Layer Load Time</div><div>${Date.now() - sourceSetStart} ms</div>`;
        sourceSetStart = Date.now();
    }

});

document.getElementById('zoom-adjust').innerHTML = `<div class="title">Change Zoom</div><div><select id="zoom-selector" onchange="changeZoom(this.value)"></select></div>`;
const zoomSelector = document.getElementById('zoom-selector');
for (let i = 0; i < 12; i++) {
    const option = document.createElement('option');
    option.value = i;
    option.textContent = i;
    zoomSelector.appendChild(option);
}
function changeZoom(value) {
    map.setZoom(value);
}



const yjRainScale = () => {
    const domain = [0, 1, 4, 8, 12, 16, 24, 32, 40, 48, 56, 64, 80, 200];
    const range = [
        'rgba(204, 255, 255, 0.0)',
        'rgba(102, 255, 255, 0.0)',
        'rgba(0, 204, 255, 0.8)',
        'rgba(0, 153, 255, 0.8)',
        'rgba(51, 102, 255, 0.8)',
        'rgba(51, 255, 0, 0.8)',
        'rgba(51, 204, 0, 0.8)',
        'rgba(25, 153, 0, 0.8)',
        'rgba(255, 255, 0, 0.8)',
        'rgba(255, 204, 0, 0.8)',
        'rgba(255, 153, 0, 0.8)',
        'rgba(255, 80, 102, 0.8)',
        'rgba(255, 0, 0, 0.8)',
        'rgba(183, 0, 16, 0.8)'
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const jmaSedimentScale = () => {
    const domain = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const range = [
        'rgba(0, 0, 0, 1.0)',
        'rgba(0, 0, 0, 1.0)',
        'rgba(0, 0, 0, 1.0)',
        'rgba(0, 0, 0, 1.0)',
        'rgba(242, 231, 0, 1.0)',
        'rgba(255, 40, 0, 1.0)',
        'rgba(170, 0, 170, 1.0)',
        'rgba(12, 0, 12, 1.0)',
        'rgba(0, 0, 0, 1.0)',
        'rgba(0, 0, 0, 1.0)',
        'rgba(0, 0, 0, 1.0)'
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const vectorScale = () => {
    const domain = [0, 1, 4, 8, 12, 16, 24, 32, 40, 48, 56, 64, 80, 200];
    const range = [
        'rgba(50, 54, 54, 0)',
        'rgba(102, 255, 255, 0.0)',
        'rgba(0, 204, 255, 0.0)',
        'rgba(0, 153, 255, 0.8)',
        'rgba(51, 102, 255, 0.8)',
        'rgba(51, 255, 0, 0.8)',
        'rgba(51, 204, 0, 0.8)',
        'rgba(25, 153, 0, 0.8)',
        'rgba(255, 255, 0, 0.8)',
        'rgba(255, 204, 0, 0.8)',
        'rgba(255, 153, 0, 0.8)',
        'rgba(255, 80, 102, 0.8)',
        'rgba(255, 0, 0, 0.8)',
        'rgba(183, 0, 16, 0.8)'
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const snowScale = () => {
    const domain = [1.5, 4.5, 19.5, 49.5, 90.5, 149.5, 199.5];
    const range = [
        'rgba(160, 210, 255, 0.9)',  // 水色 (5)
        'rgba(33, 140, 255, 0.9)',  // 水色 (5)
        'rgba(0, 65, 255, 0.9)',    // 明るい青 (20)
        'rgba(250, 245, 0, 0.9)',   // 青 (50)
        'rgba(255, 153, 0, 0.9)',    // 黄色 (100)
        'rgba(255, 40, 0, 0.9)',    // オレンジ (150)
        'rgba(180, 0, 104, 0.9)'      // 赤 (200)
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const kikikuruShinsuiScale = () => {
    //const domain = [2, 3, 4, 5];
    const domain = [1.5, 2.5, 3.5, 4.5];
    const range = [
        'rgba(242, 231, 0, 1)',
        'rgba(255, 40, 0, 1)',
        'rgba(170, 0, 170, 1)',
        'rgba(12, 0, 12, 1)',
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const kikikuruDoshaScale = () => {
    //const domain = [4, 5, 6, 7];
    const domain = [3.5, 4.5, 5.5, 6.5];
    const range = [
        'rgba(242, 231, 0, 1)',
        'rgba(255, 40, 0, 1)',
        'rgba(170, 0, 170, 1)',
        'rgba(12, 0, 12, 1)',
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const rainScale = () => {
    const domain = [
        2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
        23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
        61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80
    ];

    const range = [
        'rgba(102, 255, 255, 0.7)',
        'rgba(68, 238, 255, 0.7)',
        'rgba(34, 221, 255, 0.71)',
        'rgba(0, 204, 255, 0.71)',
        'rgba(10, 184, 255, 0.71)',
        'rgba(20, 163, 255, 0.71)',
        'rgba(31, 143, 255, 0.72)',
        'rgba(41, 122, 255, 0.72)',
        'rgba(51, 102, 255, 0.72)',
        'rgba(71, 112, 230, 0.72)',
        'rgba(92, 122, 204, 0.73)',
        'rgba(112, 133, 178, 0.73)',
        'rgba(133, 143, 153, 0.73)',
        'rgba(153, 153, 128, 0.73)',
        'rgba(173, 163, 102, 0.74)',
        'rgba(194, 173, 76, 0.74)',
        'rgba(214, 184, 51, 0.74)',
        'rgba(235, 194, 26, 0.74)',
        'rgba(255, 204, 0, 0.75)',
        'rgba(255, 199, 0, 0.75)',
        'rgba(255, 194, 0, 0.75)',
        'rgba(255, 189, 0, 0.75)',
        'rgba(255, 184, 0, 0.76)',
        'rgba(255, 178, 0, 0.76)',
        'rgba(255, 173, 0, 0.76)',
        'rgba(255, 168, 0, 0.76)',
        'rgba(255, 163, 0, 0.77)',
        'rgba(255, 158, 0, 0.77)',
        'rgba(255, 153, 0, 0.77)',
        'rgba(255, 145, 0, 0.77)',
        'rgba(255, 138, 0, 0.78)',
        'rgba(255, 130, 0, 0.78)',
        'rgba(255, 122, 0, 0.78)',
        'rgba(255, 115, 0, 0.78)',
        'rgba(255, 107, 0, 0.79)',
        'rgba(255, 99, 0, 0.79)',
        'rgba(255, 92, 0, 0.79)',
        'rgba(255, 84, 0, 0.79)',
        'rgba(255, 76, 0, 0.8)',
        'rgba(255, 69, 0, 0.8)',
        'rgba(255, 61, 0, 0.8)',
        'rgba(255, 54, 0, 0.81)',
        'rgba(255, 46, 0, 0.81)',
        'rgba(255, 38, 0, 0.81)',
        'rgba(255, 31, 0, 0.81)',
        'rgba(255, 23, 0, 0.82)',
        'rgba(255, 15, 0, 0.82)',
        'rgba(255, 8, 0, 0.82)',
        'rgba(255, 0, 0, 0.82)',
        'rgba(253, 0, 1, 0.83)',
        'rgba(250, 0, 1, 0.83)',
        'rgba(248, 0, 2, 0.83)',
        'rgba(245, 0, 2, 0.83)',
        'rgba(243, 0, 3, 0.84)',
        'rgba(241, 0, 3, 0.84)',
        'rgba(238, 0, 4, 0.84)',
        'rgba(236, 0, 4, 0.84)',
        'rgba(233, 0, 5, 0.85)',
        'rgba(231, 0, 5, 0.85)',
        'rgba(229, 0, 6, 0.85)',
        'rgba(226, 0, 6, 0.85)',
        'rgba(224, 0, 7, 0.86)',
        'rgba(221, 0, 7, 0.86)',
        'rgba(219, 0, 8, 0.86)',
        'rgba(217, 0, 9, 0.86)',
        'rgba(214, 0, 9, 0.87)',
        'rgba(212, 0, 10, 0.87)',
        'rgba(209, 0, 10, 0.87)',
        'rgba(207, 0, 11, 0.87)',
        'rgba(205, 0, 11, 0.88)',
        'rgba(202, 0, 12, 0.88)',
        'rgba(200, 0, 12, 0.88)',
        'rgba(197, 0, 13, 0.88)',
        'rgba(195, 0, 13, 0.89)',
        'rgba(193, 0, 14, 0.89)',
        'rgba(190, 0, 14, 0.89)',
        'rgba(188, 0, 15, 0.89)',
        'rgba(185, 0, 15, 0.9)',
        'rgba(183, 0, 16, 0.9)'
    ];
    return domain.map((v, i) => [v, range[i]]).flat();
};

const COLORSCALES = {
    'Turbo': d3.interpolateTurbo,
    'Spectral': x => d3.interpolateSpectral(1 - x),
    'Magma': d3.interpolateMagma,
    'Plasma': d3.interpolatePlasma,
    'Inferno': d3.interpolateInferno,
    'Greys': x => d3.interpolateGreys(1 - x),
    'Viridis': d3.interpolateViridis,
    'Cividis': d3.interpolateCividis,
    'Warm': d3.interpolateWarm,
    'Cool': d3.interpolateCool,
    'Cubehelix': d3.interpolateCubehelixDefault,
    // 'YJRain': {
    //     manual: true,
    //     value: yjRainScale()
    // },
    'JMASediment': {
        manual: true,
        value: jmaSedimentScale()
    },
    'Rain': {
        manual: true,
        value: rainScale()
    },
    'Snow': {
        manual: true,
        value: snowScale()
    },
    'Vector': {
        manual: true,
        value: vectorScale()
    },
    'KikikuruShinsui': {
        manual: true,
        value: kikikuruShinsuiScale()
    },
    'KikikuruDosha': {
        manual: true,
        value: kikikuruDoshaScale()
    }
};

const defaultcolorscalename = 'Turbo';
let selectedcolorscalename = tilesets[firsttileset].colorscale || defaultcolorscalename;
let colorscaletype = COLORSCALES[selectedcolorscalename];
let colorsteps = 256;
//let colorsteps = 8

const stepexpression = [
    'step',
    ['raster-value'],
    'rgba(0, 0, 0, 0)'
];
const interpolateexpression = [
    'interpolate',
    ['linear'],
    ['raster-value']
];

//let colorscaleExpressiontemplate = interpolateexpression
let colorscaleExpressiontemplate = stepexpression;
// tilesetsuffix and tilesetresampling are now declared at the top of the file

function getColorScale(colorRange) {
    let colorscale = null;
    if (colorscaletype.manual) {
        colorscale = colorscaletype.value;
    } else {
        colorscale = d3.quantize(colorscaletype, colorsteps).map((c, i) => [(i / colorsteps), c]);
        const [minValue, maxValue] = colorRange;
        colorscale = colorscale.map(([x, c]) => [
            minValue + (maxValue - minValue) * x,
            c
        ])
            .flat();
    }
    const colorscaleExpression = colorscaleExpressiontemplate.slice();
    colorscale.forEach(item => {
        colorscaleExpression.push(item);
    });
    return colorscaleExpression;
}

function updateLegendBar(colorRange) {
    const increment = oneTwoFive(colorRange);
    const [minValue, maxValue] = colorRange;
    let legendVals = [];
    for (let i = minValue + increment; i <= maxValue; i += increment) {
        legendVals.push(i);
    }
    let colors = null;
    if (colorscaletype.manual) {
        colors = colorscaletype.value;
        let updateColors = [];
        for (let i = 0; i < colors.length; i += 2) {
            updateColors.push([colors[i], colors[i + 1].replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)/, 'rgb($1,$2,$3)')]);
        }
        colors = updateColors;
    } else {
        colors = d3.quantize(colorscaletype, colorsteps).map((c, i) => [(i / colorsteps), c]);
    }
    const updatedColors = colors.map(([stop, color]) => {
        if (color.startsWith('rgb(') && !color.startsWith('rgba(')) {
            color = color.replace('rgb(', 'rgba(').replace(')', ', 1)');
        }
        return [stop, color];
    });

    const minStop = Math.min(...updatedColors.map(([stop]) => stop));
    const maxStop = Math.max(...updatedColors.map(([stop]) => stop));

    // Normalize stop values between 0 and 1
    const gradientColors = updatedColors.map(([stop, color]) => {
        const normalizedStop = (stop - minStop) / (maxStop - minStop);  // Normalized to range [0, 1]
        return `${color} ${normalizedStop * 100}%`;
    }).join(', ');

    const legendBar = document.querySelector('.legend-bar');

    legendBar.style.background = `linear-gradient(to right, ${gradientColors})`;

    legendBar.innerHTML = '';
    legendVals.forEach(element => {
        const span = legendBar.appendChild(document.createElement('span'));
        span.className = 'label';
        span.style = '';
        span.innerHTML = element;
    });
}

let initOption;
// bandlist is now declared at the top of the file

function showAllOptions() {
    sourceSetStart = Date.now();
    if (tilesettype === 'raster-array') {
        document.getElementById('raster-array-options').style.display = 'block';
        document.getElementById('raster-array-coloring-options').style.display = 'block';
        if (tilesetid.indexOf('alert') !== -1 || tilesetid.indexOf('landslide') !== -1) {
            document.getElementById('legend').style.display = 'none';
            document.getElementById('kikikuru-legend').style.display = 'block';
            document.getElementById('kikikuru-level-lowest').style = '';
            document.getElementById('swatch-level-lowest').style = '';
            if (tilesetid.indexOf('alert') !== -1) {
                document.getElementById('kikikuru-type').innerText = '浸水害';
            } else if (tilesetid.indexOf('landslide') !== -1) {
                document.getElementById('kikikuru-type').innerText = '土砂災害';
            }
        } else {
            document.getElementById('kikikuru-legend').style.display = 'none';
            document.getElementById('legend').style.display = 'block';
        }

        document.getElementById('map-overlay-bottom').style.display = 'block';
        showAllRasterArrayOptions();
    } else if (tilesettype === 'raster-array-particle') {
        showAllRasterArrayOptions().then(() => {
            addParticles();
            document.getElementById('raster-array-coloring-options').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
            document.getElementById('map-overlay-bottom').style.display = 'none';
            document.getElementById('kikikuru-legend').style.display = 'none';
            setTimeFromTileJson();
        });

    } else {
        document.getElementById('raster-array-options').style.display = 'none';
        document.getElementById('legend').style.display = 'none';
        document.getElementById('map-overlay-bottom').style.display = 'none';
        if (tilesettype === 'raster') {
            addRasterLayer();
        } else if (tilesettype === 'vector') {
            if (tilesetvectortype === 'circle') {
                addCircleLayer();
            } else if (tilesetvectortype === 'fill') {
                addFillLayer();
            } else if (tilesetvectortype === 'line' && tilesetvectorsource === 'river_flood') {
                addFloodLayer();
            } else if (tilesetvectortype === 'line') {
                addLineLayer();
            }
        }
        if (tilesetid.indexOf('flood') !== -1) {
            document.getElementById('kikikuru-legend').style.display = 'block';
            document.getElementById('kikikuru-type').innerText = '洪水';
            document.getElementById('kikikuru-level-lowest').style = 'background-color: #00FFFF;';
            document.getElementById('swatch-level-lowest').style = 'background-color: #00FFFF;';
        }
        setTimeFromTileJson();

    }
}

function setTimeFromTileJson() {
    getTilejson().then(tilejson => {
        if (!tilejson.description) {
            return;
        }

        const utcTimestamp = tilejson.description.split(':: ')[1];

        // Convert UTC yyyyMMddHHmmSS to JST yyyyMMddHHmmSS
        const jstTimestamp = utcStringToJST(utcTimestamp);

        // Format the JST timestamp into the desired format
        const year = jstTimestamp.substring(0, 4);
        const month = jstTimestamp.substring(4, 6);
        const day = jstTimestamp.substring(6, 8);
        const hour = jstTimestamp.substring(8, 10);
        const minute = jstTimestamp.substring(10, 12);

        const formattedDate = `${year}/${month}/${day}`;
        const formattedTime = `${hour}:${minute}`;

        document.getElementById('active-date').innerHTML = formattedDate;
        document.getElementById('active-time').innerHTML = formattedTime;
    });
}

async function showAllRasterArrayOptions() {
    await getCurrentBands();
    setLayerOptions();
    changeColorscaleType(selectedcolorscalename);
    // showLayer(initOption)

    const colorscaleselect = document.getElementById('colorscale-selector');
    colorscaleselect.innerHTML = '';
    for (let type in COLORSCALES) {
        const option = colorscaleselect.appendChild(document.createElement('option'));
        option.value = type;
        option.innerHTML = type;
        if (type === selectedcolorscalename) option.selected = true;
    }

    if (particlelayerid) {
        document.getElementById('particles-options-wrapper').style.display = 'block';
    } else {
        document.getElementById('particles-options-wrapper').style.display = 'none';
    }

    const tilesetselect = document.getElementById('tileset-selector');
    tilesetselect.innerHTML = '';
    for (let tile in tilesets) {
        const option = tilesetselect.appendChild(document.createElement('option'));
        option.value = tile;
        option.innerHTML = tilesets[tile].label;
        if (tilesets[tile].value === tileset) option.selected = true;
    }

    initTimeSlider(0);

}

function initTimeSlider(val) {
    const timeslider = document.getElementById('slider');
    timeslider.max = bandlist.length - 1;
    timeslider.value = val;

    const timediv = document.getElementById('timediv');
    timediv.innerHTML = '';
    const date = document.getElementById('active-date');
    date.innerHTML = '';
    const time = document.getElementById('active-time');
    time.innerHTML = '';

    const auto = document.getElementById('auto');

    if (bandlist.length >= 1) {
        const currentDateTime = convertTimeValue(bandlist[val]).split(' ');
        date.innerHTML = currentDateTime[0];
        time.innerHTML = currentDateTime[1];

        timeslider.disabled = false;
        auto.disabled = false;
        timeslider.style = 'visibility: visible;';
        let index = 0;
        bandlist.forEach(datetime => {
            const datetimearray = convertTimeValue(datetime).split(' ');
            const timespan = timediv.appendChild(document.createElement('span'));
            if (index === 0 || index === bandlist.length - 1) {
                timespan.innerHTML = `${datetimearray[1]}`;
            } else {
                timespan.innerHTML = `・`;
            }
            // date.innerHTML = datetimearray[0] // This line was incorrect
            index++;
        });
        if (bandlist.length === 1) {
            document.getElementById('map-overlay-bottom').style.display = 'none';
        }
    } else {
        timeslider.disabled = true;
        timeslider.style = 'visibility: hidden;';
        if (autoFlag) play();
        auto.disabled = true;
        document.getElementById('map-overlay-bottom').style.display = 'none';
    }
}

const baseDate = new Date(Date.UTC(1990, 0, 1));
function convertTimeValue(timeValue) {
    // Check if timeValue is a string (band name) rather than a numeric time value
    if (typeof timeValue === 'string' && isNaN(Number(timeValue))) {
        return '  '; // Return two spaces so split(' ') produces valid array
    }

    const millisecondsInDay = 24 * 60 * 60 * 1000;
    const totalMilliseconds = Math.round(timeValue * millisecondsInDay);
    const date = new Date(baseDate.getTime() + totalMilliseconds);
    const options = {
        timeZone: 'Asia/Tokyo',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false, // Use 24-hour format
    };
    const formatter = new Intl.DateTimeFormat('ja-JP', options);
    const parts = formatter.formatToParts(date);
    const dateString = `${parts.find(p => p.type === 'year').value}/` +
        `${parts.find(p => p.type === 'month').value}/` +
        `${parts.find(p => p.type === 'day').value} ` +
        `${parts.find(p => p.type === 'hour').value}:` +
        `${parts.find(p => p.type === 'minute').value}`;

    return dateString;
}

async function getCurrentBands() {
    const tilejson = await getTilejson();

    // If particlelayerid is already set from tileset config, use it
    if (particlelayerid && tilesettype === 'raster-array-particle') {
        return tilejson;
    }

    // If currentLayer is set from speedLayer config, find it
    if (currentLayer && tilesettype === 'raster-array') {
        let foundLayer = false;
        tilejson.raster_layers.forEach(layer => {
            if (layer.id === currentLayer || layer.fields.name === currentLayer) {
                bandlist = layer.fields.bands || [];
                initTimeSlider(lastBandIndex);
                initOption = layer.fields.name;
                currentLayer = layer.fields.name;

                layers[layer.fields.name] = {
                    label: layer.fields.name,
                    layer: layer.fields.name,
                    color_range: layer.fields.range,
                    minzoom: tilejson.minzoom,
                    maxzoom: tilejson.maxzoom,
                };
                foundLayer = true;
            }
        });
        if (foundLayer) {
            return tilejson;
        }
    }

    // Otherwise, check for default particle layer names
    if (!currentLayer) {
        currentLayer = tilejson.raster_layers[0].fields.name; // Default to the first layer if none is set
    }

    if (currentLayer === 'wind' || currentLayer === 'winds' || currentLayer === '10winds' || currentLayer.includes('wind_vector')) {
        particlelayerid = currentLayer;
        return tilejson;
    }

    tilejson.raster_layers.forEach(layer => {
        if (layer.id === currentLayer || layer.fields.name === currentLayer) {
            bandlist = layer.fields.bands || [];
            initTimeSlider(lastBandIndex);
            initOption = layer.fields.name;
            currentLayer = layer.fields.name;

            layers[layer.fields.name] = {
                label: layer.fields.name,
                layer: layer.fields.name,
                color_range: layer.fields.range,
                minzoom: tilejson.minzoom,
                maxzoom: tilejson.maxzoom,
            };
        }
    });
    return tilejson; // Return the data for callers who need it
}

async function getTilejson() {
    const tilesetid = tileset.split('/').slice(-1)[0];
    const tilejsonurl = `https://api.mapbox.com/v4/${tilesetid}.json?access_token=${mapboxgl.accessToken}`;
    try {
        const response = await fetch(tilejsonurl);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const tilejson = await response.json();
        console.log('Tile JSON:', tilejson);
        return tilejson;
    } catch (error) {
        console.error('Error fetching tile JSON:', error);
        throw error; // Re-throw so callers can handle the error
    }
}
// lastBandIndex is now declared at the top of the file

async function changeBand(index) {
    lastBandIndex = index;
    initTimeSlider(lastBandIndex);
    map.setPaintProperty(currentLayer, 'raster-array-band', bandlist[lastBandIndex]);
}
window.changeBand = changeBand;

function removeAllLayers() {
    // Remove all raster array layers
    for (let l in layers) {
        if (map.getLayer(l)) {
            map.removeLayer(l);
        }
    }

    // Remove common layer types
    const commonLayers = ['vector', 'raster', 'particlelayer'];
    commonLayers.forEach(layerId => {
        if (map.getLayer(layerId)) {
            map.removeLayer(layerId);
        }
    });

    // Remove particles
    removeParticles();

    // Remove all sources
    const commonSources = ['rastersource', 'vectorsource', 'particlesource'];
    commonSources.forEach(sourceId => {
        if (map.getSource(sourceId)) {
            map.removeSource(sourceId);
        }
    });

    // Reset layers object
    layers = {};

    // Reset layer-related variables
    particlelayerid = null;
    bandlist = [];
    initOption = null;
    currentLayer = null;
}

let currentStyle = mapstyle;
function changeTileset(t) {
    lastBandIndex = 0;
    removeAllLayers();
    tilesetid = t;
    tileset = tilesets[t].value;
    tilesettype = tilesets[t].type;
    const newMapStyle = tilesets[t].mapstyle || defaultStyle;
    layerAbove = tilesets[t].maplayer_above || layerAboveDefault;
    tilesetsuffix = tilesets[t].suffix || '';
    tilesetresampling = tilesets[t].resampling || 'nearest';

    // Reset layer-specific variables
    particlelayerid = null;
    currentLayer = null;

    // Set particle layer ID if specified
    if (tilesets[t].particleLayer) {
        particlelayerid = tilesets[t].particleLayer;
    }

    // Set current layer if speedLayer is specified
    if (tilesets[t].speedLayer) {
        currentLayer = tilesets[t].speedLayer;
    }

    if (tilesettype === 'vector') {
        tilesetvectortype = tilesets[t].vector_layer_type;
        tilesetvectorsource = tilesets[t].vector_layer_source;
    }
    if (tilesets[t].zoom) {
        zoom = tilesets[t].zoom;
    } else {
        zoom = defaultzoom;
    }
    if (tilesets[t].colorscale) {
        selectedcolorscalename = tilesets[t].colorscale;
    } else {
        selectedcolorscalename = defaultcolorscalename;
    }

    // Check if the new style is different from the current one.
    if (currentStyle !== newMapStyle) {
        // If styles are different, wait for the new style to load.
        map.once('style.load', () => {
            showAllOptions();
        });
        map.setStyle(newMapStyle);
    } else {
        // If style is the same, the map is ready. Just add the new layers.
        showAllOptions();
    }
    currentStyle = newMapStyle;
}
window.changeTileset = changeTileset;

function changeColorscaleType(type) {
    selectedcolorscalename = type;
    colorscaletype = COLORSCALES[type];
    showLayer(currentLayer);
}
window.changeColorscaleType = changeColorscaleType;

function changeColorSteps(steps) {
    colorsteps = steps;
    showLayer(currentLayer);
}
window.changeColorSteps = changeColorSteps;

function oneTwoFive(range, maxSteps = 15) {
    const rng = range[1] - range[0];
    const oneSize = 1 * Math.pow(10, Math.round(Math.log10(rng / 1 / maxSteps)));
    const twoSize = 2 * Math.pow(10, Math.round(Math.log10(rng / 2 / maxSteps)));
    const fiveSize = 5 * Math.pow(10, Math.round(Math.log10(rng / 5 / maxSteps)));
    const oneSteps = Math.floor(rng / oneSize);
    const twoSteps = Math.floor(rng / twoSize);
    const fiveSteps = Math.floor(rng / fiveSize);

    if (oneSteps < twoSteps) return oneSteps < fiveSteps ? oneSize : fiveSize;
    return twoSteps < fiveSteps ? twoSize : fiveSize;
}
// layers is now declared at the top of the file

function setLayerOptions() {
    const select = document.getElementById('layer-selector');
    select.innerHTML = '';
    for (let l in layers) {
        const option = select.appendChild(document.createElement('option'));
        option.value = l;
        option.innerHTML = l;
        if (l === initOption) {
            option.selected = true;
        }
    }
    document.getElementById('layer-selector').addEventListener('change', function () {
        showLayer(this.value);
    });
}
// currentLayer is now declared at the top of the file (initialized to null, will be set later)
currentLayer = initOption;
const layerAboveDefault = tilesets[firsttileset].maplayer_above || 'road-exit-shield';
let layerAbove = layerAboveDefault;
const showLayer = (layer) => {
    currentLayer = layer;
    for (let l in layers) {
        if (map.getLayer(l)) {
            map.removeLayer(l);
        }
    }
    removeParticles();
    if (map.getSource('rastersource')) {
        map.removeSource('rastersource');
    }
    if (tilesettype === 'raster-array') {
        addRasterArrayLayer(layer);
    }
};
document.showLayer = showLayer;

const addCircleLayer = () => {
    if (map.getLayer('vector')) {
        map.removeLayer('vector');
    }
    if (map.getSource('vectorsource')) {
        map.removeSource('vectorsource');
    }
    map.addSource('vectorsource', {
        type: 'vector',
        url: tileset
    });
    map.addLayer({
        id: 'vector',
        type: 'circle',
        source: 'vectorsource',
        'source-layer': tilesetvectorsource,
        paint: {
            'circle-radius': 5,
            'circle-color': 'rgba(255, 0, 0, 1)',
            'circle-stroke-width': 1,
            'circle-stroke-color': 'rgba(0, 0, 0, 1)'
        },
        layerAbove
    });
};

const addFillLayer = () => {
    if (map.getLayer('vector')) {
        map.removeLayer('vector');
    }
    if (map.getSource('vectorsource')) {
        map.removeSource('vectorsource');
    }
    map.addSource('vectorsource', {
        type: 'vector',
        url: tileset
    });
    map.addLayer({
        id: 'vector',
        type: 'fill',
        source: 'vectorsource',
        'source-layer': tilesetvectorsource,
        paint: {
            'fill-color': 'rgba(255, 0, 0, 0.5)',
            'fill-outline-color': 'rgba(0, 0, 0, 1)'
        },
        layerAbove
    });
};

const addLineLayer = () => {
    if (map.getLayer('vector')) {
        map.removeLayer('vector');
    }
    if (map.getSource('vectorsource')) {
        map.removeSource('vectorsource');
    }
    map.addSource('vectorsource', {
        type: 'vector',
        url: tileset
    });
    map.addLayer({
        id: 'vector',
        type: 'line',
        source: 'vectorsource',
        'source-layer': tilesetvectorsource,
        paint: {
            'line-color': 'rgba(255, 0, 0, 1)',
            'line-width': 2
        }
        , layerAbove
    });
};

const addFloodLayer = () => {
    if (map.getLayer('vector')) {
        map.removeLayer('vector');
    }
    if (map.getSource('vectorsource')) {
        map.removeSource('vectorsource');
    }
    map.addSource('vectorsource', {
        type: 'vector',
        url: tileset
    });
    map.addLayer({
        id: 'vector',
        type: 'line',
        source: 'vectorsource',
        'source-layer': tilesetvectorsource,
        'paint': {
            'line-color': [
                'case',
                ['==', ['get', 'TYPE'], '1'],
                [
                    'interpolate',
                    ['linear'],
                    ['to-number', ['get', 'FLOODRISK']],
                    1, '#cccc00', // Darker yellow for 1
                    2, '#ff0000', // Red for 2
                    3, '#800080', // Purple for 3
                    4, '#000000', // Black for 4
                ],
                ['==', ['get', 'TYPE'], '2'],
                [
                    'interpolate',
                    ['linear'],
                    ['to-number', ['get', 'FLOODFCST']],
                    2, '#cccc00', // Darker yellow for 1
                    3, '#ff0000', // Red for 2
                    4, '#800080', // Purple for 3
                    5, '#000000', // Black for 4
                ],
                '#ADD8E6' // Default color if TYPE is not 1 or 2
            ],
            'line-width': [
                'interpolate',
                ['linear'],
                ['zoom'],
                0,
                ['case',
                    ['==', ['get', 'TYPE'], '1'], 1,
                    ['==', ['get', 'TYPE'], '2'], 2,
                    1 // Default width if TYPE is not 1 or 2
                ],
                10,
                ['case',
                    ['==', ['get', 'TYPE'], '1'], 4,
                    ['==', ['get', 'TYPE'], '2'], 6,
                    4 // Default width if TYPE is not 1 or 2
                ],
                15,
                ['case',
                    ['==', ['get', 'TYPE'], '1'], 8,
                    ['==', ['get', 'TYPE'], '2'], 12,
                    8 // Default width if TYPE is not 1 or 2
                ]
            ],
            'line-opacity': 1.0,
        },
    });
};

const addRasterLayer = () => {
    if (map.getLayer('raster')) {
        map.removeLayer('raster');
    }
    if (map.getSource('rastersource')) {
        map.removeSource('rastersource');
    }
    map.addSource('rastersource', {
        type: 'raster',
        url: tileset
    });
    const layer_def = {
        id: 'raster',
        type: 'raster',
        source: 'rastersource',
        paint: {
            'raster-opacity': 1.0,
        }
    };
    map.addLayer(layer_def, layerAbove);
};

const addRasterArrayLayer = (layer) => {
    // console.log('Adding raster array source:', tileset + tilesetsuffix);
    map.addSource('rastersource', {
        type: 'raster-array',
        url: tileset + tilesetsuffix
    });
    const layerVals = layers[layer];
    // console.log('Layer values:', layerVals);
    const layer_def = {
        id: layer,
        type: 'raster',
        //slot: 'bottom',
        source: 'rastersource',
        'source-layer': layerVals.layer,
        paint: {
            'raster-color-range': layerVals.color_range,
            'raster-color': getColorScale(layerVals.color_range),
            'raster-resampling': tilesetresampling,
            'raster-color-range-transition': { duration: 0 },
            'raster-opacity': 1.0,
            'raster-array-band': bandlist[0],
            'raster-emissive-strength': 1.0,
            'raster-fade-duration': 0
        },
        // minzoom: layerVals.minzoom,
        // maxzoom: layerVals.maxzoom,
    };
    console.log('Adding layer with definition:', layer_def);
    map.addLayer(layer_def, layerAbove);
    const element = document.getElementById(layer);
    updateLegendBar(layerVals.color_range);

    addParticles();
};

const removeParticles = () => {
    if (map.getLayer('particlelayer')) {
        map.removeLayer('particlelayer');
    }
    if (map.getSource('particlesource')) {
        map.removeSource('particlesource');
    }
};

const addParticles = () => {
    // console.log('Adding particles for layer:', particlelayerid);
    if (particlelayerid) {
        const particlesource = {
            id: 'particlesource',
            type: 'raster-array',
            url: tileset,
            maxzoom: 16
        };
        map.addSource('particlesource', particlesource);
        const particlelayer = {
            'id': 'particlelayer',
            'type': 'raster-particle',
            'source': 'particlesource',
            'source-layer': particlelayerid,
            'slot': 'top',
            'layout': {},
            'paint': {
                'raster-particle-max-speed': 10,
                'raster-particle-fade-opacity-factor': 0.90,
                'raster-particle-reset-rate-factor': 0.4,
                'raster-resampling': 'bilinear',
            },
            'minzoom': 0,
            'maxzoom': 22,
        };
        map.addLayer(particlelayer, layerAbove);
        let particleCount = 1000;
        document.getElementById('particle-count-slider').value = particleCount;
        setParticleCount(particleCount);

        let particleSpeed = 0.08;
        document.getElementById('particle-speed-slider').value = particleSpeed;
        setParticleSpeed(particleSpeed);

        let particleColor = '#ffffff';
        document.getElementById('particle-color').value = particleColor;
        setParticleColor(particleColor);
    }
};

function showWind(elem) {
    if (elem.checked) {
        document.getElementById('particle-options').style.display = 'block';
        addParticles();
    } else {
        document.getElementById('particle-options').style.display = 'none';
        removeParticles();
    }
}
document.showWind = showWind;

let autoFlag = false;
const autoUpdate = () => {
    if (!autoFlag) return;
    const slider = document.getElementById('slider');
    let index = slider.value;
    index++;
    if (index > bandlist.length - 1) {
        index = 0;
    }
    slider.value = index;

    var inputEvent = new Event('input', {
        bubbles: true,
        cancelable: true
    });

    slider.dispatchEvent(inputEvent);

    setTimeout(autoUpdate, 1000);
};

function play() {
    const auto = document.getElementById('auto');
    if (auto.innerHTML === 'Play') {
        autoFlag = true;
        autoUpdate();
        auto.innerHTML = 'Stop';
        auto.style.backgroundColor = '#f44336';
    } else {
        autoFlag = false;
        auto.innerHTML = 'Play';
        auto.style.backgroundColor = '#4CAF50';
    }
}
window.play = play;

const setParticleCount = (val) => {
    document.getElementById('particle-count').innerHTML = val;
    map.setPaintProperty('particlelayer', 'raster-particle-count', Number(val));
};
document.setParticleCount = setParticleCount;

const setParticleSpeed = (val) => {
    document.getElementById('particle-speed').innerHTML = val;
    map.setPaintProperty('particlelayer', 'raster-particle-speed-factor', Number(val));
};
document.setParticleSpeed = setParticleSpeed;

const setParticleColor = (val) => {
    // const color = [
    //     "interpolate",
    //     ["linear"],
    //     ["raster-particle-speed"],
    //     0, "rgba(0,0,0,0)",
    //     10, val
    // ]
    color = val;
    map.setPaintProperty('particlelayer', 'raster-particle-color', color);
};
document.setParticleColor = setParticleColor;
  // Converted from TypeScript to JavaScript

const roundToNearestFive = (date) => {
    const minutes = date.getMinutes();
    const roundedMinutes = Math.floor(minutes / 5) * 5;
    date.setMinutes(roundedMinutes);
    return date;
};

const getTimeWithOffset = (baseDate, offsetMinutes) => {
    const utc = baseDate.getTime(); // in ms
    const adjusted = utc + offsetMinutes * 60 * 1000;
    return new Date(adjusted);
};

const formatTimeWithOffset = (baseDate, offsetMinutes) => {
    const newDate = getTimeWithOffset(baseDate, offsetMinutes);
    const jstDate = new Date(newDate.getTime() + 9 * 60 * 60 * 1000);
    return `${jstDate.getUTCHours().toString().padStart(2, '0')}:${jstDate.getUTCMinutes().toString().padStart(2, '0')}`;
};

const parseDateString = (dateString) => {
    const year = parseInt(dateString.slice(0, 4), 10);
    const month = parseInt(dateString.slice(4, 6), 10) - 1;
    const day = parseInt(dateString.slice(6, 8), 10);
    const hour = parseInt(dateString.slice(8, 10), 10);
    const minute = parseInt(dateString.slice(10, 12), 10);
    const second = parseInt(dateString.slice(12, 14), 10);
    return new Date(Date.UTC(year, month, day, hour, minute, second));
};

const parseDateStringJST = (dateString) => {
  const year = parseInt(dateString.slice(0, 4), 10);
  const month = parseInt(dateString.slice(4, 6), 10) - 1;
  const day = parseInt(dateString.slice(6, 8), 10);
  const hour = parseInt(dateString.slice(8, 10), 10);
  const minute = parseInt(dateString.slice(10, 12), 10);
  const second = parseInt(dateString.slice(12, 14), 10);
  return new Date(Date.UTC(year, month, day, hour - 9, minute, second));
};

const convertToJST = (date) => {
    const jstTimestamp = date.getTime() + (9 * 60 * 60 * 1000);
    return new Date(jstTimestamp);
};

const convertToUTC = (date) => {
    const utcTimestamp = date.getTime() - (9 * 60 * 60 * 1000);
    return new Date(utcTimestamp);
};

const formatDateString = (date) => {
    const yyyy = date.getUTCFullYear().toString();
    const MM = (date.getUTCMonth() + 1).toString().padStart(2, '0');
    const dd = date.getUTCDate().toString().padStart(2, '0');
    const HH = date.getUTCHours().toString().padStart(2, '0');
    const mm = date.getUTCMinutes().toString().padStart(2, '0');
    const ss = date.getUTCSeconds().toString().padStart(2, '0');
    return `${yyyy}${MM}${dd}${HH}${mm}${ss}`;
};

const toJST = (unixTimestamp, conversion=true) => {
    let date = new Date(unixTimestamp * 1000);
    if(conversion) {
        date = convertToJST(date);
    }
    return formatDateString(date);
};

const toUTC = (JSTyyyyMMddHHmmSS) => {
    const jstDate = parseDateString(JSTyyyyMMddHHmmSS);
    const utcDate = convertToUTC(jstDate);
    return formatDateString(utcDate);
};

const utcStringToJST = (utcyyyyMMddHHmmSS) => {
    const utcDate = parseDateString(utcyyyyMMddHHmmSS);
    const jstDate = convertToJST(utcDate);
    return formatDateString(jstDate);
};

const jstStringToUnixTimestamp = (JSTyyyyMMddHHmmSS) => {
    const jstDate = parseDateString(JSTyyyyMMddHHmmSS);
    const utcDate = convertToUTC(jstDate);
    return Math.floor(utcDate.getTime() / 1000);
};

const getLastHalfOrExactHour = (input, isUTC) => {
    let date = parseDateString(input);
    if (!isUTC) {
        date = convertToUTC(date);
    }
    if (date.getUTCMinutes() >= 30) {
        date.setUTCMinutes(30, 0, 0);
    } else {
        date.setUTCMinutes(0, 0, 0);
    }
    if (!isUTC) {
        date = convertToJST(date);
    }
    return formatDateString(date);
};

const getLastExactHour = (input, isUTC) => {
    let date = parseDateString(input);
    if (!isUTC) {
        date = convertToUTC(date);
    }
    date.setUTCMinutes(0, 0, 0);
    if (!isUTC) {
        date = convertToJST(date);
    }
    return formatDateString(date);
};

const datetimeToJapanese = (datetime) => {
    const dateObj = parseDateStringJST(datetime);
    const year = dateObj.getFullYear();
    const month = dateObj.getMonth() + 1;
    const day = dateObj.getDate();
    const hour = dateObj.getHours().toString().padStart(2, '0');
    const minute = dateObj.getMinutes().toString().padStart(2, '0');
    return `${year}年${month}月${day}日 ${hour}:${minute}時点`;
};

class TimeManager {
    constructor(JSTyyyyMMddHHmmSS) {
        this.baseDate = roundToNearestFive(parseDateStringJST(JSTyyyyMMddHHmmSS));
        this.refDate = new Date(this.baseDate);
    }

    setBaseDate(yyyyMMddHHmmSS) {
        this.baseDate = roundToNearestFive(parseDateStringJST(yyyyMMddHHmmSS));
        this.refDate = new Date(this.baseDate);
    }

    getMinutesDifference() {
        const diffInMilliseconds = this.refDate.getTime() - this.baseDate.getTime();
        return Math.floor(diffInMilliseconds / (1000 * 60));
    }

    getPastPresentFuture() {
        return '';
        const timeDiff = this.getMinutesDifference();
        if (timeDiff > 1) return '（予想）';
        else if (timeDiff < -1) return '（時点）';
        else return '（現在）';
    }

    updateTimeByOffset(offsetMinutes) {
        this.refDate = getTimeWithOffset(this.baseDate, offsetMinutes);
    }

    getFormattedDateTime() {
        const jstDate = new Date(this.refDate.getTime() + 9 * 60 * 60 * 1000);
        return `${(jstDate.getUTCMonth() + 1)}月 ${jstDate.getUTCDate()}日 ${formatTimeWithOffset(this.refDate, 0)} ${this.getPastPresentFuture()}`;
    }

    getFormattedTime(offsetMinutes = 0) {
        return formatTimeWithOffset(this.baseDate, offsetMinutes);
    }

    getyyyyMMddHHmmSS(offsetMinutes = 0) {
        const date = getTimeWithOffset(this.baseDate, offsetMinutes);
        const jstDate = new Date(date.getTime() + 9 * 60 * 60 * 1000);
        const year = jstDate.getUTCFullYear();
        const month = (jstDate.getUTCMonth() + 1).toString().padStart(2, '0');
        const day = jstDate.getUTCDate().toString().padStart(2, '0');
        const hour = jstDate.getUTCHours().toString().padStart(2, '0');
        const minute = jstDate.getUTCMinutes().toString().padStart(2, '0');
        const second = jstDate.getUTCSeconds().toString().padStart(2, '0');
        return `${year}${month}${day}${hour}${minute}${second}`;
    }

    getRefyyyyMMddHHmmSS() {
        const jstDate = new Date(this.refDate.getTime() + 9 * 60 * 60 * 1000);
        const year = jstDate.getUTCFullYear();
        const month = (jstDate.getUTCMonth() + 1).toString().padStart(2, '0');
        const day = jstDate.getUTCDate().toString().padStart(2, '0');
        const hour = jstDate.getUTCHours().toString().padStart(2, '0');
        const minute = jstDate.getUTCMinutes().toString().padStart(2, '0');
        const second = jstDate.getUTCSeconds().toString().padStart(2, '0');
        return `${year}${month}${day}${hour}${minute}${second}`;
    }

    getHHmm() {
        return formatTimeWithOffset(this.refDate, 0);
    }

    isPast(yyyyMMddHHmmSS) {
        return Number(yyyyMMddHHmmSS) < Number(this.getyyyyMMddHHmmSS());
    }

    isCurrent(yyyyMMddHHmmSS) {
        return Number(yyyyMMddHHmmSS) === Number(this.getyyyyMMddHHmmSS());
    }

    isCurrentOrPast(yyyyMMddHHmmSS) {
        return this.isCurrent(yyyyMMddHHmmSS) || this.isPast(yyyyMMddHHmmSS);
    }

    getOffsetMinutes(yyyyMMddHHmmSS) {
        const date = parseDateStringJST(yyyyMMddHHmmSS);
        const diffInMilliseconds = date.getTime() - this.baseDate.getTime();
        return Math.floor(diffInMilliseconds / (1000 * 60));
    }
}

window.TimeManager = TimeManager;
window.toJST = toJST;
window.toUTC = toUTC;
window.utcStringToJST = utcStringToJST;
window.jstStringToUnixTimestamp = jstStringToUnixTimestamp;
window.getLastHalfOrExactHour = getLastHalfOrExactHour;
window.getLastExactHour = getLastExactHour;
window.datetimeToJapanese = datetimeToJapanese;
function convertTimeValue(timeValue) {
    // Check if timeValue is a string (band name) rather than a numeric time value
    if (typeof timeValue === 'string' && isNaN(Number(timeValue))) {
        return '  '; // Return two spaces so split(' ') produces valid array
    }

    const dateString = toJST(timeValue, false)
    const year = dateString.substring(0, 4);
    const month = dateString.substring(4, 6);
    const day = dateString.substring(6, 8);
    const hour = dateString.substring(8, 10);
    const minute = dateString.substring(10, 12);
    const second = dateString.substring(12, 14);
    const date = new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}Z`);
    const options = {
        timeZone: 'Asia/Tokyo',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false, // Use 24-hour format
    };
    const formatter = new Intl.DateTimeFormat('ja-JP', options);
    const parts = formatter.formatToParts(date);
    const formattedDate = `${parts.find(p => p.type === 'year').value}/` +
        `${parts.find(p => p.type === 'month').value}/` +
        `${parts.find(p => p.type === 'day').value} ` +
        `${parts.find(p => p.type === 'hour').value}:` +
        `${parts.find(p => p.type === 'minute').value}`;
    return formattedDate;
}
</script>

</html>