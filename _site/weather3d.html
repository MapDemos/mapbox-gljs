<html lang="ja">

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-language/v1.0.0/mapbox-gl-language.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/d3@7.8.5/dist/d3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.min.js"></script>
<link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.2/mapbox-gl-geocoder.css" type="text/css" />
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
<script src="https://kenji-shima.github.io/resource-files/polyline.js" type="module"></script>
<script src="https://kenji-shima.github.io/resource-files/utils.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.min.js" type="text/javascript"></script>
  <link href="https://cdn.jsdelivr.net/gh/jscastro76/threebox@v.2.2.2/dist/threebox.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  
  <style>
    * {
  box-sizing: border-box;
}

table {
  border-collapse: collapse;
  width: 100%;
}

td,
th {
  border: 1px solid black;
  text-align: left;
  padding: 8px;
}

th {
  background-color: #f2f2f2;
}

h1 {
  font-size: 22px;
  margin: 0;
  font-weight: 400;
  line-height: 20px;
  padding: 20px 2px;
}

a {
  color: red;
  text-decoration: underline;
  cursor: pointer;
  font: 400 14px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
}

.map {
  position: absolute;
  /*left: 20%;*/
  width: 100%;
  top: 0;
  bottom: 0;
}

::-webkit-scrollbar {
  width: 3px;
  height: 3px;
  border-left: 0;
  background: rgba(0, 0, 0, 0.1);
}

::-webkit-scrollbar-track {
  background: none;
}

::-webkit-scrollbar-thumb {
  background: #fff;
  border-radius: 0;
}

.map-overlay-right {
  position: absolute;
  top: 20px;
  right: 20px;
  opacity: 0.8;
  background-color: black;
  color: white;
  opacity: 0.8;
  text-align: left;
  overflow: auto;
  border-radius: 3px;
  padding: 10px;
  font: 400 12px/22px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
  animation: slide-up 1s;
}

.title {
  font-weight: bold;
}

@keyframes slide-up {
  from {
    transform: translateY(100%);
  }

  to {
    transform: translateY(0%);
  }
}

@keyframes slide-right {
  from {
    transform: translateX(-100%);
  }

  to {
    transform: translateX(0%);
  }
}

a.boxclose {
  float: right;
  cursor: pointer;
  display: block;
  box-sizing: border-box;
  width: 20px;
  height: 20px;
  border-width: 3px;
  border-style: solid;
  border-color: #605F61;
  border-radius: 100%;
  background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%);
  background-color: #605F61;
  box-shadow: 0px 0px 5px 2px rgba(0, 0, 0, 0.5);
  transition: all 0.3s ease;
}

h3 {
  /*background: #0076D1;
  color: #fff;*/
  margin: 0;
  padding: 10px;
  border-radius: 3px 3px 0 0;
  font-weight: 700;
  /*margin-top: -15px;*/
}

body,
html {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  font-family: 'Open Sans', sans-serif;
  color: red;
}

h1 {
  margin: 0;
  position: relative;
  top: 50%;
  left: 0;
  right: 0;
  transform: translateY(-50%);
  text-align: center;
  font-size: 40px;
}

.map-overlay-legend {
  position: absolute;
  opacity: 0.8;
  top: 30;
  right: 0;
  background: #fff;
  margin-right: 20px;
  overflow: auto;
  border-radius: 3px;
  width: 300px;
  padding: 10px;
  font: 400 12px/22px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
  transition: transform .5s ease-in-out;
}

.mapboxgl-popup {
  padding-bottom: 10px;
  opacity: 0.8;
  width: 500px;
}

.mapboxgl-popup-content {
  padding-bottom: 10px;
  opacity: 0.8;
  width: fit-content;
}

.marker {
  border: none;
  cursor: pointer;
  height: 56px;
  width: 56px;
  background-image: url(../images/alert.png);
}

.blinking {
  -webkit-animation: blink .5s ease-in-out infinite alternate;
  -moz-animation: blink .5s ease-in-out infinite alternate;
  animation: blink .5s ease-in-out infinite alternate;
}

@-webkit-keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@-moz-keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes blink {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

a.replay {
  color: blue;
  text-decoration: underline;
  cursor: pointer;
  font: 400 18px 'Source Sans Pro', 'Helvetica Neue', sans-serif;
}


.legend {
  position: absolute;
  bottom: 120px;
  right: 40px;
  background: black;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
  z-index: 1;
  width: 50%;
  opacity: 0.8;
}

.legend-title {
  font-size: 14px;
  text-align: center;
  margin-bottom: 5px;
  color: #000000;
}

.legend-scale {
  text-align: center;
}

.legend-bar {
  position: relative;
  height: 30px;
  background: linear-gradient(to right,
      rgba(80, 74, 154, 1),
      rgba(84, 172, 162, 1),
      rgba(193, 228, 148, 1),
      rgba(252, 244, 162, 1),
      rgba(251, 166, 91, 1),
      rgba(216, 66, 65, 1),
      rgba(143, 3, 58, 1));
  border: 1px solid #999;
  border-radius: 3px;
  margin-bottom: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 5px;
}

.label {
  font-size: 12px;
  color: #fff;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

.hidden {
  display: none;
}

.map-overlay-bottom {
  position: absolute;
  bottom: 30px;
  right: 20px;
  left: 20px;
  background-color: black;
  color: white;
  opacity: 0.8;
  margin-right: 20px;
  font-family: Arial, sans-serif;
  overflow: auto;
  border-radius: 3px;
  padding: 10px;
  height: 80px;
}
.slider {
  position: relative;
  top: 20px;
  width: 100%;
}
.time {
  display: flex;
  justify-content: space-between;
  position: relative;
  width: 100%;
  top: 10px;
}
.time span {
  font-size: 12px;
  text-align: center;
}

#active-datetime {
  font-size: 14px;
  width: 100%;
  position: relative;
}

button {
  height: 14px;
  padding: 0 10px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 10px;
}

button:hover {
  background-color: #45a049;
}
    :root {
    --clock-icon: url("https://www.google.com/imgres?q=clock%20image&imgurl=https%3A%2F%2Fmedia.istockphoto.com%2Fid%2F931336618%2Fvector%2Fclock-vector-icon-isolated.jpg%3Fs%3D612x612%26w%3D0%26k%3D20%26c%3DI8EBJl8i6olqcrhAtKko74ydFEVbfCQ6s5Pbsx6vfas%3D&imgrefurl=https%3A%2F%2Fwww.istockphoto.com%2Fillustrations%2Fclock-clipart&docid=MUgeI1-l6LyZcM&tbnid=L1e9OAP6nyEPtM&vet=12ahUKEwjHtaCTrPaNAxUblK8BHahhPJMQM3oECBwQAA..i&w=612&h=612&hcb=2&ved=2ahUKEwjHtaCTrPaNAxUblK8BHahhPJMQM3oECBwQAA");
}

.city-panel {
    display: flex;
    flex-direction: row;
    gap: 10px;
    z-index: 1000;
    background-color: black;
    opacity: 0.95;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    width: auto;
    max-width: 95%;
    overflow-y: auto;
}

.city-box {
    background-color: rgba(255, 255, 255, 1);
    border-radius: 8px;
    padding: 5px 10px;
    font-size: 11px;
    color: #333;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    min-height: 60px;
    min-width: 60px;
    text-align: center;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 0 0 auto;
}

.weather-icon {
    width: 24px;
    height: 24px;
    display: block;
    margin: 6px auto;
}

#mini-map {
    width: 80px;
    height: 80px;
    border-radius: 8px;
    border: 2px solid white;
    overflow: hidden;
    cursor: pointer;
    flex-shrink: 0;
}

.city-header {
    position: absolute;
    top: 10px;
    left: 5px;
    right: 5px;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 10px;
    z-index: 1000;
}

.legend {
  position: absolute;
  bottom: 35px;
  right: 5px;
  background: black;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
  z-index: 1;
  max-width: 50%;
  width: 250px;
  opacity: 0.8;
}

.area-panel {
  position: absolute;
  top: 100px;
  right: 5px;
  padding: 5px 10px;
  border-radius: 6px;
  background-color: white;
  opacity: 0.85;
  align-items: center;
  color: #333;
  font-size: 14px;
  gap: 8px;
  z-index: 1000;
  display: none;
}

.time-panel {
  position: absolute;
  top: 100px;
  left: 5px;
  right: 5px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: flex-start;
  z-index: 1000;
}

.time-box {
  background-color: white;
  opacity: 0.90;
  padding: 10px;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  color: #333;
  font-size: 12px;
}

.map-slider-container {
  background-color: black;
  color: white;
  opacity: 0.8;
  font-family: Arial, sans-serif;
  border-radius: 3px;
  padding: 10px;
  height: 30px;
  display: flex;
  align-items: center;
}

.time-slider {
    position: relative;
    width: 80%;
}

input[type=range] {
    -webkit-appearance: none;
    /* Hides the slider so we can custom-style it */
    appearance: none;
    width: 100%;
    /* Full-width */
    background: transparent;
    /* Otherwise white in Chrome */
    cursor: pointer;
}

/* * Style for the slider thumb (the handle) for WebKit browsers (Chrome, Safari, Opera, etc.) 
         */
input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    /* Override default look */
    appearance: none;
    margin-top: -12px;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 24 24' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23000'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E");
    background-size: cover;
    /* Ensure the image covers the thumb area */
    height: 20px;
    width: 20px;
    border-radius: 50%;
    /* Makes the thumb circular if desired */
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

/* * Style for the slider thumb for Firefox
         */
input[type=range]::-moz-range-thumb {
    /* --- YOUR IMAGE STYLES HERE --- */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 24 24' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23000'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E");
    background-size: cover;
    height: 20px;
    width: 20px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}

/* * Style for the slider track for WebKit browsers
         */
input[type=range]::-webkit-slider-runnable-track {
    width: 100%;
    height: 4px;
    background: #fff;
    /* Purple track color */
    border-radius: 9999px;
    /* Fully rounded ends */
    border: 2px solid #fff;
}

/* * Style for the slider track for Firefox
         */
input[type=range]::-moz-range-track {
    width: 100%;
    height: 4px;
    background: #fff;
    border-radius: 9999px;
    border: 2px solid #fff;
}

/* Removes the focus outline, you can customize this for accessibility */
input[type=range]:focus {
    outline: none;
}

.precipitation-chart {
  position: absolute;
  bottom: 35px;
  right: 5px;
  width: 600px;
  max-width: 95%;
  background-color: white;
  padding: 2px;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  display: none;
  opacity: 0.7;
}

.apexcharts-canvas {
  font-family: Arial, sans-serif !important;
}

.apexcharts-tooltip {
  font-size: 12px !important;
  background: rgba(0, 0, 0, 1) !important;
  color: white !important;
  border-radius: 4px !important;
  padding: 6px 10px !important;
}

.apexcharts-tooltip-title {
  background-color: black !important;
  color: white !important;
  font-weight: bold;
}

.apexcharts-xaxis-label,
.apexcharts-yaxis-label {
  font-size: 10px;
  fill: #333;
}
</style>
</head>

<body>
  <div id="map" class="map"></div>
  <div class="city-header">
    <div id="mini-map"></div>
    <div id="city-panel" class="city-panel"></div>
  </div>
  <div id="area-panel" class="area-panel">
    <div id="geo-name"></div>
    <div id="geo-weather"></div>
  </div>
  <div class="time-panel">
    <div id="current-time" class="time-box">--</div>
    <div class="map-slider-container">
        <input type="range" min="0" step="1" value="0" max="5" class="time-slider" id="slider" oninput="inputBand(this.value)" onchange="changeBand()" />
    </div>
  </div>
  <div id="precipitation-chart" class="precipitation-chart"></div>
  <div id="legend" class="legend">
    <div class="legend-scale">
        <div class="legend-bar"></div>
    </div>
</div>
  

</body>
<script>
  // Converted from TypeScript to JavaScript

const roundToNearestFive = (date) => {
    const minutes = date.getMinutes();
    const roundedMinutes = Math.floor(minutes / 5) * 5;
    date.setMinutes(roundedMinutes);
    return date;
};

const getTimeWithOffset = (baseDate, offsetMinutes) => {
    const utc = baseDate.getTime(); // in ms
    const adjusted = utc + offsetMinutes * 60 * 1000;
    return new Date(adjusted);
};

const formatTimeWithOffset = (baseDate, offsetMinutes) => {
    const newDate = getTimeWithOffset(baseDate, offsetMinutes);
    const jstDate = new Date(newDate.getTime() + 9 * 60 * 60 * 1000);
    return `${jstDate.getUTCHours().toString().padStart(2, '0')}:${jstDate.getUTCMinutes().toString().padStart(2, '0')}`;
};

const parseDateString = (dateString) => {
    const year = parseInt(dateString.slice(0, 4), 10);
    const month = parseInt(dateString.slice(4, 6), 10) - 1;
    const day = parseInt(dateString.slice(6, 8), 10);
    const hour = parseInt(dateString.slice(8, 10), 10);
    const minute = parseInt(dateString.slice(10, 12), 10);
    const second = parseInt(dateString.slice(12, 14), 10);
    return new Date(Date.UTC(year, month, day, hour, minute, second));
};

const parseDateStringJST = (dateString) => {
  const year = parseInt(dateString.slice(0, 4), 10);
  const month = parseInt(dateString.slice(4, 6), 10) - 1;
  const day = parseInt(dateString.slice(6, 8), 10);
  const hour = parseInt(dateString.slice(8, 10), 10);
  const minute = parseInt(dateString.slice(10, 12), 10);
  const second = parseInt(dateString.slice(12, 14), 10);
  return new Date(Date.UTC(year, month, day, hour - 9, minute, second));
};

const convertToJST = (date) => {
    const jstTimestamp = date.getTime() + (9 * 60 * 60 * 1000);
    return new Date(jstTimestamp);
};

const convertToUTC = (date) => {
    const utcTimestamp = date.getTime() - (9 * 60 * 60 * 1000);
    return new Date(utcTimestamp);
};

const formatDateString = (date) => {
    const yyyy = date.getUTCFullYear().toString();
    const MM = (date.getUTCMonth() + 1).toString().padStart(2, '0');
    const dd = date.getUTCDate().toString().padStart(2, '0');
    const HH = date.getUTCHours().toString().padStart(2, '0');
    const mm = date.getUTCMinutes().toString().padStart(2, '0');
    const ss = date.getUTCSeconds().toString().padStart(2, '0');
    return `${yyyy}${MM}${dd}${HH}${mm}${ss}`;
};

const toJST = (unixTimestamp) => {
    const date = new Date(unixTimestamp * 1000);
    const jstDate = convertToJST(date);
    return formatDateString(jstDate);
};

const toUTC = (JSTyyyyMMddHHmmSS) => {
    const jstDate = parseDateString(JSTyyyyMMddHHmmSS);
    const utcDate = convertToUTC(jstDate);
    return formatDateString(utcDate);
};

const utcStringToJST = (utcyyyyMMddHHmmSS) => {
    const utcDate = parseDateString(utcyyyyMMddHHmmSS);
    const jstDate = convertToJST(utcDate);
    return formatDateString(jstDate);
};

const jstStringToUnixTimestamp = (JSTyyyyMMddHHmmSS) => {
    const jstDate = parseDateString(JSTyyyyMMddHHmmSS);
    const utcDate = convertToUTC(jstDate);
    return Math.floor(utcDate.getTime() / 1000);
};

const getLastHalfOrExactHour = (input, isUTC) => {
    let date = parseDateString(input);
    if (!isUTC) {
        date = convertToUTC(date);
    }
    if (date.getUTCMinutes() >= 30) {
        date.setUTCMinutes(30, 0, 0);
    } else {
        date.setUTCMinutes(0, 0, 0);
    }
    if (!isUTC) {
        date = convertToJST(date);
    }
    return formatDateString(date);
};

const getLastExactHour = (input, isUTC) => {
    let date = parseDateString(input);
    if (!isUTC) {
        date = convertToUTC(date);
    }
    date.setUTCMinutes(0, 0, 0);
    if (!isUTC) {
        date = convertToJST(date);
    }
    return formatDateString(date);
};

const datetimeToJapanese = (datetime) => {
    const dateObj = parseDateStringJST(datetime);
    const year = dateObj.getFullYear();
    const month = dateObj.getMonth() + 1;
    const day = dateObj.getDate();
    const hour = dateObj.getHours().toString().padStart(2, '0');
    const minute = dateObj.getMinutes().toString().padStart(2, '0');
    return `${year}年${month}月${day}日 ${hour}:${minute}時点`;
};

class TimeManager {
    constructor(JSTyyyyMMddHHmmSS) {
        this.baseDate = roundToNearestFive(parseDateStringJST(JSTyyyyMMddHHmmSS));
        this.refDate = new Date(this.baseDate);
    }

    setBaseDate(yyyyMMddHHmmSS) {
        this.baseDate = roundToNearestFive(parseDateStringJST(yyyyMMddHHmmSS));
        this.refDate = new Date(this.baseDate);
    }

    getMinutesDifference() {
        const diffInMilliseconds = this.refDate.getTime() - this.baseDate.getTime();
        return Math.floor(diffInMilliseconds / (1000 * 60));
    }

    getPastPresentFuture() {
        return ''
        const timeDiff = this.getMinutesDifference();
        if (timeDiff > 1) return '（予想）';
        else if (timeDiff < -1) return '（時点）';
        else return '（現在）';
    }

    updateTimeByOffset(offsetMinutes) {
        this.refDate = getTimeWithOffset(this.baseDate, offsetMinutes);
    }

    getFormattedDateTime() {
        const jstDate = new Date(this.refDate.getTime() + 9 * 60 * 60 * 1000);
        return `${(jstDate.getUTCMonth() + 1)}月 ${jstDate.getUTCDate()}日 ${formatTimeWithOffset(this.refDate, 0)} ${this.getPastPresentFuture()}`;
    }

    getFormattedTime(offsetMinutes = 0) {
        return formatTimeWithOffset(this.baseDate, offsetMinutes);
    }

    getyyyyMMddHHmmSS(offsetMinutes = 0) {
        const date = getTimeWithOffset(this.baseDate, offsetMinutes);
        const jstDate = new Date(date.getTime() + 9 * 60 * 60 * 1000);
        const year = jstDate.getUTCFullYear();
        const month = (jstDate.getUTCMonth() + 1).toString().padStart(2, '0');
        const day = jstDate.getUTCDate().toString().padStart(2, '0');
        const hour = jstDate.getUTCHours().toString().padStart(2, '0');
        const minute = jstDate.getUTCMinutes().toString().padStart(2, '0');
        const second = jstDate.getUTCSeconds().toString().padStart(2, '0');
        return `${year}${month}${day}${hour}${minute}${second}`;
    }

    getRefyyyyMMddHHmmSS() {
        const jstDate = new Date(this.refDate.getTime() + 9 * 60 * 60 * 1000);
        const year = jstDate.getUTCFullYear();
        const month = (jstDate.getUTCMonth() + 1).toString().padStart(2, '0');
        const day = jstDate.getUTCDate().toString().padStart(2, '0');
        const hour = jstDate.getUTCHours().toString().padStart(2, '0');
        const minute = jstDate.getUTCMinutes().toString().padStart(2, '0');
        const second = jstDate.getUTCSeconds().toString().padStart(2, '0');
        return `${year}${month}${day}${hour}${minute}${second}`;
    }

    getHHmm() {
        return formatTimeWithOffset(this.refDate, 0);
    }

    isPast(yyyyMMddHHmmSS) {
        return Number(yyyyMMddHHmmSS) < Number(this.getyyyyMMddHHmmSS());
    }

    isCurrent(yyyyMMddHHmmSS) {
        return Number(yyyyMMddHHmmSS) === Number(this.getyyyyMMddHHmmSS());
    }

    isCurrentOrPast(yyyyMMddHHmmSS) {
        return this.isCurrent(yyyyMMddHHmmSS) || this.isPast(yyyyMMddHHmmSS);
    }

    getOffsetMinutes(yyyyMMddHHmmSS) {
        const date = parseDateStringJST(yyyyMMddHHmmSS);
        const diffInMilliseconds = date.getTime() - this.baseDate.getTime();
        return Math.floor(diffInMilliseconds / (1000 * 60));
    }
}

// window.TimeManager = TimeManager;
// window.toJST = toJST;
// window.toUTC = toUTC;
// window.utcStringToJST = utcStringToJST;
// window.jstStringToUnixTimestamp = jstStringToUnixTimestamp;
// window.getLastHalfOrExactHour = getLastHalfOrExactHour;
// window.getLastExactHour = getLastExactHour;
// window.datetimeToJapanese = datetimeToJapanese;
  const precipitationColorScale = () => {
    const domain = [2, 5, 10, 20, 30, 50, 80];
    const range = [
        "rgba(102, 255, 255, 0.8)",
        "rgba(0, 204, 255, 0.8)",
        "rgba(51, 102, 255, 0.8)",
        "rgba(255, 204, 0, 0.8)",
        "rgba(255, 153, 0, 0.8)",
        "rgba(255, 0, 0, 0.8)",
        "rgba(183, 0, 16, 0.8)"
    ];

    // const domain = [0, 1, 4, 8, 12, 16, 24, 32, 40, 48, 56, 64, 80, 200];
    // const range = [
    //     "rgba(204, 255, 255, 0.0)",
    //     "rgba(102, 255, 255, 0.0)",
    //     "rgba(0, 204, 255, 0.8)",
    //     "rgba(0, 153, 255, 0.8)",
    //     "rgba(51, 102, 255, 0.8)",
    //     "rgba(51, 255, 0, 0.8)",
    //     "rgba(51, 204, 0, 0.8)",
    //     "rgba(25, 153, 0, 0.8)",
    //     "rgba(255, 255, 0, 0.8)",
    //     "rgba(255, 204, 0, 0.8)",
    //     "rgba(255, 153, 0, 0.8)",
    //     "rgba(255, 80, 102, 0.8)",
    //     "rgba(255, 0, 0, 0.8)",
    //     "rgba(183, 0, 16, 0.8)"
    // ]

    let result = domain.map((v, i) => [v, range[i]]).flat();
    result.unshift("rgba(0, 0, 0, 0)");
    return result;
};

class PrecipitationLayerHelper {
    map;
    currentVisibleLayer = '';
    currentVisibleBand = '';
    precipitation_tiles = {};
    belt_tiles = {};
    timeManager;

    constructor(map, timeManager) {
        this.map = map;
        this.timeManager = timeManager;
    }

    checkAllSourcesLoaded() {
        if (Object.keys(this.precipitation_tiles).length < 22) return false;
        return Object.values(this.precipitation_tiles).every(tile => tile.sourceLoaded);
    }

    getTilesetKeyAndTime(datetime) {
        let tileset_key = datetime;
        let tileset_time = datetime;
        const offsetMinutes = this.timeManager.getOffsetMinutes(datetime);

        if (!this.timeManager.isCurrentOrPast(datetime)) {
            if (offsetMinutes <= 60) {
                tileset_time = this.timeManager.getyyyyMMddHHmmSS(0);
            }
            if (offsetMinutes <= 30) {
                tileset_key = this.timeManager.getyyyyMMddHHmmSS(0);
            } else if (offsetMinutes > 30 && offsetMinutes <= 60) {
                tileset_key = this.timeManager.getyyyyMMddHHmmSS(30);
            } else {
                tileset_time = this.timeManager.getyyyyMMddHHmmSS(0);
            }
        }

        return [tileset_key, tileset_time];
    }

    getTilesetIdAndUrl(datetime, tileset_time) {
        const offsetMinutes = this.timeManager.getOffsetMinutes(datetime);
        let tileset_suffix = '-30m';
        let tileset_prefix = 'nowcast';

        if (!this.timeManager.isCurrentOrPast(datetime)) {
            if (offsetMinutes > 30 && offsetMinutes <= 60) {
                tileset_suffix = '-60m';
            } else if (offsetMinutes > 60 && offsetMinutes <= 360) {
                tileset_time = getLastHalfOrExactHour(tileset_time, false);
                tileset_prefix = 'forecast';
                tileset_suffix = '-6h';
            } else {
                tileset_time = getLastExactHour(tileset_time, false);
                tileset_prefix = 'forecast';
                tileset_suffix = '-15h';
            }
        }

        const tileset_id = `kenji-shima.${tileset_prefix}-${toUTC(tileset_time)}${tileset_suffix}`;
        const tileset_url = `mapbox://${tileset_id}`;
        return [tileset_id, tileset_url];
    }

    setBand(datetime, tileset_key, layer_key, band) {
        if (!this.precipitation_tiles[tileset_key].layers[layer_key]) {
            this.precipitation_tiles[tileset_key].layers[layer_key] = { bands: {} };
        }

        const bandJpTime = toJST(Number(band));

        if (this.timeManager.isPast(datetime)) {
            if (datetime === bandJpTime) {
                this.precipitation_tiles[tileset_key].layers[layer_key].bands[bandJpTime] = { val: band };
            }
        } else {
            const tileset_id = this.precipitation_tiles[tileset_key].tileset_id;
            if (tileset_id.includes('forecast') && tileset_id.includes('-6h')) {
                const oneHourLater = this.timeManager.getyyyyMMddHHmmSS(60);
                const firstBandOfForecast = getLastHalfOrExactHour(oneHourLater, false);
                if (firstBandOfForecast !== bandJpTime) {
                    this.precipitation_tiles[tileset_key].layers[layer_key].bands[bandJpTime] = { val: band };
                }
            } else {
                this.precipitation_tiles[tileset_key].layers[layer_key].bands[bandJpTime] = { val: band };
            }
        }
    }

    handlePrecipitationSourceDataLoaded(tileset_key, datetime) {
        if (this.map?.getLayer(tileset_key)) return;

        const source = this.map?.getSource(tileset_key);
        source.rasterLayers?.forEach((layer) => {
            const fields = layer.fields;
            if (fields) {
                const bands = fields.bands;
                bands?.forEach((band) => {
                    this.setBand(datetime, tileset_key, fields.name, band);
                });
                this.map?.addLayer({
                    id: tileset_key,
                    type: 'raster',
                    source: tileset_key,
                    'source-layer': fields.name,
                    paint: {
                        'raster-color-range': [0, 200],
                        'raster-color': ['step', ['raster-value'], ...precipitationColorScale()],
                        'raster-resampling': 'nearest',
                        'raster-color-range-transition': { duration: 0 },
                        'raster-opacity': 0.0,
                        'raster-array-band': bands[0],
                        'raster-emissive-strength': 1.0
                    },
                    maxzoom: 14.99,
                });
            }
        });

        this.precipitation_tiles[tileset_key].sourceLoaded = true;
    }

    stringifyError(err) {
        const props = Object.getOwnPropertyNames(err);
        let result = '';
        props.forEach(prop => {
            result += `${prop}: ${err[prop]}\n`;
        });
        return result;
    }

    addLayer(datetime) {
        const [tileset_key, tileset_time] = this.getTilesetKeyAndTime(datetime);

        if (this.map) {
            if (Object.keys(this.precipitation_tiles).includes(tileset_key)) return;

            const [tileset_id, tileset_url] = this.getTilesetIdAndUrl(datetime, tileset_time);
            this.precipitation_tiles[tileset_key] = {
                tileset_id: tileset_id,
                url: tileset_url,
                layers: {},
                sourceLoaded: false
            };

            if (!this.map.getSource(tileset_key)) {
                this.map.addSource(tileset_key, {
                    type: 'raster-array',
                    url: tileset_url
                });

                this.map.on('sourcedata', (e) => {
                    if (e.sourceId === tileset_key && e.isSourceLoaded) {
                        this.handlePrecipitationSourceDataLoaded(tileset_key, datetime);
                        console.log(`Precipitation layer added: ${tileset_key} at ${datetime}`, this.precipitation_tiles);
                    }
                });

                this.map.on('error', (e) => {
                    if (e.error.toString().startsWith('Error:  (404)')) {
                        console.log(e.error);
                    }
                });
            }
        }
    }

    visibleLayer(datetime) {
        if (this.map) {
            let tileset_key = datetime;
            let band_key = datetime;

            if (!this.timeManager.isCurrentOrPast(datetime)) {
                const offsetMinutes = this.timeManager.getOffsetMinutes(datetime);
                if (offsetMinutes <= 30) {
                    tileset_key = this.timeManager.getyyyyMMddHHmmSS(0);
                } else if (offsetMinutes > 30 && offsetMinutes <= 60) {
                    tileset_key = this.timeManager.getyyyyMMddHHmmSS(30);
                }
            }

            if (this.precipitation_tiles[tileset_key].sourceLoaded) {
                this.privateVisibleLayer(tileset_key, band_key);
            } else {
                this.map.once('sourcedata', (e) => {
                    if (e.sourceId === datetime && e.isSourceLoaded) {
                        this.privateVisibleLayer(tileset_key, band_key);
                    }
                });
            }
        }
    }

    privateVisibleLayer(tileset_key, band_key) {
        if (this.currentVisibleLayer === tileset_key && this.currentVisibleBand === band_key) {
            return;
        }

        const tileset = this.precipitation_tiles[tileset_key];

        if (tileset.tileset_id.includes('forecast')) {
            if (tileset.tileset_id.includes('6h')) {
                band_key = getLastHalfOrExactHour(band_key, false);
            } else if (tileset.tileset_id.includes('15h')) {
                band_key = getLastExactHour(band_key, false);
            }
        }

        let band = band_key;
        for (const layer in tileset.layers) {
            const bands = tileset.layers[layer].bands;
            band = bands[band_key] ? bands[band_key].val : band_key;
        }

        if (this.map) {
            if (this.currentVisibleLayer !== '') {
                this.map.setPaintProperty(this.currentVisibleLayer, 'raster-opacity', 0);
            }
            this.map.setPaintProperty(tileset_key, 'raster-opacity', 0.8);
            this.map.setPaintProperty(tileset_key, 'raster-array-band', band);
            this.currentVisibleLayer = tileset_key;
            this.currentVisibleBand = band;

            // console.log(`Visible layer set to: ${tileset_key} with band: ${band}`);
        }
    }

    clearAll() {
        for (const key in this.precipitation_tiles) {
            if (!this.map.getLayer(key)) continue;
            this.map.removeLayer(key);
            this.map.removeSource(key);
        }
        this.precipitation_tiles = {};

        for (const key in this.belt_tiles) {
            const tileset_id = this.belt_tiles[key].tileset_id;
            if (!this.map.getLayer(tileset_id)) continue;
            this.map.removeLayer(tileset_id);
            this.map.removeSource(tileset_id);
        }
        this.belt_tiles = {};
    }

    getPrecipitationTiles() {
        return this.precipitation_tiles;
    }
}
  const defaultCoordinates = [138.8876271433324, 38.36242938133822];

const cities = {
    'Sapporo': {
        coordinates: [141.35638473162078, 43.0610860864561],
        label: '札幌',
    },
    'Hakodate': {
        coordinates: [140.726146, 41.768793],
        label: '函館',
    },
    'Aomori': {
        coordinates: [140.74101080009962, 40.82973093604397],
        label: '青森',
    },
    'Morioka': {
        coordinates: [141.152683, 39.703619],
        label: '盛岡',
    },
    'Akita': {
        coordinates: [140.102384, 39.720007],
        label: '秋田',
    },
    'Sendai': {
        coordinates: [140.88140697482936, 38.2624351622911],
        label: '仙台',
    },
    'Niigata': {
        coordinates: [139.0433188097315, 37.922656261020975],
        label: '新潟',
    },
    'Kanazawa': {
        coordinates: [136.65827701776624, 36.56102863073599],
        label: '金沢',
    },
    'Tokyo': {
        coordinates: [139.76687407959213, 35.68123488811237],
        label: '東京',
    },
    'Yokohama': {
        coordinates: [139.62952923135003, 35.454898444738674],
        label: '横浜',
    },
    'Kawasaki': {
        coordinates: [139.69724429384019, 35.53278091882032],
        label: '川崎',
    },
    'Chiba': {
        coordinates: [140.123306, 35.607409],
        label: '千葉',
    },
    'Shizuoka': {
        coordinates: [138.38341396065834, 34.979465742494114],
        label: '静岡',
    },
    'Nagoya': {
        coordinates: [136.9082992254862, 35.17242940435324],
        label: '名古屋',
    },
    'Kyoto': {
        coordinates: [135.781970818716, 35.012937415842686],
        label: '京都',
    },
    'Osaka': {
        coordinates: [135.49893833814843, 34.70279801557176],
        label: '大阪',
    },
    'Kobe': {
        coordinates: [135.18856833278267, 34.683766915876504],
        label: '神戸',
    },
    'Okayama': {
        coordinates: [133.92666745933246, 34.6631527793071],
        label: '岡山',
    },
    'Hiroshima': {
        coordinates: [132.47504878481664, 34.39579664329516],
        label: '広島',
    },
    'Takamatsu': {
        coordinates: [134.04705771944793, 34.352717493450655],
        label: '高松',
    },
    'Matsuyama': {
        coordinates: [132.765736, 33.839157],
        label: '松山',
    },
    'Fukuoka': {
        coordinates: [130.3623852229087, 33.59516379302434],
        label: '福岡',
    },
    'Kumamoto': {
        coordinates: [130.70368427741442, 32.80021015491796],
        label: '熊本',
    },
    'Kagoshima': {
        coordinates: [130.5647776092315, 31.595973113134818],
        label: '鹿児島',
    },
    'Naha': {
        coordinates: [127.67920025197901, 26.213833753425405],
        label: '那覇',
    },
    'Miyakojima': {
        coordinates: [125.281667, 24.805556],
        label: '宮古島',
    },
    'Ishigaki': {
        coordinates: [124.157222, 24.340278],
        label: '石垣',
    }
}

function updateLegendBar() {
    const legend = document.querySelector('.legend-bar');
    if (!legend) return;

    const scale = precipitationColorScale();

    // Remove the first value if it's a fallback (like "rgba(0, 0, 0, 0)")
    const stops = typeof scale[0] === 'string' ? scale.slice(1) : scale;

    const valueColorPairs = [];
    for (let i = 0; i < stops.length; i += 2) {
        valueColorPairs.push({ val: stops[i], color: stops[i + 1] });
    }

    // Normalize positions between 0–100% for gradient stops
    const min = valueColorPairs[0].val;
    const max = valueColorPairs[valueColorPairs.length - 1].val;
    const gradientStops = valueColorPairs.map(({ val, color }) => {
        const percent = ((val - min) / (max - min)) * 100;
        return `${color} ${percent.toFixed(2)}%`;
    });

    legend.style.background = `linear-gradient(to right, ${gradientStops.join(', ')})`;

    // Optional: show tick labels below
    const ticks = document.querySelector('.legend-bar');
    if (ticks) {
        ticks.innerHTML = '';
        valueColorPairs.forEach(({ val }) => {
            const tick = document.createElement('span');
            tick.className = 'label';
            tick.textContent = val;
            tick.style = '';
            ticks.appendChild(tick);
        });
    }
}

const sliderDomain = [0, 38];
const baseDate = "20240621055000";
const timeManager = new TimeManager(baseDate);

// const yjRainScale = () => {
//     const domain = [0, 1, 4, 8, 12, 16, 24, 32, 40, 48, 56, 64, 80, 200];
//     const range = [
//         "rgba(204, 255, 255, 0.0)",
//         "rgba(102, 255, 255, 0.0)",
//         "rgba(0, 204, 255, 0.8)",
//         "rgba(0, 153, 255, 0.8)",
//         "rgba(51, 102, 255, 0.8)",
//         "rgba(51, 255, 0, 0.8)",
//         "rgba(51, 204, 0, 0.8)",
//         "rgba(25, 153, 0, 0.8)",
//         "rgba(255, 255, 0, 0.8)",
//         "rgba(255, 204, 0, 0.8)",
//         "rgba(255, 153, 0, 0.8)",
//         "rgba(255, 80, 102, 0.8)",
//         "rgba(255, 0, 0, 0.8)",
//         "rgba(183, 0, 16, 0.8)"
//     ]
//     return domain.map((v, i) => [v, range[i]]).flat();
// };

// const getStepColorscale = () => {
//     let result = yjRainScale()
//     result.unshift("rgba(0, 0, 0, 0)")
//     return result
// }

// const stepScale = [
//     'step',
//     ['raster-value'],
//     ...getStepColorscale()
// ]

// const interpolateScale = [
//     'interpolate',
//     ['linear'],
//     ['raster-value'],
//     ...yjRainScale()
// ]

const rasterTileQuery = async (coords) => {
    const currentKey = preciptationHelper.currentVisibleLayer;
    const currentTileset = preciptationHelper.precipitation_tiles[currentKey].tileset_id;
    const currentBand = preciptationHelper.currentVisibleBand;

    const layers = ['precipitation']
    const bands = [currentBand]
    const layerString = layers.length > 0 ? `&layers=${layers.join(',')}` : ''
    const bandString = bands.length > 0 ? `&bands=${bands.join(',')}` : ''
    const response = await fetch(`https://api.mapbox.com/v4/${currentTileset}/tilequery/${coords[0]},${coords[1]}.json?${layerString}${bandString}&access_token=${mapboxgl.accessToken}`)
    const data = await response.json()
    return data
}

const batchRasterTileQuery = async (coords) => {
    const tileset_id = []
    const layers = []
    const bands = []

    for (const key in preciptationHelper.precipitation_tiles) {
        const tile = preciptationHelper.precipitation_tiles[key];
        if (tile.tileset_id) {
            if (!tileset_id.includes(tile.tileset_id)) {
                tileset_id.push(tile.tileset_id);
            }
            for (const layerid in tile.layers) {
                if (!layers.includes(layerid)) {
                    layers.push(layerid);
                }
                for (const bandid in tile.layers[layerid].bands) {
                    const band = tile.layers[layerid].bands[bandid].val;
                    if (!bands.includes(band)) {
                        bands.push(band);
                    }
                }
            }
        }
    }
    const layerString = layers.length > 0 ? `&layers=${layers.join(',')}` : ''
    const bandString = bands.length > 0 ? `&bands=${bands.join(',')}` : ''
    const response = await fetch(`https://api.mapbox.com/v4/${tileset_id}/tilequery/${coords[0]},${coords[1]}.json?${layerString}${bandString}&access_token=${mapboxgl.accessToken}`)
    const data = await response.json()
    return data
}

const reverseGeocode = async (coords) => {
    const response = await fetch(`https://api.mapbox.com/search/geocode/v6/reverse?longitude=${coords[0]}&latitude=${coords[1]}&language=ja&country=jp&types=place&access_token=${mapboxgl.accessToken}`)
    const data = await response.json()
    return data
}

const getLightPreset = () => {
    const HHmm = timeManager.getHHmm();
    const hour = parseInt(HHmm.slice(0, 2), 10);
    lightPreset = 'dawn';
    if (hour >= 4 && hour < 6) lightPreset = 'dawn';
    else if (hour >= 6 && hour < 17) lightPreset = 'day';
    else if (hour >= 17 && hour < 19) lightPreset = 'dusk';
    else lightPreset = 'night';
    return lightPreset;
}

const setLocalEffects = (lng, lat) => {

    reverseGeocode([lng, lat]).then((data) => {
        if (data.features.length) {
            const placeName = data.features[0].properties.name;
            const geoName = document.getElementById('geo-name');
            if (geoName) {
                geoName.textContent = placeName;
                document.getElementById('area-panel').style.display = 'flex';
            }
        }
    });

    rasterTileQuery([lng, lat]).then((data) => {

        let precipitation = 0.0;
        let density = 0.0;
        let intensity = 0.0;
        let highColor = 'rgb(225, 236, 248)';
        let modelLightIntensity = 5.0;
        //let lightPreset = getLightPreset();
        if (data.features.length) {
            precipitation = data.features[0].properties['val'];
            if (precipitation > 1) {
                density = precipitation * 0.01 * 2
                if (density > 1) {
                    density = 1.0
                }
                intensity = density
            }
            if (density > 0.3) {
                highColor = 'rgb(71, 76, 89)';
                modelLightIntensity = 1.0;
                //lightPreset = 'dusk';
            }
            // console.log(`Tilequery value: ${precipitation}`);
            // console.log(`Density: ${density}`);
            // console.log(`Intensity: ${intensity}`);
            // console.log(`High Color: ${highColor}`);
        }

        map.setRain({
            density: [
                'interpolate',
                ['linear'],
                ['zoom'],
                14.99, 0.0,
                15, density
            ],
            intensity: [
                'interpolate',
                ['linear'],
                ['zoom'],
                14.99, 0.0,
                15, 1.0
            ],
            //color: '#919191',
            opacity: 0.6,
            'center-thinning': 0,
            direction: [0, 90],
            'droplet-size': [1, 50],
            'distortion-strength': 0.5,
            vignette: 0.5,
            vignetteColor: '#6e6e6e'
        })

        const weather = getWeather(precipitation);
        const model = getModel(weather);
        // if (model) {
        //     moveModel(model.name, [lng, lat], model.height);
        // }

        const geoWeather = document.getElementById('geo-weather');
        if (geoWeather) {
            geoWeather.innerHTML = '';
            let iconUrl = getWeatherIcon(weather);
            if (iconUrl) {
                const img = document.createElement('img');
                img.src = iconUrl;
                img.className = 'weather-icon';
                geoWeather.appendChild(img);
                document.getElementById('area-panel').style.display = 'flex';
            }
        }

        // if (weather !== 'sunny') {
        //     map.setFog({
        //         color: highColor, // Lower atmosphere
        //         'high-color': highColor, // Upper atmosphere
        //         //'horizon-blend': 0.02, // Atmosphere thickness (default 0.2 at low zooms)
        //         'space-color': highColor, // Background color
        //         //'star-intensity': 0.6 // Background star brightness (default 0.35 at low zoooms )
        //     })
        // } else {
        //     const style = map.getStyle();
        //     if (style && style.fog) {
        //         style.fog = {};
        //         map.setStyle(style);
        //     }
        // }
        //modelLight.intensity = modelLightIntensity;
        // map.setConfigProperty('basemap', 'lightPreset', lightPreset);


    })

    batchRasterTileQuery([lng, lat]).then((data) => {
        if (data.features.length > 0) {
            const deduped = new Map();
            // Iterate in reverse so later entries take precedence
            for (let i = data.features.length - 1; i >= 0; i--) {
                const feature = data.features[i];
                const band = feature.properties.tilequery.band;
                if (!deduped.has(band)) {
                    deduped.set(band, {
                        band_jstyyyyMMddHHmmSS: toJST(band),
                        band: band,
                        value: feature.properties.val[0]
                    });
                }
            }
            const results = Array.from(deduped.values());
            results.sort((a, b) => a.band_jstyyyyMMddHHmmSS.localeCompare(b.band_jstyyyyMMddHHmmSS));
            showPrecipitationChart(results);
        }
    });
}

// const SUNNY = { name: "the_sun.glb", size: 40, height: 3000 };
// const CLOUDY = { name: 'cloud_ring.glb', size: 140, height: 200 };
// const RAINY = { name: 'cloud_ring.glb', size: 140, height: 200 };

let preciptationHelper = null;
function addPrecipitationLayers(map) {

    preciptationHelper = new PrecipitationLayerHelper(map, timeManager);

    const values = Array.from({ length: sliderDomain[1] - sliderDomain[0] + 1 }, (_, i) => sliderDomain[0] + i);
    values.forEach((value) => {
        const offset = getMinutesOffset(value);
        let yyyyMMddHHmmSS = timeManager.getyyyyMMddHHmmSS(offset);
        if (offset > 30 && offset <= 60) {
            // yyyyMMddHHmmSS = timeManager.getyyyyMMddHHmmSS(offset);
            // do nothing, use the same time
        } else if (offset > 60 && offset <= 360) {
            tileset_time = getLastHalfOrExactHour(yyyyMMddHHmmSS, false);
        } else {
            tileset_time = getLastExactHour(yyyyMMddHHmmSS, false);
        }
        preciptationHelper.addLayer(yyyyMMddHHmmSS);
    });

    const timeslider = document.getElementById('slider')
    timeslider.max = sliderDomain[sliderDomain.length - 1]
    timeslider.value = 12

    function loadFirstLayer() {
        if (!preciptationHelper.checkAllSourcesLoaded()) {
            setTimeout(loadFirstLayer, 10);
            return;
        }
        preciptationHelper.visibleLayer(baseDate);
        addCityPanels();
        setCurrentTime();
        updateLegendBar();
    }
    loadFirstLayer();
}

function setCurrentTime() {
    const currentTimeBox = document.getElementById('current-time');
    if (currentTimeBox) {
        currentTimeBox.textContent = timeManager.getFormattedDateTime();
    }
}
function inputBand(val) {
    const minutesOffset = getMinutesOffset(val);
    timeManager.updateTimeByOffset(minutesOffset)
    preciptationHelper.visibleLayer(timeManager.getyyyyMMddHHmmSS(minutesOffset));
    setCurrentTime();
}
window.inputBand = inputBand;

function changeBand() {
    addCityPanels();
    const zoom = map.getZoom();
    if (zoom > 15) {
        // clearModels();
        setLocalEffects(map.getCenter().lng, map.getCenter().lat);
    }
    map.setConfigProperty('basemap', 'lightPreset', getLightPreset());
}
window.changeBand = changeBand;

// let modelLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1.0);
function addThreeboxLayer(map) {
    map.addLayer({
        id: 'threebox-layer',
        type: 'custom',
        renderingMode: '3d',
        minzoom: 16,
        onAdd: function (map, mbxContext) {

            window.tb = new Threebox(
                map,
                mbxContext,
                { defaultLights: true }
            );

            // Add a hemisphere light to the Threebox scene to simulate natural sky/ground ambient light.
            tb.scene.add(modelLight);

        },
        render: function (gl, matrix) {
            window.tb.update();
        }

    })
}

let cg_models = {}
let rotateRequestId = null;
let isRotating = false;
async function loadModel(name, scale) {
    const type = name.substring(name.lastIndexOf('.') + 1)
    const options = {
        obj: `./assets/models/${name}`,
        type: type,
        scale: scale,
        units: 'meters',
        rotation: { x: 90, y: 270, z: 0 }, // default rotation
        anchor: 'center'
    }
    window.tb.loadObj(options, function (model) {
        // Add a PointLight at the center of the model to simulate sunlight
        // const pointLight = new THREE.PointLight(0xffffff, 5, 1000);
        // pointLight.position.set(0, 0, 0); // center of the model
        // model.add(pointLight);
        cg_models[name] = {
            model: model,
            scale: scale
        }
    })
}

function clearModels() {
    Object.keys(cg_models).forEach(name => {
        moveModel(name, [0, 0], -1000);
    });
}

function moveModel(name, coordinates, height = 400) {
    const model = cg_models[name].model
    window.tb.add(model)
    model.setCoords([coordinates[0], coordinates[1], height]);
    //model.set({ position: { x: 0, y: 0, z: 0 } })
    return model
}

function getWeather(precipitation) {
    if (precipitation >= 0 && precipitation <= 1) {
        return 'sunny';
    } else if (precipitation > 1 && precipitation < 10) {
        return 'cloudy';
    } else if (precipitation >= 10) {
        return 'rainy';
    }
    return '';
}

function getWeatherIcon(weather) {
    const lightPreset = getLightPreset();
    if (weather === 'sunny') {
        if (lightPreset === 'dusk' || lightPreset === 'night') {
            return './assets/images/moon.png';
        } else{
            return './assets/images/sun.png';
        }
    } else if (weather === 'cloudy') {
        if (lightPreset === 'dusk' || lightPreset === 'night') {
            return './assets/images/cloud-moon.png';
        } else{
            return './assets/images/cloudy.png';
        }
    } else if (weather === 'rainy') {
        return './assets/images/rainy-day.png';
    }
    return '';
}

function getModel(weather) {
    // if (weather === 'cloudy') {
    //     return CLOUDY;
    // } else if (weather === 'rainy') {
    //     return RAINY;
    // }
    return '';
}

function addCityPanels() {
    // Create city panel container
    const panel = document.getElementById('city-panel');
    panel.innerHTML = ''; // Clear existing content
    // panel.id = 'city-panel';
    // panel.className = 'city-panel';
    // document.body.appendChild(panel);

    Object.entries(cities).forEach(([key, { label, coordinates }]) => {
        const box = document.createElement('div');
        box.className = 'city-box';
        box.textContent = label;
        let localWeather = 'sunny'; // default fallback
        rasterTileQuery(coordinates).then((data) => {
            if (data.features.length) {
                const val = data.features[0].properties['val'];
                localWeather = getWeather(val);
                let iconUrl = getWeatherIcon(localWeather);

                if (iconUrl) {
                    const img = document.createElement('img');
                    img.src = iconUrl;
                    img.alt = label;
                    img.className = 'weather-icon';
                    box.appendChild(img);
                }
            }
        });
        box.addEventListener('click', () => {
            boxClick(coordinates, 15.5, 75, true);
        });
        panel.appendChild(box);
    });
}

const boxClick = (coordinates, zoom, pitch, rotateOnce = true) => {
    if (rotateRequestId !== null) {
        cancelAnimationFrame(rotateRequestId);
        rotateRequestId = null;
    }
    isRotating = false;
    map.flyTo({
        center: coordinates,
        zoom: zoom,
        pitch: pitch,
        bearing: 0,
        speed: 7.0,
        curve: 1,
        easing: (t) => t
    });
    if (!rotateOnce) {
        return;
    }
    map.once('moveend', () => {
        let totalRotation = 0;
        isRotating = true;
        function rotateOnce() {
            if (totalRotation >= 360) {
                isRotating = false;
                return;
            }
            const bearing = map.getBearing();
            const step = 0.1;
            map.setBearing(bearing + step);
            totalRotation += step;
            rotateRequestId = requestAnimationFrame(rotateOnce);
        }
        rotateOnce();
    });
}
window.boxClick = boxClick;

const getMinutesOffset = (value) => {
    if (value < 24) {
        return (value - 12) * 5;
    } else {
        const rawOffset = (value - 23) * 60;
        const targetTime = timeManager.getyyyyMMddHHmmSS(rawOffset);

        let adjustedTime;
        if (rawOffset > 30 && rawOffset <= 60) {
            return rawOffset;
        } else if (rawOffset > 60 && rawOffset <= 360) {
            adjustedTime = getLastHalfOrExactHour(targetTime, false);
        } else if (rawOffset > 360) {
            adjustedTime = getLastExactHour(targetTime, false);
        }

        const base = timeManager.baseDate;
        const adjusted = parseDateStringJST(adjustedTime);
        // console.log(`Adjusted time for ${value}: ${adjustedTime} (base: ${base}) (adjusted: ${adjusted})`);
        return Math.floor((adjusted - base) / 60000); // difference in minutes
    }
}

const loadMap = () => {
    map = new mapboxgl.Map({
        container: 'map',
        center: defaultCoordinates,
        //style: 'mapbox://styles/mapbox/streets-v12',
        zoom: 3.7,
        minZoom: 3,
        language: 'ja',
        scrollZoom: true,
        projection: 'mercator',
    })

    map.on('load', () => {

        //map.setConfigProperty('basemap', 'theme', 'faded');

        // addThreeboxLayer(map);
        // loadModel(SUNNY.name, SUNNY.size);
        // loadModel(CLOUDY.name, CLOUDY.size);
        // loadModel(RAINY.name, RAINY.size);

        addPrecipitationLayers(map);

    });

    map.on('moveend', () => {
        const center = map.getCenter();
        const lng = center.lng;
        const lat = center.lat;
        // Custom red marker element
        const el = document.createElement('div');
        el.style.width = '8px';
        el.style.height = '8px';
        el.style.borderRadius = '50%';
        el.style.backgroundColor = 'red';
        el.style.border = '1px solid white';

        if (window.miniMapMarker) {
            window.miniMapMarker.remove();
        }
        const zoom = map.getZoom();
        if (zoom > 5) {
            window.miniMapMarker = new mapboxgl.Marker({ element: el })
                .setLngLat([lng, lat])
                .addTo(window.miniMap);
        }

        if (zoom < 15) {
            //map.setConfigProperty('basemap', 'lightPreset', 'day');
            // const style = map.getStyle();
            // if (style && style.fog) {
            //     style.fog = {};
            //     map.setStyle(style);
            // }
            document.getElementById('geo-name').textContent = '';
            document.getElementById('geo-weather').innerHTML = '';
            //clearModels();
            document.getElementById('area-panel').style.display = 'none';
            document.getElementById('legend').style.display = 'block';
            document.getElementById('precipitation-chart').style.display = 'none';
            return;
        } else {
            document.getElementById('legend').style.display = 'none';
        }
        if (!isRotating) {
            setLocalEffects(lng, lat);
        }

    });

    function cancelRotation() {
        if (rotateRequestId !== null) {
            cancelAnimationFrame(rotateRequestId);
            rotateRequestId = null;
        }
        isRotating = false;
    }

    map.on('dragstart', cancelRotation);
    map.on('mousedown', cancelRotation);
    map.on('wheel', cancelRotation);
    map.on('touchstart', cancelRotation);

    window.miniMap = new mapboxgl.Map({
        container: 'mini-map',
        style: 'mapbox://styles/kenji-shima/clnxv0r9k003b01rff933dq05',
        center: map.getCenter(),
        zoom: 1.2,
        interactive: false,
        attributionControl: false,
        projection: 'mercator',
        //language: 'ja',
    });

    window.miniMap.on('load', () => {
        const labelLayerTypes = ['symbol'];
        window.miniMap.getStyle().layers.forEach(layer => {
            if (labelLayerTypes.includes(layer.type)) {
                window.miniMap.setLayoutProperty(layer.id, 'visibility', 'none');
            }
        });
    });

    // Allow clicking the mini map to trigger boxClick with defaultCoordinates
    document.getElementById('mini-map').addEventListener('click', () => {
        if (window.miniMapMarker) {
            window.miniMapMarker.remove();
            window.miniMapMarker = null;
        }
        boxClick(defaultCoordinates, 4, 0, false);
    });
}

loadMap()

map.on('click', (e) => {
    console.log('Map clicked at:', [e.lngLat.lng, e.lngLat.lat]);
});

// Renders a precipitation bar chart using ApexCharts
function showBarChart(data) {
    let chartContainer = document.getElementById('precipitation-chart');
    chartContainer.style.display = 'block';
    // Destroy previous chart instance if present
    if (chartContainer._apexChartObj && typeof chartContainer._apexChartObj.destroy === 'function') {
        chartContainer._apexChartObj.destroy();
    }

    const categories = data.map(d => d.time);
    const options = {
        annotations: {
            xaxis: data
                .map((d, i) => d.now ? { x: d.time, borderColor: '#d00', label: { style: { color: '#d00' } } } : null)
                .filter(Boolean)
        },
        chart: {
            type: 'bar',
            height: 200
        },
        title: {
            text: '降雨量の推移',
            align: 'center',
            margin: 10,
            offsetY: 0,
            style: {
                fontSize: '14px',
                fontWeight: 'bold',
                color: '#333'
            }
        },
        dataLabels: {
            enabled: false
        },
        series: [{
            name: '降雨量',
            data: data.map(d => d.val)
        }],
        xaxis: {
            categories: categories,
            title: {
                text: '時間'
            },
            labels: {
                rotate: -70,
                style: {
                    fontSize: '9px'
                },
                formatter: function (val, index) {
                    if (data[index] && data[index].now) {
                        // Attempt rich text style for "now" label (ApexCharts supports HTML in some cases)
                        // fallback: just return val; for advanced, could try: return '<span style="color:#d00">' + val + '</span>';
                        return val;
                    }
                    return val;
                }
            }
        },
        yaxis: {
            max: 40,
            title: {
                text: '雨量（mm）'
            }
        },
        tooltip: {
            y: {
                formatter: val => `${val} mm`
            },
        }
    };

    const chart = new ApexCharts(chartContainer, options);
    chart.render();
    chartContainer._apexChartObj = chart;
}
// Example usage:
function showPrecipitationChart(data) {
    const results = [];
    data.forEach(item => {
        const time = item.band_jstyyyyMMddHHmmSS.slice(8, 10) + ':' + item.band_jstyyyyMMddHHmmSS.slice(10, 12);
        const val = parseFloat(item.value.toFixed(2));
        const isNow = item.band_jstyyyyMMddHHmmSS === timeManager.getRefyyyyMMddHHmmSS();
        results.push({ time: time, val: val, now: isNow });
    });
    showBarChart(results)
};
</script>

</html>
